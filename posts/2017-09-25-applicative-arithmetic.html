<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Applicative Arithmetic - Donnacha Oisín Kidney</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Applicative Arithmetic</h2>

            <div class="info">
    Posted on September 25, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="safer-arithmetic">Safer Arithmetic</h1>
<p>There are a couple partial functions in the Haskell Prelude which people seem to agree shouldn’t be there. <code class="sourceCode haskell">head</code>, for example, will throw an error on an empty list. Most seem to agree that it should work something more like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">head<span class="ot"> ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
head <span class="fu">=</span> foldr (const <span class="fu">.</span> <span class="dt">Just</span>) <span class="dt">Nothing</span></code></pre></div>
<p>There are other examples, like <code class="sourceCode haskell">last</code>, <code class="sourceCode haskell"><span class="fu">!!</span></code>, etc.</p>
<p>One which people <em>don’t</em> agree on, however, is division by zero. In the current Prelude, the following will throw an error:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dv">1</span> <span class="fu">/</span> <span class="dv">0</span></code></pre></div>
<p>The “safe” version might have a signature like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(/) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</code></pre></div>
<p>However, this turns out to be quite a headache for writing code generally. So the default is the (somewhat) unsafe version.</p>
<p>Is there a way to introduce a safer version without much overhead, so the programmer is given the option? Of course! With some newtype magic, it’s pretty simple to write a wrapper which catches division by zero in some arbitrary monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">AppNum</span> f a <span class="fu">=</span> <span class="dt">AppNum</span>
    {<span class="ot"> runAppNum ::</span> f a
    } <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Applicative</span>,<span class="dt">Monad</span>,<span class="dt">Alternative</span>,<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">MonadFail</span>)

<span class="kw">instance</span> (<span class="dt">Num</span> a, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span>
         <span class="dt">Num</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span>
    abs <span class="fu">=</span> fmap abs
    signum <span class="fu">=</span> fmap signum
    (<span class="fu">+</span>) <span class="fu">=</span> liftA2 (<span class="fu">+</span>)
    (<span class="fu">*</span>) <span class="fu">=</span> liftA2 (<span class="fu">*</span>)
    (<span class="fu">-</span>) <span class="fu">=</span> liftA2 (<span class="fu">-</span>)
    negate <span class="fu">=</span> fmap negate
    fromInteger <span class="fu">=</span> pure <span class="fu">.</span> fromInteger

<span class="kw">instance</span> (<span class="dt">Fractional</span> a, <span class="dt">MonadFail</span> f, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span>
         <span class="dt">Fractional</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span>
    fromRational <span class="fu">=</span> pure <span class="fu">.</span> fromRational
    xs <span class="fu">/</span> ys <span class="fu">=</span>
        ys <span class="fu">&gt;&gt;=</span>
        \<span class="kw">case</span>
            <span class="dv">0</span> <span class="ot">-&gt;</span> fail <span class="st">&quot;divide by zero&quot;</span>
            y <span class="ot">-&gt;</span> fmap (<span class="fu">/</span> y) xs</code></pre></div>
<p>I’m using the <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XLambdaCase</span></code> extension and <code class="sourceCode haskell"><span class="dt">MonadFail</span></code> here.</p>
<h1 id="free-applicatives">Free Applicatives</h1>
<p>You’ll notice that you only need <code class="sourceCode haskell"><span class="dt">Applicative</span></code> for most of the arithmetic operations above. In fact, you only need <code class="sourceCode haskell"><span class="dt">Monad</span></code> when you want to examine the contents of <code class="sourceCode haskell">f</code>. Using that fact, we can manipulate expression trees using the free applicative from the <a href="https://hackage.haskell.org/package/free">free</a> package. Say, for instance, we want to have free variables in our expressions. Using <code class="sourceCode haskell"><span class="dt">Either</span></code>, it’s pretty easy:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) <span class="dt">Integer</span>

<span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span>
var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Left</span></code></pre></div>
<p>We can collect the free variables from an expression:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
vars <span class="fu">=</span> runAp_ (either pure (const [])) <span class="fu">.</span> runAppNum

x <span class="fu">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">WithVars</span>
y <span class="fu">=</span> var <span class="st">&quot;y&quot;</span>
z <span class="fu">=</span> var <span class="st">&quot;z&quot;</span>

vars (x <span class="fu">+</span> y <span class="fu">+</span> z) <span class="co">-- [&quot;y&quot;,&quot;z&quot;]</span></code></pre></div>
<p>If we want to sub in, though, we’re going to run into a problem: we can’t just pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span></code> because you’re able to construct values like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bad ::</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
bad <span class="fu">=</span> <span class="dt">AppNum</span> (liftAp (<span class="dt">Left</span> <span class="st">&quot;oh noes&quot;</span>))</code></pre></div>
<p>We’d need to pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)</code> as well; in fact you’d need a map for every possible type. Which isn’t feasible.</p>
<h1 id="gadts">GADTs</h1>
<p>Luckily, we <em>can</em> constrain the types of variables in our expression so that they’re always <code class="sourceCode haskell"><span class="dt">Integer</span></code>, using a GADT:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Variable</span> a <span class="kw">where</span>
        <span class="dt">Constant</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Variable</span> a
        <span class="dt">Variable</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Variable</span> <span class="dt">Integer</span></code></pre></div>
<p>The type above seems useless on its own: it doesn’t have a <code class="sourceCode haskell"><span class="dt">Functor</span></code> instance, never mind an <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, so how can it fit into <code class="sourceCode haskell"><span class="dt">AppNum</span></code>?</p>
<p>The magic comes from the free applicative, which converts any type of kind <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> into an applicative. With that in mind, we can change around the previous code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> <span class="dt">Variable</span>) <span class="dt">Integer</span>

<span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span>
var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Variable</span>

<span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
vars <span class="fu">=</span> runAp_ f <span class="fu">.</span> runAppNum
  <span class="kw">where</span>
<span class="ot">    f ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]
    f (<span class="dt">Constant</span> _) <span class="fu">=</span> []
    f (<span class="dt">Variable</span> s) <span class="fu">=</span> [s]</code></pre></div>
<p>And write the function to sub in for us:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">variableA
<span class="ot">    ::</span> <span class="dt">Applicative</span> f
    <span class="ot">=&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> f <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> f a
variableA _ (<span class="dt">Constant</span> x) <span class="fu">=</span> pure x
variableA f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s

<span class="ot">variable ::</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> a
variable _ (<span class="dt">Constant</span> x) <span class="fu">=</span> x
variable f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s

<span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
replace m <span class="fu">=</span> runAp (variable (m <span class="fu">Map.!</span>)) <span class="fu">.</span> runAppNum

replace (Map.fromList [(<span class="st">&quot;z&quot;</span>,<span class="dv">2</span>), (<span class="st">&quot;y&quot;</span>,<span class="dv">3</span>)]) (x <span class="fu">+</span> y <span class="fu">+</span> z)
<span class="co">-- 6</span></code></pre></div>
<h1 id="accumulation">Accumulation</h1>
<p>This will fail if a free variable isn’t present in the map, unfortunately. To fix it, we <em>could</em> use <code class="sourceCode haskell"><span class="dt">Either</span></code> instead of <code class="sourceCode haskell"><span class="dt">Identity</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Integer</span>
replace m <span class="fu">=</span>
    runAp
        (variableA <span class="fu">$</span>
         \s <span class="ot">-&gt;</span>
              maybe (<span class="dt">Left</span> s) <span class="dt">Right</span> (Map.lookup s m)) <span class="fu">.</span>
    runAppNum</code></pre></div>
<p>But this only gives us the first missing variable encountered. We’d like to get back <em>all</em> of the missing variables, ideally: accumulating the <code class="sourceCode haskell"><span class="dt">Left</span></code>s. <code class="sourceCode haskell"><span class="dt">Either</span></code> doesn’t accumulate values, as if it did it would <a href="https://stackoverflow.com/a/23611068/4892417">break the monad laws</a>.</p>
<p>There’s no issue with the <em>applicative</em> laws, though, which is why the <a href="https://hackage.haskell.org/package/validation-0.5.4">validation</a> package provides a <em>non-monadic</em> either-like type, which we can use here.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">AccValidation</span> [<span class="dt">String</span>] <span class="dt">Integer</span>
replace m <span class="fu">=</span>
    runAp
        (variableA <span class="fu">$</span>
         \s <span class="ot">-&gt;</span>
              maybe (<span class="dt">AccFailure</span> [s]) pure (Map.lookup s m)) <span class="fu">.</span>
    runAppNum

replace (Map.fromList []) (x <span class="fu">+</span> y <span class="fu">+</span> z)
<span class="co">-- AccFailure [&quot;y&quot;,&quot;z&quot;]</span></code></pre></div>
<h1 id="other-uses">Other uses</h1>
<p>There are a bunch more applicatives you could use instead of <code class="sourceCode haskell"><span class="dt">Either</span></code>. Using lists, for instance, you could calculate the possible outcomes from a range of inputs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">range<span class="ot"> ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
range <span class="fu">=</span> runAp (variable (const [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>])) <span class="fu">.</span> runAppNum

range (x <span class="fu">+</span> y <span class="fu">+</span> z)
<span class="co">-- [3,4,5,4,5,6,5,6,7]</span></code></pre></div>
<p>Or you could ask the user for input:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">query ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Integer</span>
query <span class="fu">=</span> runAp (variable f) <span class="fu">.</span> runAppNum
  <span class="kw">where</span>
    f s <span class="fu">=</span> <span class="kw">do</span>
      putStr <span class="st">&quot;Input a value for &quot;</span>
      putStrLn s
      fmap read getLine</code></pre></div>
<p>Finally, and this one’s a bit exotic, you could examine every variable in turn, with defaults for the others:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zygo
<span class="ot">    ::</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x)
    <span class="ot">-&gt;</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b)
    <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a
    <span class="ot">-&gt;</span> [b]
zygo (<span class="ot">l ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x) (<span class="ot">c ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b) <span class="fu">=</span>
    fst <span class="fu">.</span> go id
  <span class="kw">where</span>
<span class="ot">    go ::</span> forall c<span class="fu">.</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Ap</span> f c <span class="ot">-&gt;</span> ([b], c)
    go _ (<span class="dt">Pure</span> x) <span class="fu">=</span> ([], x)
    go k (<span class="dt">Ap</span> x f) <span class="fu">=</span> (c x (k <span class="fu">.</span> ls) <span class="fu">:</span> xs, ls lx)
      <span class="kw">where</span>
        (xs,ls) <span class="fu">=</span> go (k <span class="fu">.</span> (<span class="fu">$</span> lx)) f
        lx <span class="fu">=</span> l x

<span class="ot">examineEach ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>]
examineEach <span class="fu">=</span> zygo (variable (const <span class="dv">1</span>)) g <span class="fu">.</span> runAppNum
  <span class="kw">where</span>
<span class="ot">    g ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> b
    g (<span class="dt">Constant</span> x) rhs _ <span class="fu">=</span> rhs x
    g (<span class="dt">Variable</span> _) rhs i <span class="fu">=</span> rhs i</code></pre></div>
<p>This produces a list of functions which are equivalent to subbing in for each variable with the rest set to 1.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
