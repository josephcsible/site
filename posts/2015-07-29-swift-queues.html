<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Deques, Queues, and Lists in Swift with Indirect - Donnacha Oisín Kidney</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>Deques, Queues, and Lists in Swift with Indirect</h2>

            <div class="info">
    Posted on July 29, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Swift.html">Swift</a>
    
</div>

<p>Recursive enums have finally arrived. Woo! The first thing to do with these is to make a recursive list:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public enum List&lt;Element&gt; {
  <span class="kw">case</span> Nil
  indirect <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: List&lt;Element&gt;)
}</code></pre></div>
<p>The <code class="sourceCode scala">head</code> stores the element, and <code class="sourceCode scala">tail</code> is a reference to the rest of the list. As you can imagine, getting at the <code class="sourceCode scala">head</code> is pretty easy, while accessing elements further along is more difficult. There’s a common pattern for dealing with these recursive structures: if you have a function that performs some transformation on a list, it will take the <code class="sourceCode scala">head</code>, perform that transformation on it, and then call itself recursively on the <code class="sourceCode scala">tail</code>. If it’s given an empty list, it returns an empty list. For instance, here’s the <code class="sourceCode haskell">map</code> function, defined in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map _ []     <span class="fu">=</span> []
map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</code></pre></div>
<p>The two lines are analogous to a switch statement in Swift. The parameters for <code class="sourceCode haskell">map</code> are a transformation function and a list. So, the first line has <code class="sourceCode haskell">_</code> (wildcard) for the function, and <code class="sourceCode haskell">[]</code> (empty) for the list, meaning it will match any function and an empty list. It returns an empty list.</p>
<p>The second line matches a function (which it assigns the name <code class="sourceCode scala">f</code>) and then decomposes the list it’s given into a head (<code class="sourceCode scala">x</code>) and tail (<code class="sourceCode scala">xs</code>). It then calls <code class="sourceCode scala">f</code> on the head, and prepends (the <code class="sourceCode scala">:</code> operator is prepends, also called “cons” by convention) the result to itself called recursively on the tail.</p>
<p>With switch statements and the <code class="sourceCode scala">indirect</code> keyword, we’re getting pretty close to that level of brevity (terseness?) in Swift:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; List&lt;T&gt; {
    switch self {
    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span>
    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail): <span class="kw">return</span>
      .<span class="fu">Cons</span>(head: <span class="fu">transform</span>(head), tail: tail.<span class="fu">map</span>(transform))
    }
  }
}</code></pre></div>
<p>We can define our own “cons”, to clean it up a little. We’re not allowed to use <code class="sourceCode scala">:</code>, so I went with <code class="sourceCode scala">|&gt;</code>, which is, in my mind, reasonably representative of “cons”.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">infix operator |&gt; {
  associativity right
  precedence <span class="dv">100</span>
}

public func |&gt; &lt;T&gt;(lhs: T, rhs: List&lt;T&gt;) -&gt; List&lt;T&gt; {
  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)
}

extension List {
  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; List&lt;T&gt; {
    switch self {
    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span>
    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):
      <span class="kw">return</span> <span class="fu">transform</span>(head) |&gt; tail.<span class="fu">map</span>(transform)
    }
  }
}</code></pre></div>
<p>Pretty soon you can start doing some elegant and exciting things with lists. The recursive pattern is <em>very</em> well suited to higher-order functions and other FP staples. Take, for instance, the <code class="sourceCode scala">reduce</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  public func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) -&gt; T) -&gt; T {
    switch self {
    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> initial
    <span class="kw">case</span> let .<span class="fu">Cons</span>(h, t):
      <span class="kw">return</span> t.<span class="fu">reduce</span>(<span class="fu">combine</span>(initial, h), combine: combine)
    }
  }
}</code></pre></div>
<p>Or a transposing function:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func transpose&lt;T&gt;(mat: List&lt;List&lt;T&gt;&gt;) -&gt; List&lt;List&lt;T&gt;&gt; {
  switch mat {
  <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs) where x.<span class="fu">isEmpty</span>: <span class="kw">return</span> <span class="fu">transpose</span>(xs)
  <span class="kw">case</span> let .<span class="fu">Cons</span>(.<span class="fu">Cons</span>(x, xs), xss):
    <span class="kw">return</span> (x |&gt; xss.<span class="fu">flatMap</span>{$<span class="fl">0.f</span>irst}) |&gt;
      <span class="fu">transpose</span>(xs |&gt; xss.<span class="fu">map</span>{$<span class="fl">0.</span>tail})
  default: <span class="kw">return</span> .<span class="fu">Nil</span>
  }
}

let jo: List&lt;List&lt;Int&gt;&gt; = [[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]]
<span class="fu">transpose</span>(jo) <span class="co">// [[1, 1, 1], [2, 2, 2], [3, 3, 3]]</span></code></pre></div>
<p>You can do <code class="sourceCode scala">foldr</code>, which is like <code class="sourceCode scala">reduce</code>, but works in reverse:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  func foldr&lt;T&gt;(initial: T, @noescape combine: (element: Element, accumulator: T) -&gt; T) -&gt; T {
    switch self {
    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> initial
    <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs):
      <span class="kw">return</span> <span class="fu">combine</span>(
        element: x,
        accumulator: xs.<span class="fu">foldr</span>(initial, combine: combine)
      )
    }
  }
}</code></pre></div>
<p>Using <code class="sourceCode scala">foldr</code>, you can get all of the non-empty subsequences of a list:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  <span class="kw">var</span> subsequences: List&lt;List&lt;Element&gt;&gt; {
    switch self {
    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span>
    <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs):
      <span class="kw">return</span> [x] |&gt; xs.<span class="fu">subsequences</span>.<span class="fu">foldr</span>([]) {
        (ys, r) in ys |&gt; (x |&gt; ys) |&gt; r
      }
    }
  }
}
let jo: List = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
jo.<span class="fu">subsequences</span> <span class="co">// [[1], [2], [1, 2], [1, 3], [2, 3], [1, 2, 3]]</span></code></pre></div>
<p>(these examples are all translated from the Haskell standard library) Lists are extremely fun, and some functions you would have found yourself writing on 10-15 lines can be got into 2-3. To get a better feel for playing around with lists, it’s useful to have them conform to some protocols that make them easier to work with in a playground.</p>
<p>For instance, making a list currently looks like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let jo: List = <span class="dv">1</span> |&gt; <span class="dv">2</span> |&gt; <span class="dv">3</span> |&gt; .<span class="fu">Nil</span></code></pre></div>
<p>Which is fine, and better than:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let jo: List = .<span class="fu">Cons</span>(head: <span class="dv">1</span>, tail: .<span class="fu">Cons</span>(head: <span class="dv">2</span>, tail: .<span class="fu">Cons</span>(head: <span class="dv">3</span>, tail: .<span class="fu">Nil</span>)))</code></pre></div>
<p>but still not fantastic. The obvious next step is making <code class="sourceCode scala">List</code> <code class="sourceCode scala">ArrayLiteralConvertible</code>, but there’s a small catch. We don’t have an <code class="sourceCode scala">append</code> function for lists (yet). So we can’t, off the bat, do something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List : ArrayLiteralConvertible {
  public <span class="fu">init</span>(arrayLiteral: Element...) {
    <span class="kw">var</span> ret: List&lt;Element&gt; = .<span class="fu">Nil</span>
    <span class="kw">for</span> el in arrayLiteral { ret.<span class="fu">append</span>(el) }
    self = ret
  }
}</code></pre></div>
<p>And nor do I think we’d want to. Operations on the end of lists are slow: you have to walk along the entire list every time.</p>
<p>We could <em>reverse</em> the sequence we want to turn into a list, and prepend as we go. But… that’s inefficient too. Sure, <code class="sourceCode scala">Array</code>s are fast to reverse, but other sequences aren’t. For those that can’t be reversed lazily, you’re storing an extra sequence in memory unnecessarily.</p>
<p>But there’s something that we can use: generators. In Swift, generators are like super-imperative, crazy-unsafe recursive lists. When you can the <code class="sourceCode scala"><span class="fu">next</span>()</code> method on a generator, you get the “head” back. Crucially, though: <em>the generator is left with the tail</em>. Making use of this fact too often will lead to bugs, but if we wrap it up in <code class="sourceCode scala"><span class="kw">private</span></code>, it’s a perfect fit:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {
    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
      self = head |&gt; List(gen: gen)
    } <span class="kw">else</span> {
      self = .<span class="fu">Nil</span>
    }
  }
}</code></pre></div>
<p>The potential bug here is kind of interesting. If, instead of an infix operator for cons, we’d had a method on <code class="sourceCode scala">List</code> that did the same thing:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  public func <span class="fu">prepended</span>(<span class="kw">with</span>: Element) -&gt; List&lt;Element&gt; {
    <span class="kw">return</span> .<span class="fu">Cons</span>(head: <span class="kw">with</span>, tail: self)
  }
}</code></pre></div>
<p>We’d be able to curry that function in a <code class="sourceCode scala"><span class="fu">map</span>()</code>, and get an <code class="sourceCode scala">init</code> function that’s very pretty:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> g: G) {
    self = g.<span class="fu">next</span>().<span class="fu">map</span>(List(g: g).<span class="fu">prepended</span>) ?? .<span class="fu">Nil</span>
  }
}</code></pre></div>
<p>But it won’t run. Since the recursive call to the function is curried, it’s resolved before the <code class="sourceCode scala">g.<span class="fu">next</span>()</code> part. Which means that, regardless of whether <code class="sourceCode scala">g</code> returns <code class="sourceCode scala">nil</code> or not, the call will be made, causing an infinite loop of sadness. To fix it, you have to make the order of operations clear: <em>do not</em> make a recursive call if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {
    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
      self = head |&gt; List(gen: gen)
    } <span class="kw">else</span> {
      self = .<span class="fu">Nil</span>
    }
  }
  public init&lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;(_ seq: S) {
    self = List(gen: seq.<span class="fu">generate</span>())
  }
}

extension List : ArrayLiteralConvertible {
  public <span class="fu">init</span>(arrayLiteral: Element...) {
    self = List(arrayLiteral.<span class="fu">generate</span>())
  }
}</code></pre></div>
<p>This all makes it easy to initialise a list. Being able to <em>see</em> the list and its contents is also important. Currently, we’ve got this mess:</p>
<p><img class="aligncenter size-full wp-image-404" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-29-at-12-12-56.png" alt="Screen Shot 2015-07-29 at 12.12.56" width="660" height="39" /></p>
<p>When what we really want is a comma-separated list of the contents. We also probably want some demarcation at either end, so it’s easier to recognise nested lists. I’m not sure what the best demarcation would be: ideally it should be different to an Array’s square brackets, but not confusing either. I went with <code class="sourceCode scala">[:</code> and <code class="sourceCode scala">:]</code> in the end, though I’m not terribly happy about it:</p>
<p><img class="aligncenter size-full wp-image-406" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-29-at-12-27-53.png" alt="Screen Shot 2015-07-29 at 12.27.53" width="522" height="32" /></p>
<p>To get that printout on the right-hand-side of your playground, you need to make your type <code class="sourceCode scala">CustomDebugStringConvertible</code>. There’s one one interesting problem with this: how do you know the contents of your list are printable? You can’t extend your struct to have conditional conformance, like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List (where Element : CustomDebugStringConvertible) : CustomDebugStringConvertible {...</code></pre></div>
<p>However, you can’t just get a string representation of something that doesn’t have one. Luckily, <code class="sourceCode scala">String</code> has an initialiser that takes <em>anything</em>. It uses runtime reflection to do so. Here’s what the extension ends up looking like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List : CustomDebugStringConvertible {
  public <span class="kw">var</span> debugDescription: String {
    return<span class="st">&quot;[:&quot;</span> + <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(map{String(reflecting: $<span class="dv">0</span>)}) + <span class="st">&quot;:]&quot;</span>
  }
}</code></pre></div>
<p>To use the <code class="sourceCode scala"><span class="fu">join</span>()</code> function, of course, <code class="sourceCode scala">List</code> needs to conform to <code class="sourceCode scala">SequenceType</code>. We’ll need some generator that swaps out the current <code class="sourceCode scala">List</code> struct on each iteration, and returns the head. You <em>could</em> just use <code class="sourceCode scala">anyGenerator</code> but, since it’s a class, it’s significantly slower than defining a new struct.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct ListGenerator&lt;Element&gt; : GeneratorType, SequenceType {
  <span class="kw">private</span> <span class="kw">var</span> list: List&lt;Element&gt;
  public mutating func <span class="fu">next</span>() -&gt; Element? {
    switch list {
    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> nil
    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):
      list = tail
      <span class="kw">return</span> head
    }
  }
  public func <span class="fu">generate</span>() -&gt; ListGenerator { <span class="kw">return</span> self }
}

extension List : SequenceType {
  public func <span class="fu">generate</span>() -&gt; ListGenerator&lt;Element&gt; {
    <span class="kw">return</span> <span class="fu">ListGenerator</span>(list: self)
  }
}</code></pre></div>
<p>And you’ve got a <code class="sourceCode scala">SequenceType</code> that’s normal-looking and easy to work with.</p>
<h3 id="laziness">Laziness</h3>
<p>I’m not sure if this is entirely relevant here, but I <em>do</em> like laziness, so I thought I’d make a version of <code class="sourceCode scala">List</code> that was lazy. It turns out it’s easy to do: in fact, it was possible before <code class="sourceCode scala">indirect</code> enums. So, starting with the standard <code class="sourceCode scala">List</code> definition:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public enum LazyList&lt;Element&gt; {
  <span class="kw">case</span> Nil
  indirect <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: LazyList&lt;Element&gt;)
}</code></pre></div>
<p>Let’s make it lazy. The main idea would be to defer the resolution of <code class="sourceCode scala">tail</code>. What we really want is for tail to be a function that <em>returns</em> a list, rather than a list itself.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public enum LazyList&lt;Element&gt; {
  <span class="kw">case</span> Nil
  <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: () -&gt; LazyList&lt;Element&gt;)
}</code></pre></div>
<p>This is the reason that <code class="sourceCode scala">indirect</code> isn’t needed: because tail isn’t a list, all that’s stored in the enum is the reference to the function. This is what <code class="sourceCode scala">indirect</code> does automatically, or what the <code class="sourceCode scala">Box</code> struct did manually.</p>
<p>There are some more wrinkles with laziness. For instance, our old infix operator won’t work:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public func |&gt; &lt;T&gt;(lhs: T, rhs: LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {
  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)
}</code></pre></div>
<p>Again, because tail is meant to be a function that returns a list, not a list itself. This <em>would</em> work, but not in the way we intend it:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public func |&gt; &lt;T&gt;(lhs: T, rhs: LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {
  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: {rhs})
}</code></pre></div>
<p>Whatever’s to the right-hand-side of the operator will get resolved, and <em>then</em> put into the closure, which we don’t want. For instance, this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">printAndGiveList</span>() -&gt; LazyList&lt;Int&gt; {
  <span class="fu">print</span>(<span class="dv">2</span>)
  <span class="kw">return</span> .<span class="fu">Nil</span>
}

<span class="dv">2</span> |&gt; <span class="dv">1</span> |&gt; <span class="fu">printAndGiveList</span>()</code></pre></div>
<p>Will give you a “<code class="sourceCode scala">LazyList</code>”, but 2 gets printed, meaning that it’s not <em>really</em> behaving lazily.</p>
<p><code class="sourceCode scala">@autoclosure</code> to the rescue! This is a little annotation you put before your parameters that can let you decide when to evaluate the argument.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public func |&gt; &lt;T&gt;(lhs: T, @<span class="fu">autoclosure</span>(escaping) rhs: () -&gt; LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {
  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)
}</code></pre></div>
<p>The <code class="sourceCode scala">escaping</code> in the brackets is needed to signify that the closure will last longer than the lifetime of the scope it is declared in. If you test this new version with the <code class="sourceCode scala"><span class="fu">printAndGiveList</span>()</code> function, you’ll see that 2 does <em>not</em> get printed. In fact, the behaviour of this operator lets us use a lot of the same code from the strict list, <em>without</em> the strictness. (The generator initialiser, for instance: the same code, if used to initialise a lazy list, will work. In fact, if the underlying sequence that the generator comes from is lazy, <em>that laziness is maintained in the lazy list</em>. That’s pretty cool.)</p>
<p>There’s an interesting point to be made, here. The usual definition for a lazy programming language is one in which functions do not evaluate their arguments until they need to. In contrast, eager languages evaluate function arguments before the body of the function. This kind of makes it seem that you could treat Swift as a totally lazy language…</p>
<p>At any rate, this new-and-improved operator works exactly as we want it. It’s properly lazy. The rest is easy: every time <code class="sourceCode scala">tail</code> was used in <code class="sourceCode scala">List</code>, replace it with <code class="sourceCode scala"><span class="fu">tail</span>()</code>.</p>
<h3 id="the-deque">The Deque</h3>
<p>Lists are useful. They let you operate on their first element in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math> time, which makes a lot of sense, since you often find yourself starting there.</p>
<p>They’ve got some disadvantages, though: for one, to get to the nth element, you have to walk along n elements in the list. So while operations of the <em>start</em> are fast, operations on the end are painfully slow. And forget about efficient indexing.</p>
<p>This is where a Deque comes in. When you need to operate on two ends of a collection, a Deque is what you want to be using. Removal of the first and last element, prepending, and appending are all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math>.</p>
<p>It’s made up of two lists: one for the front half, and one, in reverse, for the back half. With that information we’ve enough to get a definition down:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct Deque&lt;Element&gt; {
  <span class="kw">private</span> <span class="kw">var</span> front, back: List&lt;Element&gt;
}</code></pre></div>
<p>You’ve got to do similar things that you did to the list to get an easy-to-work-with struct. <code class="sourceCode scala">CustomDebugStringConvertible</code>, <code class="sourceCode scala">ArrayLiteralConvertible</code>, etc. It’s not tremendously interesting, so here it is:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Deque : CustomDebugStringConvertible {
  public <span class="kw">var</span> debugDescription: String {
    <span class="kw">return</span>
      <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(front.<span class="fu">map</span>{String(reflecting: $<span class="dv">0</span>)}) +
      <span class="st">&quot; | &quot;</span> +
      <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(back.<span class="fu">reverse</span>().<span class="fu">map</span>{String(reflecting: $<span class="dv">0</span>)})
  }
}

extension Deque {
  public <span class="fu">init</span>(array: [Element]) {
    let half = array.<span class="fu">endIndex</span> / <span class="dv">2</span>
    front = List(array[<span class="dv">0</span>..&lt;half])
    back = List(array[half..&lt;array.<span class="fu">endIndex</span>].<span class="fu">reverse</span>())
  }
}

extension Deque : ArrayLiteralConvertible {
  public <span class="fu">init</span>(arrayLiteral: Element...) {
    self.<span class="fu">init</span>(array: arrayLiteral)
  }
}

extension Deque {
  public init&lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;(_ seq: S) {
    self.<span class="fu">init</span>(array: Array(seq))
  }
}</code></pre></div>
<p>The debug output puts a <code class="sourceCode scala">|</code> between the two lists:</p>
<p><img class="aligncenter size-full wp-image-395" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-28-at-21-32-44.png" alt="Screen Shot 2015-07-28 at 21.32.44" width="660" height="29" /></p>
<p>This makes it clear how the performance characteristics come about: because the second half is a reversed list, all of the operations on the end of the Deque are operations on the beginning of a list. And that’s where lists are fast.</p>
<p>But there’s an obvious issue. Say we take that list, and start removing the first element from it:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let a = an.<span class="fu">tail</span> <span class="co">// 2, 3 | 4, 5, 6</span>
let b = a.<span class="fu">tail</span>  <span class="co">// 3 | 4, 5, 6</span>
let c = b.<span class="fu">tail</span>  <span class="co">// | 4, 5, 6</span>
let d = c.<span class="fu">tail</span>  <span class="co">// ?????</span></code></pre></div>
<p>The front will end up being empty. The solution to this is the second important element to a Deque. It needs an invariant: if its number of elements is greater than one, neither the front list nor the back will be empty. When the invariant gets violated, it needs to fix it. We can check that the invariant has been upheld with a <code class="sourceCode scala">switch</code> statement:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Deque {
  <span class="kw">private</span> mutating func <span class="fu">check</span>() {
    <span class="fu">switch</span> (front, back) {
    <span class="kw">case</span> (.<span class="fu">Nil</span>, let .<span class="fu">Cons</span>(head, tail)) where !tail.<span class="fu">isEmpty</span>: <span class="fu">fix</span>()
    <span class="kw">case</span> (let .<span class="fu">Cons</span>(head, tail), .<span class="fu">Nil</span>) where !tail.<span class="fu">isEmpty</span>: <span class="fu">fix</span>()
    default:
      <span class="kw">return</span>
    }
  }
}</code></pre></div>
<p>The first case is the front is empty, and the back has more than one element, and the second case is the back is empty, and the front has more than one element. To fix it, just chop off the tail of the non-empty list, reverse it, and assign it to the empty list:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Deque {
  <span class="kw">private</span> mutating func <span class="fu">check</span>() {
    <span class="fu">switch</span> (front, back) {
    <span class="kw">case</span> (.<span class="fu">Nil</span>, let .<span class="fu">Cons</span>(head, tail)) where !tail.<span class="fu">isEmpty</span>:
      (front, back) = (tail.<span class="fu">reverse</span>(), [head])
    <span class="kw">case</span> (let .<span class="fu">Cons</span>(head, tail), .<span class="fu">Nil</span>) where !tail.<span class="fu">isEmpty</span>:
      (back, front) = (tail.<span class="fu">reverse</span>(), [head])
    default:
      <span class="kw">return</span>
    }
  }
}</code></pre></div>
<p>Now, wherever we have a mutating method that may cause a violation of the invariant, this <code class="sourceCode scala">check</code> is called. One particularly cool way to do this is by using <code class="sourceCode scala">didSet</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct Deque&lt;Element&gt; {
  <span class="kw">private</span> <span class="kw">var</span> front: List&lt;Element&gt; { didSet { <span class="fu">check</span>() } }
  <span class="kw">private</span> <span class="kw">var</span> back : List&lt;Element&gt; { didSet { <span class="fu">check</span>() } }
}</code></pre></div>
<p>This will call <code class="sourceCode scala"><span class="fu">check</span>()</code> whenever either list is mutated, ensuring you can’t forget. If a <em>new</em> Deque is initialised, though, it won’t be called. I don’t trust myself to remember the <code class="sourceCode scala"><span class="fu">check</span>()</code> on every init, so we can put it into the initialiser:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">private</span> <span class="fu">init</span>(_ front: List&lt;Element&gt;, _ back: List&lt;Element&gt;) {
    (self.<span class="fu">front</span>, self.<span class="fu">back</span>) = (front, back)
    <span class="fu">check</span>()
  }</code></pre></div>
<p>This is the only initialiser so far, so it’s the only one I’m allowed to call. However, there may be some cases where I <em>know</em> that the front and back are balanced. So I want a separate initialiser for those, for efficiency’s sake. But it’s got to be called <code class="sourceCode scala">init</code> no matter what, so how can I specify that I want to use the non-checking initialiser, over the checking one? I could have a function called something like <code class="sourceCode scala">initialiseFromBalanced</code> that returns a Deque, but I don’t like that. You could use labelled arguments. <a href="http://ericasadun.com/2015/06/01/swift-safe-array-indexing-my-favorite-thing-of-the-new-week/">Erica Sadun has a cool post on using them with subscripts</a>, and here’s what it would look like with <code class="sourceCode scala">init</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Deque {
  <span class="kw">private</span> <span class="fu">init</span>(balancedFront: List&lt;Element&gt;, balancedBack: List&lt;Element&gt;) {
    (front, back) = (balancedFront, balancedBack)
  }
}</code></pre></div>
<p>So now we have a default initialiser that automatically balances the Deque, and a specialised one that takes two lists already balanced.</p>
<p>There is an extra function on lists in the <code class="sourceCode scala"><span class="fu">check</span>()</code> function: <code class="sourceCode scala"><span class="fu">reverse</span>()</code>. There are a load of different ways to do it. If you’re in the mood for golf:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let joanne: List = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]
joanne.<span class="fu">reduce</span>(.<span class="fu">Nil</span>) { $<span class="dv">1</span> |&gt; $<span class="dv">0</span> } <span class="co">// 6, 5, 4, 3, 2, 1</span></code></pre></div>
<p>Or, if you’d like to keep it recursive:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  <span class="kw">private</span> func <span class="fu">reverse</span>(other: List&lt;Element&gt;) -&gt; List&lt;Element&gt; {
    switch self {
    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> other
    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail): <span class="kw">return</span> tail.<span class="fu">reverse</span>(head |&gt; other)
    }
  }
  public func <span class="fu">reverse</span>() -&gt; List&lt;Element&gt; {
    <span class="kw">return</span> <span class="fu">reverse</span>(.<span class="fu">Nil</span>)
  }
}</code></pre></div>
<p>Obviously, you want to avoid this operation as much as possible. We’ll have to bear that in mind when we’re adding other functions.</p>
<p>So what kind of operations do we want on Deques? Well, <code class="sourceCode scala"><span class="fu">removeFirst</span>()</code> and <code class="sourceCode scala"><span class="fu">removeLast</span>()</code> would be a start:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Deque {
  public mutating func <span class="fu">removeFirst</span>() -&gt; Element {
    <span class="kw">return</span> front.<span class="fu">removeFirst</span>()
  }
  public mutating func <span class="fu">removeLast</span>() -&gt; Element {
    <span class="kw">return</span> back.<span class="fu">removeFirst</span>()
  }
}</code></pre></div>
<p>And the function on lists:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension List {
  public mutating func <span class="fu">removeFirst</span>() -&gt; Element {
    switch self {
    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="fu">fatalError</span>(<span class="st">&quot;Cannot call removeFirst() on an empty list&quot;</span>)
    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):
      self = tail
      <span class="kw">return</span> head
    }
  }
}</code></pre></div>
<p>The other functions are easy enough to figure out: <code class="sourceCode scala"><span class="fu">dropFirst</span>()</code>, <code class="sourceCode scala"><span class="fu">dropLast</span>()</code>, etc. And, since it conforms to <code class="sourceCode scala">SequenceType</code>, it gets all of the sequence methods from the standard library, as well. However, those methods are designed for other kinds of sequences - <code class="sourceCode scala">Array</code>s, <code class="sourceCode scala">String.<span class="fu">CharacterView</span></code>s, etc. There are <em>much</em> more efficient ways to do most of them. <code class="sourceCode scala">reverse</code>, for instance, is just this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Deque {
  public func <span class="fu">reverse</span>() -&gt; Deque&lt;Element&gt; {
    <span class="kw">return</span> <span class="fu">Deque</span>(balancedFront: back, balancedBack: front)
  }
}</code></pre></div>
<p>(Since reverse can’t change the number of elements in either list, we can use the initialiser that takes a balanced front and back.) Other methods like <code class="sourceCode scala"><span class="fu">map</span>()</code>, <code class="sourceCode scala"><span class="fu">filter</span>()</code>, etc., will just give you back an array. If we wanted to keep the Deque, we’d have to convert it back, which involves reversing, which is expensive. So we should do our own methods for those:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Deque {
  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; Deque&lt;T&gt; {
    <span class="kw">return</span> Deque&lt;T&gt;(
      balancedFront: front.<span class="fu">map</span>(transform),
      balancedBack : back .<span class="fu">map</span>(transform)
    )
  }
}

extension Deque {
  public func <span class="fu">filter</span>(@noescape includeElement: Element -&gt; Bool) -&gt; Deque&lt;Element&gt; {
    <span class="kw">return</span> <span class="fu">Deque</span>(front.<span class="fu">filter</span>(includeElement), back.<span class="fu">filter</span>(includeElement))
  }
}</code></pre></div>
<p><code class="sourceCode scala"><span class="fu">filter</span>()</code> changes the number of elements in each list, which could cause violation of the invariant. So we use the unlabelled initialiser, which automatically <code class="sourceCode scala"><span class="fu">check</span>()</code>s.</p>
<p>Notice that we don’t have to do any reversing here. This is a huge efficiency gain, but you’ve got to bear in mind that we’re assuming the order of execution of the closures for <code class="sourceCode scala">filter</code> and <code class="sourceCode scala">map</code> don’t matter. This isn’t always the case. Take this function, which is supposed to skip two elements of a sequence:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">var</span> i = <span class="dv">0</span>
[Int](<span class="dv">1</span>...<span class="dv">10</span>).<span class="fu">filter</span> { _ in i++ % <span class="dv">3</span> == <span class="dv">0</span> } <span class="co">// [1, 4, 7, 10]</span></code></pre></div>
<p>It won’t work for a Deque:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">Deque</span>(<span class="dv">1</span>...<span class="dv">10</span>).<span class="fu">filter</span> { _ in i++ % <span class="dv">3</span> == <span class="dv">0</span> } <span class="co">// 1, 4 | 6, 9</span></code></pre></div>
<p>There’s been talk of a <code class="sourceCode scala">@pure</code> attribute. The idea is this: put it before your function or closure name, and the compiler will verify that it has no side effects. It can only use its arguments as variables, or call other <code class="sourceCode scala">@pure</code> functions. It would be very useful here, as it wouldn’t allow the <code class="sourceCode scala">i</code> to be used by <code class="sourceCode scala">filter</code>. Without it, you’ll probably just have to mention in the docs that the order of execution is not knowable.</p>
<p>For completeness’ sake, there are also <code class="sourceCode scala"><span class="fu">flatMap</span>()</code>s for the Deque, implemented in a similar fashion to the functions above:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Deque {
  public func flatMap&lt;T&gt;(@noescape transform: Element -&gt; Deque&lt;T&gt;) -&gt; Deque&lt;T&gt; {
    <span class="kw">return</span> Deque&lt;T&gt;(
      front.<span class="fu">flatMap</span>{List(<span class="fu">transform</span>($<span class="dv">0</span>))},
      back .<span class="fu">flatMap</span>{List(<span class="fu">transform</span>($<span class="dv">0</span>).<span class="fu">reverse</span>())}
    )
  }

  public func flatMap&lt;T&gt;(@noescape transform: Element -&gt; T?) -&gt; Deque&lt;T&gt; {
    <span class="kw">return</span> Deque&lt;T&gt;(
      front.<span class="fu">flatMap</span>(transform),
      back .<span class="fu">flatMap</span>(transform)
    )
  }
}</code></pre></div>
<p>All of this code is available as a playground, <a href="https://github.com/oisdk/Deques-Queues-and-Lists-in-Swift-with-indirect">here</a>. These two structs are also implemented a little more fully in <a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a>.</p>
<p>Since the only real constitutive part of the Deque is a list, it’s probably possible to implement it lazily, by just substituting in <code class="sourceCode scala">LazyList</code>s. Or, if you were feeling adventurous, you could have one of the lists lazy, and one strict. This isn’t as crazy as it sounds: <code class="sourceCode scala"><span class="fu">reverse</span>()</code> can <em>only</em> be performed eagerly, since the entire list needs to be walked to get to the last element. So the front and back lists have different functions (slightly). Also, because of the lazy initialisation of <code class="sourceCode scala">LazyList</code>, swapping between lazy and strict needn’t be very expensive. I’ll leave it up to someone else to try, though.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
