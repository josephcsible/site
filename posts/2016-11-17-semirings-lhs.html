<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Semirings - Donnacha Oisín Kidney</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Semirings</h2>

            <div class="info">
    Posted on November 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>
    
</div>

<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving, TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}</span>
<span class="ot">{-# LANGUAGE PatternSynonyms, ViewPatterns, LambdaCase #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes, FlexibleInstances, FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings, OverloadedLists, MonadComprehensions #-}</span>

<span class="kw">module</span> <span class="dt">Semirings</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Data.Array</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)
<span class="kw">import </span><span class="dt">Data.Ratio</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Arrow</span> (first)
<span class="kw">import </span><span class="dt">Control.Monad.Cont</span>
<span class="kw">import </span><span class="dt">Data.Functor.Identity</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Data.List</span> <span class="kw">hiding</span> (insert)</code></pre></div>
<p>I’ve been playing around a lot with semirings recently. A semiring is anything with addition, multiplication, zero and one. You can represent that in Haskell as:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span>
<span class="ot">  zero ::</span> a
<span class="ot">  one  ::</span> a
  <span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">&lt;.&gt;</span>
<span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
  <span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">&lt;+&gt;</span>
<span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>It’s kind of like a combination of two <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html">monoids</a>. It has the normal monoid laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;+&gt;</span> z
x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;.&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;.&gt;</span> z
x <span class="fu">&lt;+&gt;</span> zero <span class="fu">=</span> zero <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x
x <span class="fu">&lt;.&gt;</span> one  <span class="fu">=</span> one  <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span> x</code></pre></div>
<p>And a few extra:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> x
x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> z)
(x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;.&gt;</span> z <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> z) <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;.&gt;</span> z)
zero <span class="fu">&lt;.&gt;</span> a <span class="fu">=</span> a <span class="fu">&lt;.&gt;</span> zero <span class="fu">=</span> zero</code></pre></div>
<p>I should note that what I’m calling a semiring here is often called a <a href="https://ncatlab.org/nlab/show/rig">rig</a>. I actually prefer the name “rig”: a rig is a ring without <strong>n</strong>egatives (cute!); whereas a <em>semi</em>ring is a rig without neutral elements, which mirrors the definition of a semigroup. The nomenclature in this area is a mess, though (more on that later), so I went with the more commonly-used name for the sake of googleability.</p>
<p>At first glance, it looks quite numeric. Indeed, <a href="https://pursuit.purescript.org/packages/purescript-prelude/1.1.0/docs/Data.Semiring">PureScript</a> uses it as the basis for its numeric hierarchy. (In my experience so far, it’s nicer to use than Haskell’s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num"><code class="sourceCode haskell"><span class="dt">Num</span></code></a>)</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dv">0</span>
  one  <span class="fu">=</span> <span class="dv">1</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Double</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dv">0</span>
  one  <span class="fu">=</span> <span class="dv">1</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</code></pre></div>
<p>However, there are far more types which can form a valid <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance than can form a valid <code class="sourceCode haskell"><span class="dt">Num</span></code> instance. For instance, the <code class="sourceCode haskell">negate</code> method on <code class="sourceCode haskell"><span class="dt">Num</span></code> excludes types representing the natural numbers:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ChurchNat</span> <span class="fu">=</span> <span class="dt">ChurchNat</span> {<span class="ot"> runNat ::</span> forall a<span class="fu">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a}
 
<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></code></pre></div>
<p>These form perfectly sensible semirings, though:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">ChurchNat</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dt">ChurchNat</span> (const id)
  one <span class="fu">=</span> <span class="dt">ChurchNat</span> (<span class="fu">$</span>)
  <span class="dt">ChurchNat</span> n <span class="fu">&lt;+&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (\f <span class="ot">-&gt;</span> n f <span class="fu">.</span> m f)
  <span class="dt">ChurchNat</span> n <span class="fu">&lt;.&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (n <span class="fu">.</span> m)

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Nat</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dt">Zero</span>
  one <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Zero</span>
  <span class="dt">Zero</span> <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x
  <span class="dt">Succ</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> <span class="dt">Succ</span> (x <span class="fu">&lt;+&gt;</span> y)
  <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> <span class="dt">Zero</span>
  <span class="dt">Succ</span> <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span>x
  <span class="dt">Succ</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> y)</code></pre></div>
<p>The other missing method is <code class="sourceCode haskell">fromInteger</code>, which means decidedly non-numeric types are allowed:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dt">False</span>
  one  <span class="fu">=</span> <span class="dt">True</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">||</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</code></pre></div>
<p>We can provide a more general definition of the <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Product"><code class="sourceCode haskell"><span class="dt">Product</span></code></a> newtypes from <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#g:3">Data.Monoid</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Add</span> a <span class="fu">=</span> <span class="dt">Add</span>
  {<span class="ot"> getAdd ::</span> a
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)

<span class="kw">newtype</span> <span class="dt">Mul</span> a <span class="fu">=</span> <span class="dt">Mul</span>
  {<span class="ot"> getMul ::</span> a
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Add</span> <span class="kw">where</span>
  fmap f (<span class="dt">Add</span> x) <span class="fu">=</span> <span class="dt">Add</span> (f x)
<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Add</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Add</span>
  <span class="dt">Add</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Add</span> x <span class="fu">=</span> <span class="dt">Add</span> (f x)</code></pre></div>
<p>I’m using <code class="sourceCode haskell"><span class="dt">Add</span></code> and <code class="sourceCode haskell"><span class="dt">Mul</span></code> here to avoid name clashing.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Add</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Add</span> zero
  <span class="dt">Add</span> x <span class="ot">`mappend`</span> <span class="dt">Add</span> y <span class="fu">=</span> <span class="dt">Add</span> (x <span class="fu">&lt;+&gt;</span> y)

<span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Mul</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Mul</span> one
  <span class="dt">Mul</span> x <span class="ot">`mappend`</span> <span class="dt">Mul</span> y <span class="fu">=</span> <span class="dt">Mul</span> (x <span class="fu">&lt;.&gt;</span> y)
  
<span class="ot">add ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a
add <span class="fu">=</span> getAdd <span class="fu">.</span> foldMap <span class="dt">Add</span>

<span class="ot">mul ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a
mul <span class="fu">=</span> getMul <span class="fu">.</span> foldMap <span class="dt">Mul</span></code></pre></div>
<p><code class="sourceCode haskell">add</code> and <code class="sourceCode haskell">mul</code> are equivalent to <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:sum"><code class="sourceCode haskell">sum</code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:product"><code class="sourceCode haskell">product</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">add xs <span class="fu">==</span> sum (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">mul xs <span class="fu">==</span> product (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</code></pre></div>
<p>But they now work with a wider array of types: non-negative numbers, as we’ve seen, but specialised to <code class="sourceCode haskell"><span class="dt">Bool</span></code> we get the familiar <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Any"><code class="sourceCode haskell"><span class="dt">Any</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:All"><code class="sourceCode haskell"><span class="dt">All</span></code></a> newtypes (and their corresponding folds).</p>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">add xs <span class="fu">==</span> any id (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">mul xs <span class="fu">==</span> all id (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</code></pre></div>
<p>So far, nothing amazing. We avoid a little bit of code duplication, that’s all.</p>
<h2 id="a-semiring-map">A Semiring Map</h2>
<p>In older versions of Python, <a href="https://www.python.org/dev/peps/pep-0218/">there was no native set type</a>. In its place, dictionaries were used, where the values would be booleans. In a similar fashion, before the <a href="https://docs.python.org/2/library/collections.html#collections.Counter">Counter</a> type was added in 2.7, the traditional way of representing a multiset was using a dictionary where the values were integers.</p>
<p>Using semirings, both of these data structures can have the same type:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">GeneralMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span>
  {<span class="ot"> getMap ::</span> <span class="dt">Map.Map</span> a b
  } <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</code></pre></div>
<p>If operations are defined in terms of the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class, the same code will work on a set <em>and</em> a multiset:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
insert x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith (<span class="fu">&lt;+&gt;</span>) x one <span class="fu">.</span> getMap

<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
delete x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.delete x <span class="fu">.</span> getMap</code></pre></div>
<p>How to get back the dictionary-like behaviour, then? Well, operations like <code class="sourceCode haskell">lookup</code> and <code class="sourceCode haskell">assoc</code> are better suited to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> constraint, rather than <code class="sourceCode haskell"><span class="dt">Semiring</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> b
lookup x <span class="fu">=</span> fold <span class="fu">.</span> Map.lookup x <span class="fu">.</span> getMap

<span class="ot">assoc ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b)) 
      <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)
assoc k v <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith mappend k (pure v) <span class="fu">.</span> getMap</code></pre></div>
<p><code class="sourceCode haskell">lookup</code> is a function which should work on sets and multisets: however <code class="sourceCode haskell"><span class="dt">Bool</span></code> and <code class="sourceCode haskell"><span class="dt">Integer</span></code> don’t have <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instances. To fix this, we can use the <code class="sourceCode haskell"><span class="dt">Add</span></code> newtype from above. Now we have a decent interface for each of our data structures. It’s helpful to think of each interpretation of the type like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Set</span>      a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Bool</span>)
<span class="kw">type</span> <span class="dt">MultiSet</span> a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Integer</span>)
<span class="kw">type</span> <span class="dt">Map</span>      a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">First</span> b)
<span class="kw">type</span> <span class="dt">MultiMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a [b]</code></pre></div>
<p>Each of the functions from above specialises like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Set</span>
<span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a
lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Bool</span>
<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a

<span class="co">-- MultiSet</span>
<span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a
lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Integer</span>
<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a

<span class="co">-- Map</span>
<span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b
lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b
<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b

<span class="co">-- MultiMap</span>
<span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b
lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> [b]
<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</code></pre></div>
<p>This was actually where I first came across semirings: I was trying to avoid code duplication for a trie implementation. I wanted to get the Boom Hierarchy <span class="citation">(Boom 1981)</span> (plus maps) from the same underlying implementation.</p>
<p>It works <em>okay</em>. On the one hand, it’s nice that you don’t have to wrap the map type itself to get the different behaviour. There’s only one <code class="sourceCode haskell">delete</code> function, which works on sets, maps, multisets, etc. I don’t need to import the <code class="sourceCode haskell"><span class="dt">TrieSet</span></code> module qualified, to differentiate between the <em>four</em> <code class="sourceCode haskell">delete</code> functions I’ve written.</p>
<p>The abstraction goes pretty far, also:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">fromList ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
fromList <span class="fu">=</span> foldr insert (<span class="dt">GeneralMap</span> Map.empty)

<span class="ot">fromAssocs ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b), <span class="dt">Foldable</span> t) 
           <span class="ot">=&gt;</span> t (a, b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)
fromAssocs <span class="fu">=</span> foldr (uncurry assoc) (<span class="dt">GeneralMap</span> Map.empty)

<span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">GeneralMap</span> a b) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">GeneralMap</span> Map.empty
  mappend (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span> 
    <span class="dt">GeneralMap</span> (Map.unionWith mappend x y)
    
<span class="ot">singleton ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
singleton x <span class="fu">=</span> <span class="dt">GeneralMap</span> (Map.singleton x one)</code></pre></div>
<p>On the other hand, some of the constraints aren’t very nice. <code class="sourceCode haskell"><span class="dt">Applicative</span></code> on the wrappers for the map and multimap, for instance. The fact that the lookup on sets and multisets returns a wrapped value is annoying. And I couldn’t figure out a definition for <code class="sourceCode haskell">intersection</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">intersection ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b)
             <span class="ot">=&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
intersection (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span>
  <span class="dt">GeneralMap</span> (Map.intersectionWith (<span class="fu">&lt;.&gt;</span>) x y)</code></pre></div>
<p>While it works for sets, it doesn’t make sense for multisets, and it doesn’t work for maps. I couldn’t find a more suitable semiring in order to represent what I wanted. (I’m probably after a different algebraic structure)</p>
<h2 id="a-probability-semiring">A Probability Semiring</h2>
<p>While looking for a semiring to represent a valid intersection, I came across some other semirings. The <em>probability</em> semiring, for instance. It’s just the normal semiring over the rationals, with a lower bound of 0, and an upper of 1.</p>
<p>It’s useful in some cool ways. For instance, you could combine it with a list to get the probability monad <span class="citation">(Erwig and Kollmansberger 2006)</span>. There’s an example in PureScript’s <a href="https://pursuit.purescript.org/packages/purescript-distributions/">Distributions</a> package.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> [(a,s)] }</code></pre></div>
<p>This representation is unfortunately too slow to be useful (usually). In particular, there’s a combinatorial explosion on every monadic bind. One of the strategies to reduce this explosion is to use a map:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> <span class="dt">Map.Map</span> a s }</code></pre></div>
<p>Because this doesn’t allow duplicate keys, it will flatten the association list on every bind. Unfortunately, there’s no huge efficiency gain, and in some cases an efficiency <em>loss</em> <span class="citation">(Larsen 2011)</span>. Also, the <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint on <code class="sourceCode haskell">a</code> prevents the above representation from conforming to <code class="sourceCode haskell"><span class="dt">Monad</span></code>. (at least the standard version in the prelude)</p>
<p>Interestingly, this type is exactly the same as the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> from above. This is a theme I kept running into, actually: the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> type represents not just maps, multimaps, sets, multisets, but also a whole host of other data structures.</p>
<h2 id="cont">Cont</h2>
<p>Edward Kmett had an interesting blog post about “Free Modules and Functional Linear Functionals” <span class="citation">(2011b)</span>. In it, he talked about this type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">$*</span>
<span class="kw">newtype</span> <span class="dt">Linear</span> r a <span class="fu">=</span> <span class="dt">Linear</span> {<span class="ot"> ($*) ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html#t:Cont"><code class="sourceCode haskell"><span class="dt">Cont</span></code></a>, the continuation monad. What’s interesting about the above type is that it can encode the probability monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">fromProbs ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> [(a,s)] <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
fromProbs xs <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span>
  foldr (\(x,s) a <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (fmap (s<span class="fu">&lt;.&gt;</span>) (k x)) a) (pure zero) xs

<span class="ot">probOfT ::</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a <span class="ot">-&gt;</span> m r
probOfT e c <span class="fu">=</span> runContT c (\x <span class="ot">-&gt;</span> <span class="kw">if</span> e x <span class="kw">then</span> pure one <span class="kw">else</span> pure zero)

<span class="ot">probOf ::</span> <span class="dt">Semiring</span> r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> r
probOf e <span class="fu">=</span> runIdentity <span class="fu">.</span> probOfT e

<span class="ot">uniform ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="dt">Double</span> m a
uniform xs <span class="fu">=</span>
  <span class="kw">let</span> s <span class="fu">=</span> <span class="fl">1.0</span> <span class="fu">/</span> fromIntegral (length xs)
  <span class="kw">in</span> fromProbs (map (flip (,) s) xs)</code></pre></div>
<p>Multiplication isn’t paid for on every bind, making this (potentially) a more efficient implementation than both the map and the association list.</p>
<p>You can actually make the whole thing a semiring:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span>
  one  <span class="fu">=</span> <span class="dt">ContT</span> (const (pure one))
  zero <span class="fu">=</span> <span class="dt">ContT</span> (const (pure one))
  f <span class="fu">&lt;+&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (runContT f k) (runContT g k))
  f <span class="fu">&lt;.&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;.&gt;</span>) (runContT f k) (runContT g k))</code></pre></div>
<p>Which gives you a lovely <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span>
  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>)
  empty <span class="fu">=</span> zero</code></pre></div>
<p>The multiplication here is equivalent to the unsatisfactory intersection from above. Zero is the empty map, one is the map where <em>every</em> key has a value of one. To make one in the previous implementations, you would have to enumerate over every possible value for the keys. In this version, to <em>inspect</em> the values you have to enumerate over every possible key.</p>
<p>I think I now have a name for the probability monad / general map / Cont thing: a <em>covector</em>.</p>
<p>I think that the transformer version of Cont has a valid interpretation, also. If I ever understand <span class="citation">Hirschowitz and Maggesi (2010)</span> I’ll put it into a later follow-up post.</p>
<h2 id="conditional-choice">Conditional choice</h2>
<p>As a short digression, you can beef up the <code class="sourceCode haskell"><span class="fu">&lt;|&gt;</span></code> operator a little, with something like <a href="http://zenzike.com/posts/2011-08-01-the-conditional-choice-operator">the conditional choice operator</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BiWeighted</span> s <span class="fu">=</span> s <span class="fu">:|:</span> s
<span class="kw">infixl</span> <span class="dv">8</span> <span class="fu">:|:</span>

<span class="ot">(|&gt;) ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Semiring</span> s)
     <span class="ot">=&gt;</span> <span class="dt">BiWeighted</span> s
     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
((lp <span class="fu">:|:</span> rp) <span class="fu">|&gt;</span> r) l <span class="fu">=</span>
  (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) lp l <span class="fu">&lt;|&gt;</span> (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) rp r
<span class="co">--</span>
<span class="ot">(&lt;|) ::</span> <span class="dt">ContT</span> s m a
     <span class="ot">-&gt;</span> (<span class="dt">ContT</span> s m a <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a)
     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
l <span class="fu">&lt;|</span> r <span class="fu">=</span> r l

<span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">&lt;|</span>
<span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">|&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">probOf (<span class="ch">'a'</span><span class="fu">==</span>) (uniform <span class="st">&quot;a&quot;</span> <span class="fu">&lt;|</span> <span class="fl">0.4</span> <span class="fu">:|:</span> <span class="fl">0.6</span> <span class="fu">|&gt;</span> uniform <span class="st">&quot;b&quot;</span>)
<span class="fl">0.4</span></code></pre></div>
<h2 id="unleak">UnLeak</h2>
<p>Interestingly, the probability monad can be constructed from more primitive types. For instance, extracting the <code class="sourceCode haskell"><span class="dt">WriterT</span></code> monad transformer gives you:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Double</span>) []</code></pre></div>
<p>Eric Kidd describes it as <code class="sourceCode haskell"><span class="dt">PerhapsT</span></code>: a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> with attached probability in his <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/">excellent blog post</a> <span class="citation">(and his paper in 2007)</span>.</p>
<p>Straight away, we can optimise this representation by transforming <a href="https://twitter.com/gabrielg439/status/659170544038707201">leaky</a> <code class="sourceCode haskell"><span class="dt">WriterT</span></code> into a state monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">WeightedT</span> s m a <span class="fu">=</span> <span class="dt">WeightedT</span> 
  {<span class="ot"> getWeightedT ::</span> s <span class="ot">-&gt;</span> m (a, s)
  } <span class="kw">deriving</span> <span class="dt">Functor</span>
  
<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> pure (x,s)
  <span class="dt">WeightedT</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">WeightedT</span> xs <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
    (f, p) <span class="ot">&lt;-</span> fs s
    (x, t) <span class="ot">&lt;-</span> xs p
    pure (f x, t)
  
<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span>
  <span class="dt">WeightedT</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
    (x, p) <span class="ot">&lt;-</span> x s
    getWeightedT (f x) p</code></pre></div>
<p>I’m not sure yet, but I think this might have something to do with the isomorphism between <code class="sourceCode haskell"><span class="dt">Cont</span> ((<span class="ot">-&gt;</span>) s)</code> and <code>State s</code> <span class="citation">(Kmett 2011a)</span>.</p>
<p>You can even make it look like a normal (non-transformer) writer with some pattern synonyms:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Weighted</span> s <span class="fu">=</span> <span class="dt">WeightedT</span> s <span class="dt">Identity</span>

pattern <span class="dt">Weighted</span> w <span class="ot">&lt;-</span> (runIdentity <span class="fu">.</span> flip getWeightedT zero <span class="ot">-&gt;</span> w) <span class="kw">where</span>
  <span class="dt">Weighted</span> (x,w) <span class="fu">=</span> <span class="dt">WeightedT</span> (\s <span class="ot">-&gt;</span> <span class="dt">Identity</span> (x, s <span class="fu">&lt;.&gt;</span> w) )</code></pre></div>
<p>And you can pretend that you’ve just got a normal tuple:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">half ::</span> a <span class="ot">-&gt;</span> <span class="dt">Weighted</span> <span class="dt">Double</span> a
half x <span class="fu">=</span> <span class="dt">Weighted</span> (x, <span class="fl">0.5</span>)

<span class="ot">runWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> (a, s)
runWeighted (<span class="dt">Weighted</span> w) <span class="fu">=</span> w

<span class="ot">evalWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> a
evalWeighted (<span class="dt">Weighted</span> (x,_)) <span class="fu">=</span> x

<span class="ot">execWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> s
execWeighted (<span class="dt">Weighted</span> (_,s)) <span class="fu">=</span> s</code></pre></div>
<h2 id="free">Free</h2>
<p>Looking back at Cont, it is reminiscent of a particular encoding of the free monoid from <span class="citation">Doel (2015)</span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FreeMonoid</span> a <span class="fu">=</span> <span class="dt">FreeMonoid</span>
  { forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> m }</code></pre></div>
<p>So possibly covectors represent the free semiring, in some way.</p>
<p>Another encoding which looks free-ish is another efficient implementation of the probability monad from <span class="citation">Larsen (2011)</span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Dist</span> a <span class="kw">where</span>
  <span class="dt">Certainly</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="co">-- only possible value</span>
  <span class="dt">Choice</span><span class="ot"> ::</span> <span class="dt">Probability</span> <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a
  <span class="dt">Fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> b
  <span class="dt">Join</span><span class="ot"> ::</span> <span class="dt">Dist</span> (<span class="dt">Dist</span> a) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</code></pre></div>
<p>This looks an awful lot like a weighted <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html">free alternative</a>. Is it a free semiring, then?</p>
<p>Maybe. There’s a parallel between the relationship between monoids and semirings and applicatives and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Alternative"><code class="sourceCode haskell"><span class="dt">Alternative</span></code></a>s <span class="citation">(Rivas, Jaskelioff, and Schrijvers 2015)</span>. In a way, where monads are monoids in the category of endofunctors, alternatives are <em>semirings</em> in the category of endofunctors.</p>
<p>This parallel probably isn’t as consistent as I first thought. First of all, the above paper uses near-semirings, not semirings. A near-semiring is a semiring where the requirements for left distribution of multiplication over addition and commutative addition are dropped. Secondly, the class which most mirrors near-semirings is <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:MonadPlus"><code class="sourceCode haskell"><span class="dt">MonadPlus</span></code></a>, not alternative. (alternative doesn’t have annihilation) Thirdly, right distribution of multiplication over addition <em>isn’t</em> required <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code>: it’s a further law required on top of the existing laws. Fourthly, most types in the Haskell ecosystem today which conform to <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code> <em>don’t</em> conform to this extra law: in fact, those that do seem to be lists of some kind or another.</p>
<p>Another class is probably needed on top of the two already there, called <code class="sourceCode haskell"><span class="dt">Nondet</span></code> by <span class="citation">Fischer and others (2009)</span>.</p>
<p>An actual free near-semiring looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f x <span class="fu">=</span> <span class="dt">Free</span> {<span class="ot"> unFree ::</span> [<span class="dt">FFree</span> f x] }
<span class="kw">data</span> <span class="dt">FFree</span> f x <span class="fu">=</span> <span class="dt">Pure</span> x <span class="fu">|</span> <span class="dt">Con</span> (f (<span class="dt">Free</span> f x))</code></pre></div>
<p>Specialised to the <code class="sourceCode haskell"><span class="dt">Identity</span></code> monad, that becomes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Forest</span> a <span class="fu">=</span> <span class="dt">Forest</span> {<span class="ot"> unForest ::</span> [<span class="dt">Tree</span> x] }
<span class="kw">data</span> <span class="dt">Tree</span> x <span class="fu">=</span> <span class="dt">Leaf</span> x <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Forest</span> x)</code></pre></div>
<p>De-specialised to the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free.html">free monad transformer</a>, it becomes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FreeT</span> f m a <span class="fu">=</span> <span class="dt">FreeT</span>
  {<span class="ot"> runFreeT ::</span> m (<span class="dt">FreeF</span> f a (<span class="dt">FreeT</span> f m a)) }

<span class="kw">data</span> <span class="dt">FreeF</span> f a b
  <span class="fu">=</span> <span class="dt">Pure</span> a
  <span class="fu">|</span> <span class="dt">Free</span> (f b)

<span class="kw">type</span> <span class="dt">FreeNearSemiring</span> f <span class="fu">=</span> <span class="dt">FreeT</span> f []</code></pre></div>
<p>These definitions all lend themselves to combinatorial search <span class="citation">(Spivey 2009, <span class="citation">Fischer and others (2009)</span>, <span class="citation">Piponi (2009)</span>)</span>, with one extra operation needed: <code class="sourceCode haskell">wrap</code>.</p>
<h2 id="odds">Odds</h2>
<p>Does the <a href="../posts/2016-09-27-odds-lhs.html">odds monad</a> fit in to any of this?</p>
<p>While <code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</code> is a valid definition of the traditional probability monad, it’s <em>not</em> the same as the odds monad. If you take the odds monad, and parameterize it over the weight of the tail, you get this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> m a <span class="fu">=</span> <span class="dt">Certain</span> a <span class="fu">|</span> <span class="dt">Choice</span> (m (a, <span class="dt">Odds</span> a))</code></pre></div>
<p>Which looks remarkably like <a href="https://wiki.haskell.org/ListT_done_right"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ListT</span> m a <span class="fu">=</span> <span class="dt">ListT</span> {<span class="ot"> next ::</span> m (<span class="dt">Step</span> m a) }
<span class="kw">data</span> <span class="dt">Step</span> m a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">ListT</span> m a) <span class="fu">|</span> <span class="dt">Nil</span></code></pre></div>
<p>(I’m using <a href="http://www.haskellforall.com/2016/07/list-transformer-beginner-friendly-listt.html">Gabriel Gonzalez</a>’s version here)</p>
<p>Except that it allows empty lists. It looks like you can express the relationship between probability and odds as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span>  <span class="dt">Rational</span>) [] <span class="fu">=</span> <span class="dt">Probability</span>
<span class="dt">ListT</span>   (<span class="dt">Weighted</span> <span class="dt">Rational</span>)    <span class="fu">=</span> <span class="dt">Odds</span></code></pre></div>
<p>To disallow empty lists, you can use the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html">Cofree Comonad</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> (f (<span class="dt">Cofree</span> f a))</code></pre></div>
<p>Subbing in <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for <code class="sourceCode haskell">f</code>, you get a non-empty list. A <em>weighted</em> <code class="sourceCode haskell"><span class="dt">Maybe</span></code> is basically <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/"><code class="sourceCode haskell"><span class="dt">PerhapsT</span></code></a>, as was mentioned earlier.</p>
<h2 id="generalizing-semirings">Generalizing Semirings</h2>
<p>Types in haskell also form a semiring.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (,)
one <span class="fu">=</span> ()

(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="dt">Either</span>
zero <span class="fu">=</span> <span class="dt">Void</span></code></pre></div>
<p>There’s a subset of semirings which are <a href="https://en.wikipedia.org/wiki/Semiring#Star_semirings">star semirings</a>. They have an operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> such that:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>*</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a* = 1 + aa* = 1 + a*a</annotation></semantics></math></p>
<p>Or, as a class:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> a <span class="kw">where</span>
<span class="ot">  star ::</span> a <span class="ot">-&gt;</span> a
  star x <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> plus x
<span class="ot">  plus ::</span> a <span class="ot">-&gt;</span> a
  plus x <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> star x</code></pre></div>
<p>Using this on types, you get:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">star a <span class="fu">=</span> <span class="dt">Either</span> () (a, star a)</code></pre></div>
<p>Which is just a standard list! Some pseudo-haskell on alternatives will give you:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">star ::</span> (<span class="dt">Alternative</span> f, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a
star x <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> star x) <span class="fu">&lt;+&gt;</span> pure mempty <span class="kw">where</span>
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="fu">&lt;|&gt;</span></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#v:many"><code class="sourceCode haskell">many</code></a>. (although note that this breaks all the laws)</p>
<p>The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> for rationals is defined as <span class="citation">(Droste and Kuich 2009, p8)</span>:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>a</mi></mrow></mfrac></mtd><mtd><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd><mn>0</mn><mo>≤</mo><mi>a</mi><mo>&lt;</mo><mn>1</mn><mo>,</mo></mtd></mtr><mtr><mtd><mi>∞</mi></mtd><mtd><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd><mi>a</mi><mo>≥</mo><mn>1</mn><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">a* = \begin{cases}  \frac{1}{1 - a} &amp; \quad \text{if  } &amp; 0 \leq a \lt 1, \\  \infty &amp; \quad \text{if  } &amp; a \geq 1. \end{cases}</annotation></semantics></math></p>
<p>So, combining the probability with the type-level business, the star of <code>Writer s a</code> is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Either</span> (<span class="dv">1</span>, a) (a, s <span class="fu">/</span> (<span class="dv">1</span> <span class="fu">-</span> s), star (<span class="dt">Writer</span> s a))</code></pre></div>
<p>Or, to put it another way: the odds monad!</p>
<h2 id="some-examples">Some Examples</h2>
<p>So we’ve seen semirings for probabilities, maps, sets, etc. What else forms a semiring?</p>
<p>One of the most important applications (and a source of much of the notation) are regular expressions. In fact, the free semiring looks like a haskell datatype for regular expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FreeStar</span> a
 <span class="fu">=</span> <span class="dt">Gen</span> a
 <span class="fu">|</span> <span class="dt">Zer</span>
 <span class="fu">|</span> <span class="dt">One</span>
 <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;+&gt;</span> <span class="dt">FreeStar</span> a
 <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;.&gt;</span> <span class="dt">FreeStar</span> a
 <span class="fu">|</span> <span class="dt">Star</span> (<span class="dt">FreeStar</span> a)

<span class="kw">instance</span> <span class="dt">Semiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;+&gt;</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;.&gt;</span>)
  zero <span class="fu">=</span> <span class="dt">Zer</span>
  one <span class="fu">=</span> <span class="dt">One</span>
  
<span class="kw">instance</span> <span class="dt">StarSemiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span>
  star <span class="fu">=</span> <span class="dt">Star</span>
  
<span class="ot">interpret ::</span> <span class="dt">StarSemiring</span> s <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> a <span class="ot">-&gt;</span> s
interpret f <span class="fu">=</span> \<span class="kw">case</span>
  <span class="dt">Gen</span> x <span class="ot">-&gt;</span> f x
  <span class="dt">Zer</span> <span class="ot">-&gt;</span> zero
  <span class="dt">One</span> <span class="ot">-&gt;</span> one
  l <span class="fu">:&lt;+&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;+&gt;</span> interpret f r
  l <span class="fu">:&lt;.&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;.&gt;</span> interpret f r
  <span class="dt">Star</span> x <span class="ot">-&gt;</span> star (interpret f x)</code></pre></div>
<p>Using another semiring (near-semiring, specifically; and it requires the underlying monoid to be commutative):</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span>
  <span class="dt">Endo</span> f <span class="fu">&lt;+&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&lt;&gt;</span> g x)
  zero <span class="fu">=</span> <span class="dt">Endo</span> (const mempty)
  one <span class="fu">=</span> <span class="dt">Endo</span> id
  <span class="dt">Endo</span> f <span class="fu">&lt;.&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)
  
<span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span>
  star (<span class="dt">Endo</span> f) <span class="fu">=</span> <span class="dt">Endo</span> converge <span class="kw">where</span>
    converge x <span class="fu">=</span> x <span class="fu">&lt;&gt;</span> (<span class="kw">if</span> y <span class="fu">==</span> mempty <span class="kw">then</span> y <span class="kw">else</span> converge y) <span class="kw">where</span>
      y <span class="fu">=</span> f x</code></pre></div>
<p>Then, interpreting the regex is as simple as writing an interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">asRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
asRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo (interpret f fs) <span class="fu">.</span> pure <span class="kw">where</span>
  f p <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span>
    (x<span class="fu">:</span>xs) <span class="fu">|</span> p x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs
    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

<span class="ot">char' ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
char' c <span class="fu">=</span> <span class="dt">Gen</span> (c<span class="fu">==</span>)</code></pre></div>
<p>Actually, you don’t need the free version at all!</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">runRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> [[a]] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
runRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo fs <span class="fu">.</span> pure

<span class="ot">char ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> [[a]]
char c <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span>
  (x<span class="fu">:</span>xs) <span class="fu">|</span> c <span class="fu">==</span> x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs
  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>  </code></pre></div>
<p>With some <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedStrings</span></code> magic, you get a pretty nice interface:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Endo</span> [<span class="dt">String</span>]) <span class="kw">where</span>
  fromString <span class="fu">=</span> mul <span class="fu">.</span> map char <span class="fu">.</span> reverse
  
<span class="ot">(&lt;^&gt;) ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
(<span class="fu">&lt;^&gt;</span>) <span class="fu">=</span> flip (<span class="fu">&lt;.&gt;</span>)

<span class="ot">greet ::</span> <span class="dt">Endo</span> [<span class="dt">String</span>]
greet <span class="fu">=</span> <span class="st">&quot;H&quot;</span> <span class="fu">&lt;^&gt;</span> (<span class="st">&quot;a&quot;</span> <span class="fu">&lt;+&gt;</span> <span class="st">&quot;e&quot;</span>) <span class="fu">&lt;^&gt;</span> <span class="st">&quot;llo&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">runRegex greet <span class="st">&quot;Hello&quot;</span>
<span class="dt">True</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">runRegex greet <span class="st">&quot;Hallo&quot;</span>
<span class="dt">True</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">runRegex greet <span class="st">&quot;Halo&quot;</span>
<span class="dt">False</span></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>Of course, that’s about as slow as it gets when it comes to regexes. A faster representation is a <a href="https://swtch.com/~rsc/regexp/regexp1.html">nondeterministic finite automaton</a>. One such implementation in haskell is <a href="https://github.com/Gabriel439/slides/blob/master/regex/regex.md">Gabriel Gonzalez’s</a>.</p>
<p>The regex type in that example can be immediately made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> and <code class="sourceCode haskell"><span class="dt">StarSemiring</span></code>. However, it might be more interesting to translate the <em>implementation</em> into using semirings. The type of a regex looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span>

{<span class="ot"> _startingStates         ::</span> <span class="dt">Set</span> <span class="dt">State</span>
,<span class="ot"> _transitionFunction     ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span>
,<span class="ot"> _acceptingStates        ::</span> <span class="dt">Set</span> <span class="dt">State</span> }</code></pre></div>
<p>As you might note, the set data structure can be reformulated as a map from states to some semiring. In fact, the whole code can be translated into using some arbitrary semiring pretty readily:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="kw">data</span> <span class="dt">Regex</span> i s <span class="fu">=</span> <span class="dt">Regex</span>
  {<span class="ot"> _numberOfStates     ::</span> <span class="dt">Int</span> 
  ,<span class="ot"> _startingStates     ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s
  ,<span class="ot"> _transitionFunction ::</span> i <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s
  ,<span class="ot"> _acceptingStates    ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s }

<span class="ot">isEnd ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Regex</span> i s <span class="ot">-&gt;</span> s
isEnd (<span class="dt">Regex</span> _ as _ bs) <span class="fu">=</span> add (intersection as bs)

<span class="ot">match ::</span> <span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
match r <span class="fu">=</span> getAdd <span class="fu">.</span> isEnd <span class="fu">.</span> foldl' run r <span class="kw">where</span>
  run (<span class="dt">Regex</span> n (<span class="dt">GeneralMap</span> as) f bs) i <span class="fu">=</span> <span class="dt">Regex</span> n as' f bs
    <span class="kw">where</span> as' <span class="fu">=</span> mconcat [ fmap (v<span class="fu">&lt;.&gt;</span>) (f i k)  <span class="fu">|</span> (k,v) <span class="ot">&lt;-</span> Map.assocs as ]


<span class="ot">satisfy ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> s)
satisfy predicate <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">2</span> as f bs
  <span class="kw">where</span>
    as <span class="fu">=</span> singleton <span class="dv">0</span>
    bs <span class="fu">=</span> singleton <span class="dv">1</span>

    f i <span class="dv">0</span> <span class="fu">=</span> assoc <span class="dv">1</span> (predicate i) mempty
    f _ _ <span class="fu">=</span> mempty

<span class="ot">once ::</span> <span class="dt">Eq</span> i <span class="ot">=&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> <span class="dt">Bool</span>)
once x <span class="fu">=</span> satisfy (<span class="fu">==</span> x)

<span class="ot">shift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s
shift n <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.fromAscList <span class="fu">.</span> (map<span class="fu">.</span>first) (<span class="fu">+</span> n) <span class="fu">.</span> Map.toAscList <span class="fu">.</span> getMap

<span class="kw">instance</span> (<span class="dt">Semiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span>

  one <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">1</span> (singleton <span class="dv">0</span>) (\_ _ <span class="ot">-&gt;</span> mempty) (singleton <span class="dv">0</span>)
  zero <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">0</span> mempty (\_ _ <span class="ot">-&gt;</span> mempty) mempty

  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;+&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs
    <span class="kw">where</span>
      n  <span class="fu">=</span> nL <span class="fu">+</span> nR
      as <span class="fu">=</span> mappend asL (shift nL asR)
      bs <span class="fu">=</span> mappend bsL (shift nL bsR)
      f i s <span class="fu">|</span> s <span class="fu">&lt;</span> nL    <span class="fu">=</span> fL i s
            <span class="fu">|</span> otherwise <span class="fu">=</span> shift nL (fR i (s <span class="fu">-</span> nL))

  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;.&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs <span class="kw">where</span>

    n <span class="fu">=</span> nL <span class="fu">+</span> nR

    as <span class="fu">=</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection asL bsL)
         <span class="kw">in</span> mappend asL (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))

    f i s <span class="fu">=</span>
        <span class="kw">if</span> s <span class="fu">&lt;</span> nL
        <span class="kw">then</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection r bsL)
             <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))
        <span class="kw">else</span> shift nL (fR i (s <span class="fu">-</span> nL))
      <span class="kw">where</span>
        r <span class="fu">=</span> fL i s
    bs <span class="fu">=</span> shift nL bsR

<span class="kw">instance</span> (<span class="dt">StarSemiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span>
  star (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f' as
    <span class="kw">where</span>
      f' i s <span class="fu">=</span>
          <span class="kw">let</span> r <span class="fu">=</span> f i s
              ss <span class="fu">=</span> add (intersection r bs)
          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)

  plus (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f' bs
    <span class="kw">where</span>
      f' i s <span class="fu">=</span>
          <span class="kw">let</span> r <span class="fu">=</span> f i s
              ss <span class="fu">=</span> add (intersection r bs)
          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)


<span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>)) <span class="kw">where</span>
  fromString <span class="fu">=</span> mul <span class="fu">.</span> map once</code></pre></div>
<p>This begins to show some of the real power of using semirings and covectors. We have a normal regular expression implementation when we use the covector over bools. Use the probability semiring, and you’ve got probabilistic parsing. Instead of a map, if you use an integer (each bit being a value, the keys being the bit position), you have a super-fast implementation (and the final implementation used in the original example).</p>
<p>Swap in the <a href="https://ncatlab.org/nlab/show/max-plus+algebra">tropical semiring</a>: a semiring over the reals where addition is the max function, and multiplication is addition of reals. Now you’ve got a depth-first parser.</p>
<p>That’s how you might swap in different interpretations. How about swapping in different <em>implementations</em>? Well, there might be some use to swapping in the <a href="https://en.wikipedia.org/wiki/CYK_algorithm">CYK algorithm</a>, or the Gauss-Jordan-Floyd-Warshall-McNaughton-Yamada algorithm <span class="citation">(O’Connor 2011)</span>. You can use these in combination with a different representation of the underlying data structure: a matrix.</p>
<h2 id="square-matrices">Square Matrices</h2>
<p>A square matrix can represent your function from input states to output states. Take, for instance, a regular expression with three possible states. Its state transfer function might look like this:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">{</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd><mi>∅</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">transfer = \begin{cases} 1 \quad &amp; \{ 2, 3 \} \\ 2 \quad &amp; \{ 1 \} \\ 3 \quad &amp; \emptyset \end{cases}</annotation></semantics></math></p>
<p>It has the type of:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">State</span></code> is an integer. You can represent the set as a vector, where each position is a key, and each value is whether or not that key is present:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd><mtable><mtr><mtd><mo stretchy="false" form="prefix">(</mo><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable></mtd></mtr><mtr><mtd><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd><mtable><mtr><mtd><mo stretchy="false" form="prefix">(</mo><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable></mtd></mtr><mtr><mtd><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd><mtable><mtr><mtd><mo stretchy="false" form="prefix">(</mo><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">transfer = \begin{cases} 1 \quad &amp; \begin{array} ( 0 &amp; 1 &amp; 1 ) \end{array} \\ 2 \quad &amp; \begin{array} ( 1 &amp; 0 &amp; 0 ) \end{array} \\ 3 \quad &amp; \begin{array} ( 0 &amp; 0 &amp; 0 ) \end{array} \end{cases}</annotation></semantics></math></p>
<p>Then, the matrix representation is obvious:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">transfer = \left( \begin{array}{ccc} 0 &amp; 1 &amp; 1 \\ 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right)</annotation></semantics></math></p>
<p>This is the semiring of square matrices. It is, of course, yet <em>another</em> covector. The “keys” are the transfers: <code class="sourceCode haskell"><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dv">2</span></code> or <code class="sourceCode haskell"><span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dv">3</span></code>, represented by the indices of the matrix. The “values” are whether or not that transfer is permitted.</p>
<p>The algorithms for the usual semiring operations on matrices like this are well-known and well-optimized. I haven’t yet fiddled around with them Haskell, so I don’t know how fast they can be. For now, though, there’s an elegant list-based implementation in <span class="citation">Dolan (2013)</span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Matrix</span> a <span class="fu">=</span> <span class="dt">Scalar</span> a
              <span class="fu">|</span> <span class="dt">Matrix</span> [[a]]
              
<span class="ot">mjoin ::</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a) <span class="ot">-&gt;</span> <span class="dt">Matrix</span> a
mjoin (<span class="dt">Matrix</span> ws, <span class="dt">Matrix</span> xs, <span class="dt">Matrix</span> ys, <span class="dt">Matrix</span> zs) <span class="fu">=</span>
  <span class="dt">Matrix</span> ((zipWith (<span class="fu">++</span>) ws xs) <span class="fu">++</span> (zipWith (<span class="fu">++</span>) ys zs))
  
<span class="ot">msplit ::</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a)
msplit (<span class="dt">Matrix</span> (row<span class="fu">:</span>rows)) <span class="fu">=</span> 
  (<span class="dt">Matrix</span> [[first]], <span class="dt">Matrix</span> [top]
  ,<span class="dt">Matrix</span> left,      <span class="dt">Matrix</span> rest )
  <span class="kw">where</span>
    (first<span class="fu">:</span>top) <span class="fu">=</span> row
    (left,rest) <span class="fu">=</span> unzip (map (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> ([x],xs)) rows)
    
<span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dt">Scalar</span> zero
  one <span class="fu">=</span> <span class="dt">Scalar</span> one
  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;+&gt;</span> y)
  <span class="dt">Matrix</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span>
    <span class="dt">Matrix</span> (zipWith (zipWith (<span class="fu">&lt;+&gt;</span>)) x y)
  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> m <span class="fu">=</span> m <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> x
  <span class="dt">Matrix</span> [[x]] <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> [[x <span class="fu">&lt;+&gt;</span> y]]
  x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> mjoin (first <span class="fu">&lt;+&gt;</span> y, top, left, rest <span class="fu">&lt;+&gt;</span> y)
    <span class="kw">where</span> (first, top, left, rest) <span class="fu">=</span> msplit x
  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;.&gt;</span> y)
  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (x<span class="fu">&lt;.&gt;</span>) y)
  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (<span class="fu">&lt;.&gt;</span>y) x)
  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> 
    <span class="dt">Matrix</span> [ [ foldl1 (<span class="fu">&lt;+&gt;</span>) (zipWith (<span class="fu">&lt;.&gt;</span>) row col) <span class="fu">|</span> col <span class="ot">&lt;-</span> cols ] 
           <span class="fu">|</span> row <span class="ot">&lt;-</span> x ] <span class="kw">where</span> cols <span class="fu">=</span> transpose y

<span class="kw">instance</span> <span class="dt">StarSemiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span>
  star (<span class="dt">Matrix</span> [[x]]) <span class="fu">=</span> <span class="dt">Matrix</span> [[star x]]
  star m <span class="fu">=</span> mjoin (first' <span class="fu">&lt;+&gt;</span> top' <span class="fu">&lt;.&gt;</span> rest' <span class="fu">&lt;.&gt;</span> left'
                 ,top' <span class="fu">&lt;.&gt;</span> rest', rest' <span class="fu">&lt;.&gt;</span> left', rest')
    <span class="kw">where</span>
      (first, top, left, rest) <span class="fu">=</span> msplit m
      first' <span class="fu">=</span> star first
      top' <span class="fu">=</span> first' <span class="fu">&lt;.&gt;</span> top
      left' <span class="fu">=</span> left <span class="fu">&lt;.&gt;</span> first'
      rest' <span class="fu">=</span> star (rest <span class="fu">&lt;+&gt;</span> left' <span class="fu">&lt;.&gt;</span> top)</code></pre></div>
<h2 id="permutation-parsing">Permutation parsing</h2>
<p>A lot of the use from semirings comes from “attaching” them to other values. Attaching a semiring to effects (in the form of an applicative) can give you <em>repetition</em> of those effects. The excellent <a href="http://hackage.haskell.org/package/ReplicateEffects">ReplicateEffects</a> library explores this concept in depth.</p>
<p>It’s based on this type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Replicate</span> a b
  <span class="fu">=</span> <span class="dt">Nil</span>
  <span class="fu">|</span> <span class="dt">Cons</span> (<span class="dt">Maybe</span> b) (<span class="dt">Replicate</span> a (a <span class="ot">-&gt;</span> b))</code></pre></div>
<p>This type can be made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> (and <code class="sourceCode haskell"><span class="dt">Starsemiring</span></code>, etc) trivially.</p>
<p>In the simplest case, it has the same behaviour as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#v:replicateM"><code class="sourceCode haskell">replicateM</code></a>. Even the more complex combinators, like <code class="sourceCode haskell">atLeast</code>, can be built on <code class="sourceCode haskell"><span class="dt">Alternative</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">atLeast ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]
atLeast m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span>
  go <span class="dv">0</span> <span class="fu">=</span> many f
  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>))
  
<span class="ot">atMost ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]
atMost m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span>
  go <span class="dv">0</span> <span class="fu">=</span> pure []
  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>)) <span class="fu">&lt;|&gt;</span> pure []</code></pre></div>
<p>There are two main benefits over using the standard alternative implementation. First, you can choose greedy or lazy evaluation of the effects <em>after</em> the replication is built.</p>
<p>Secondly, the <em>order</em> of the effects doesn’t have to be specified. This allows you to execute permutations of the effects, in a permutation parser, for instance. The permutation is totally decoupled from the declaration of the repetition (it’s in a totally separate library, in fact: <a href="http://hackage.haskell.org/package/PermuteEffects">PermuteEffects</a>). Its construction is reminiscent of the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html#t:AltF">free alternative</a>.</p>
<p>Having the replicate type conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> is all well and good: what I’m interested in is seeing if its implementation is another semiring-based object in disguise. I’ll revisit this in another post.</p>
<h2 id="algebraic-search">Algebraic Search</h2>
<p>List comprehension notation is one of my all-time favourite bits of syntactic sugar. It seems almost <em>too</em> declarative to have a reasonable implementation strategy. The vast majority of the time, it actually works in a sensible way. There are exceptions, though. Take a reasonable definition of a list of Pythagorean triples:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</code></pre></div>
<p>The above expression will diverge. It will search through every possible value for <code class="sourceCode haskell">z</code> before incrementing either <code class="sourceCode haskell">x</code> or <code class="sourceCode haskell">y</code>. Since there are infinite values for <code class="sourceCode haskell">z</code>, it will never find a triple. For search problems like the above, a list comprehension is equivalent to depth-first search.</p>
<p>In order to express another kind of search (either breadth-first or depth-bounded), a different monad is needed. These monads explored in <span class="citation">Fischer and others (2009)</span> and <span class="citation">Spivey (2009)</span>.</p>
<p>You can actually use the <em>exact</em> same notation as above with another monad using <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XMonadComprehensions</span></code> and <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedLists</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">trips ::</span> ( <span class="dt">Alternative</span> m
         , <span class="dt">Monad</span> m
         , <span class="dt">IsList</span> (m <span class="dt">Integer</span>)
         , <span class="dt">Enum</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>))
         , <span class="dt">Num</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>)))
      <span class="ot">=&gt;</span> m (<span class="dt">Integer</span>,<span class="dt">Integer</span>,<span class="dt">Integer</span>)
trips <span class="fu">=</span> [ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</code></pre></div>
<p>So then, here’s the challenge: swap in different <code class="sourceCode haskell">m</code>s via a type annotation, and prevent the above expression from diverging.</p>
<p>As one example, here’s some code adapted from <span class="citation">Fischer and others (2009)</span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Monoid</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">ContT</span> (const (pure mempty))
  mappend (<span class="dt">ContT</span> f) (<span class="dt">ContT</span> g) <span class="fu">=</span> <span class="dt">ContT</span> (\x <span class="ot">-&gt;</span> liftA2 mappend (f x) (g x))
  
<span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> {<span class="ot"> runList ::</span> forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Cont</span> m a } <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">List</span> <span class="kw">where</span> foldMap <span class="fu">=</span> flip (runCont<span class="fu">.</span>runList)
  
<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">List</span> a) <span class="kw">where</span> show <span class="fu">=</span> show <span class="fu">.</span> foldr (<span class="fu">:</span>) []

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  mappend (<span class="dt">List</span> x) (<span class="dt">List</span> y) <span class="fu">=</span> <span class="dt">List</span> (mappend x y)
  mempty <span class="fu">=</span> <span class="dt">List</span> mempty
  
<span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  zero <span class="fu">=</span> mempty
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> mappend
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend
  one <span class="fu">=</span> pure mempty

<span class="ot">bfs ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> [a]
bfs <span class="fu">=</span> toList <span class="fu">.</span> fold <span class="fu">.</span> levels <span class="fu">.</span> anyOf

<span class="kw">newtype</span> <span class="dt">Levels</span> a <span class="fu">=</span> <span class="dt">Levels</span> {<span class="ot"> levels ::</span> [<span class="dt">List</span> a] } <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]
  <span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs <span class="fu">=</span> <span class="dt">Levels</span> [ f <span class="fu">&lt;*&gt;</span> x <span class="fu">|</span> f <span class="ot">&lt;-</span> fs, x <span class="ot">&lt;-</span> xs ]
  
<span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Levels</span> <span class="kw">where</span>
  empty <span class="fu">=</span> <span class="dt">Levels</span> []
  <span class="dt">Levels</span> x <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> y <span class="fu">=</span> <span class="dt">Levels</span> (mempty <span class="fu">:</span> merge x y)

<span class="kw">instance</span> <span class="dt">IsList</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">List</span> a) <span class="fu">=</span> a
  fromList <span class="fu">=</span> anyOf
  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []
  
<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">List</span> <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">List</span> (pure x)
  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap

<span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">List</span> <span class="kw">where</span>
  empty <span class="fu">=</span> mempty
  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> mappend

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">List</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldMap f x

<span class="ot">anyOf ::</span> (<span class="dt">Alternative</span> m, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a
anyOf <span class="fu">=</span> getAlt <span class="fu">.</span> foldMap (<span class="dt">Alt</span> <span class="fu">.</span> pure)

<span class="ot">merge ::</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a]
merge []      ys    <span class="fu">=</span> ys
merge xs      []    <span class="fu">=</span> xs
merge (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> mappend x y <span class="fu">:</span> merge xs ys</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">take <span class="dv">3</span> (bfs trips)
[(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>)]</code></pre></div>
<p>The only relevance to semirings is the merge function. The semiring over lists is the semiring over polynomials:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span>
  one <span class="fu">=</span> [one]
  zero <span class="fu">=</span> []
  [] <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> ys
  xs <span class="fu">&lt;+&gt;</span> [] <span class="fu">=</span> xs
  (x<span class="fu">:</span>xs) <span class="fu">&lt;+&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">:</span> (xs <span class="fu">&lt;+&gt;</span> ys)
  [] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []
  _ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []
  (x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span>
    (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">:</span> (map (x <span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> map (<span class="fu">&lt;.&gt;</span> y) xs <span class="fu">&lt;+&gt;</span> (xs <span class="fu">&lt;.&gt;</span> ys))</code></pre></div>
<p>The <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> is the same as the <code class="sourceCode haskell">merge</code> function. I think the <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> might be a more valid definition of the <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> function, also.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]
  <span class="dt">Levels</span> [] <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span> <span class="dt">Levels</span> []
  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> [] <span class="fu">=</span> <span class="dt">Levels</span> []
  <span class="dt">Levels</span> (f<span class="fu">:</span>fs) <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Levels</span> <span class="fu">$</span>
    (f <span class="fu">&lt;*&gt;</span> x) <span class="fu">:</span> levels (<span class="dt">Levels</span> (fmap (f <span class="fu">&lt;*&gt;</span>) xs) 
             <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> (fmap (<span class="fu">&lt;*&gt;</span> x) fs)
             <span class="fu">&lt;|&gt;</span> (<span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs))</code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>I’ve only scratched the surface of this abstraction. There are several other interesting semirings: polynomials, logs, Viterbi, Łukasiewicz, languages, multisets, bidirectional parsers, etc. Hopefully I’ll eventually be able to put this stuff into a library or something. In the meantime, I definitely will write some posts on the application to context-free parsing, bidirectional parsing (I just read <span class="citation">Breitner (2016)</span>) and search.</p>
<h2 id="references" class="unnumbered">References</h2>
<div id="refs" class="references">
<div id="ref-boom_further_1981">
<p>Boom, H. J. 1981. “Further thoughts on abstracto.” <em>Working Paper ELC-9, IFIP WG 2.1</em>. <a href="http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf" class="uri">http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf</a>.</p>
</div>
<div id="ref-breitner_showcasing_2016">
<p>Breitner, Joachim. 2016. “Showcasing applicative. Joachim breitner’s blog.” <a href="http://www.joachim-breitner.de/blog/710-Showcasing_Applicative" class="uri">http://www.joachim-breitner.de/blog/710-Showcasing_Applicative</a>.</p>
</div>
<div id="ref-doel_free_2015">
<p>Doel, Dan. 2015. “Free monoids in haskell. The comonad.Reader.” <a href="http://comonad.com/reader/2015/free-monoids-in-haskell/" class="uri">http://comonad.com/reader/2015/free-monoids-in-haskell/</a>.</p>
</div>
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. “Fun with semirings: A functional pearl on the abuse of linear algebra.” In <em>ACM SIGPLAN notices</em>, 48:101–110. ACM. <a href="http://dl.acm.org/citation.cfm?id=2500613" class="uri">http://dl.acm.org/citation.cfm?id=2500613</a>.</p>
</div>
<div id="ref-droste_semirings_2009">
<p>Droste, Manfred, and Werner Kuich. 2009. “Semirings and formal power series.” In <em>Handbook of weighted automata</em>, ed by. Manfred Droste, Werner Kuich, and Heiko Vogler, 1:3–28. Monographs in theoretical computer science. an EATCS series. Springer Berlin Heidelberg. <a href="http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf">http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf</a>.</p>
</div>
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. <a href="http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a" class="uri">http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a</a>.</p>
</div>
<div id="ref-fischer_reinventing_2009">
<p>Fischer, Sebastian, and others. 2009. “Reinventing haskell backtracking.” In, 2875–2888. <a href="http://sebfisch.de/Reinventing.pdf" class="uri">http://sebfisch.de/Reinventing.pdf</a>.</p>
</div>
<div id="ref-hirschowitz_modules_2010">
<p>Hirschowitz, André, and Marco Maggesi. 2010. “Modules over monads and initial semantics.” <em>Information and Computation</em> 208 (5). Special issue: 14th workshop on logic, language, information and computation (WoLLIC 2007) (May 1): 545–564. doi:<a href="https://doi.org/10.1016/j.ic.2009.07.003">10.1016/j.ic.2009.07.003</a>. <a href="http://www.sciencedirect.com/science/article/pii/S0890540109002405" class="uri">http://www.sciencedirect.com/science/article/pii/S0890540109002405</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.” <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-kmett_free_2011">
<p>Kmett, Edward. 2011a. “Free monads for less (part 2 of 3): Yoneda. The comonad.Reader.” <a href="http://comonad.com/reader/2011/free-monads-for-less-2/" class="uri">http://comonad.com/reader/2011/free-monads-for-less-2/</a>.</p>
</div>
<div id="ref-kmett_modules_2011">
<p>———. 2011b. “Modules and functional linear functionals. The comonad.Reader.” <a href="http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/" class="uri">http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory efficient implementation of probability monads.” <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf" class="uri">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-oconnor_very_2011">
<p>O’Connor, Russell. 2011. “A very general method of computing shortest paths. Russell o’Connor’s blog.” <a href="http://r6.ca/blog/20110808T035622Z.html" class="uri">http://r6.ca/blog/20110808T035622Z.html</a>.</p>
</div>
<div id="ref-piponi_monad_2009">
<p>Piponi, Dan. 2009. “A monad for combinatorial search with heuristics. A neighborhood of infinity.” <a href="http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html" class="uri">http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. “From monoids to near-semirings: The essence of MonadPlus and alternative.” In <em>Proceedings of the 17th international symposium on principles and practice of declarative programming</em>, 196–207. ACM. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf" class="uri">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. “Algebras for combinatorial search.” <em>Journal of Functional Programming</em> 19 (3): 469–487. <a href="https://pdfs.semanticscholar.org/0e59/fbb5bd4dab059e1736edb936d98ae0317efd.pdf" class="uri">https://pdfs.semanticscholar.org/0e59/fbb5bd4dab059e1736edb936d98ae0317efd.pdf</a>.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
