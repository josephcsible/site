<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>A Strategy for Swift Protocols - Donnacha Oisín Kidney</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>A Strategy for Swift Protocols</h2>

            <div class="info">
    Posted on July 17, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Swift.html">Swift</a>
    
</div>

<h3 id="a-misguided-over-simplified-strategy">A Misguided, Over-Simplified Strategy</h3>
<h1 id="it-makes-sense-to-me-so">It Makes Sense to Me, so…</h1>
<p>So I’ve been drinking the Protocol-Oriented-Programming gatorade for a while now. I’ve taken it to the extreme a little: you won’t find a class in pretty much any of my code these days. So, before I pull it back a little, I thought I’d put down my strategy so far for how to handle these protocol things.</p>
<p>To give you an idea of where I’m coming from: I never really understood object-oriented programming. It never clicked with me. I mean, I know the basic ideas, but they were never internalised. On the other hand, functional programming was a breeze (by comparison). I should be clear: by FP I don’t really mean monads or functors or applicative functors and monoids and commands and arrows and lenses and flux capacitors. I think everyone has a relatively difficult time wrapping their heads around that stuff.</p>
<p>I mean the <em>patterns</em> you see in FP. Pure functions - of course - but other things, also. Things that aren’t strictly FP, but just tend to be found among the FP: type classes, currying, immutability, declarative-ness, laziness, higher-order functions. Contrast that to the patterns you find in OOP: the delegate pattern, class inheritance, single-dependancy whatnot (I can’t even name them because I’m sure I’m mixing up and misunderstanding them).</p>
<p>Now, there are probably good reasons why I understand FP a little easier than OOP (or I think I do). OOP was what I saw first: when I began coding, it was in OOP. By the time I tried to understand, say, higher-order functions, I had already gotten my head around functions, types, variables, etc. Whereas when I first read “Python is an <em>object-oriented</em> programming language”, I had written my first hello world a few weeks before.</p>
<p>On top of that, I’m a hobbyist - I don’t like making things that really work, because that’s annoying. I am <em>very good</em> at finding you Fibonacci numbers. I don’t need to know about state, or IO, so I’m perfectly fine in the clean, pleasant world of FP (or semi-FP).</p>
<p>So what about protocols, then? Well, now that you know what kind of person you’re listening to, it might make sense when I say this: protocols are <em>awesome</em>. They make <em>so much</em> sense. I can’t believe we were ever doing things any other way.</p>
<p>Are protocols FP? Kind of. The first implementation of something protocol-like was probably in Haskell, with type classes. But OOP had a very similar system soon after, in the form of generics. And Dave Abrahams, who works on Swift, was the main guy for templates in C++ for a long time. They’re not FP in the traditional sense, but they <em>are</em> FP in the sense that I understand it: they’re a certain kind of style/technique. And they fit right in with the rest of the styles and techniques of FP.</p>
<h1 id="how-to-do-it">How to do it</h1>
<p>Anyway, I should get to my strategy for using them. Here’s my ridiculously oversimplified (mis)understanding of how you should see them: protocols describe <em>abilities</em> and <em>talents</em>. God that’s pretentious. Lemme try again: a protocol represents something a type <em>can</em> do, and <em>how well</em> it can do it. That’s a bit better.</p>
<p>Let’s look to the standard library for our examples here. Say you want to make a method that emulates Python’s slicing, where you can hop over elements of a sequence. Something like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public extension SequenceType {
  func <span class="fu">hop</span>(n: Int) -&gt; [Generator.<span class="fu">Element</span>] {
    <span class="kw">var</span> i = n - <span class="dv">1</span>
    <span class="kw">return</span> self.<span class="fu">filter</span> {
      _ -&gt; Bool in
      <span class="kw">if</span> ++i == n {
        i = <span class="dv">0</span>
        <span class="kw">return</span> <span class="kw">true</span>
      } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="kw">false</span>
      }
    }
  }
}
[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">hop</span>(<span class="dv">2</span>) <span class="co">// [1, 3, 5]</span></code></pre></div>
<p>We’re in protocol-land right away: <code class="sourceCode scala">SequenceType</code>. This is an “ability”. The method exists on everything with the <em>ability</em> to act like a sequence. That means arrays, sets, dictionaries, strings. Actually, a better example of the “ability” would be this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension IntegerArithmeticType {
  func <span class="dt">double</span>() -&gt; Self {
    <span class="kw">return</span> self + self
  }
}

<span class="fl">2.</span><span class="dt">double</span>() <span class="co">// 4</span></code></pre></div>
<p>Goodness gracious that’s contrived. But anyway, you get the idea. Anything that can do integer arithmetic gets that method.</p>
<p>Now, back to the hop method. Maybe it’s very expensive to actually retrieve every intermediate element and then discard it - that’s what filter is doing, after all. Why not just do an index lookup?</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public extension CollectionType {
  func <span class="fu">hop</span>(n: Index.<span class="fu">Distance</span>) -&gt; [Generator.<span class="fu">Element</span>] {
    
    <span class="kw">var</span> ar: [Generator.<span class="fu">Element</span>] = []
    
    <span class="kw">for</span> <span class="kw">var</span> i = startIndex; 
        indices.<span class="fu">contains</span>(i); 
        i = <span class="fu">advance</span>(i, n) {
          ar.<span class="fu">append</span>(self[i])
    }
    
    <span class="kw">return</span> ar
  }
}</code></pre></div>
<p>There we go! Everything can <em>do</em> the hop method, but <code class="sourceCode scala">CollectionType</code>s can do it <em>well</em>. In fact, some <code class="sourceCode scala">CollectionType</code>s can do it very well indeed:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public extension CollectionType where Index : RandomAccessIndexType {  
  func <span class="fu">hop</span>(n: Index.<span class="fu">Stride</span>) -&gt; [Generator.<span class="fu">Element</span>] {
    <span class="kw">return</span> <span class="fu">stride</span>(from: startIndex, to: endIndex, by: n).<span class="fu">map</span>{self[$<span class="dv">0</span>]}
  }
}</code></pre></div>
<p>You see this kind of thing all around the standard library, but most prominently with the index types. If something is able to do something, it gets the bare-bones, inefficient implementation. Then, for types with all the bells and whistles, you get the clever, blazing-fast version. And to the user, all you see is some easy-looking <code class="sourceCode scala"><span class="fu">indexOf</span>()</code> function.</p>
<p>So here’s how I think you should be doing your APIs: if at all possible, write your function as a method. Write the most bare-bones, slow version of it you possibly can that still makes sense. Then, specialise where it suits.</p>
<p>(I realise now that I may have just described a design pattern that was very obvious to everyone but me. Ah, well)</p>
<h1 id="the-why">The Why</h1>
<p>There are pretty major advantages to this. Your two other options are generally class inheritance, or global functions with generics. <a href="https://developer.apple.com/videos/wwdc/2015/?id=408">The best video from WWDC</a> talks about class inheritance, so I’ll stay away from that. In contrast to global functions, here are the advantages:</p>
<h2 id="more-discoverable">More discoverable</h2>
<p>Hit dot after whatever thing you’re interested in, and the little list of available goodies pops up. It’s also easy to find in the documentation (what kind of methods do I have on sequences? vs. Right, here’s the page for the global functions, cmd-f “Sequence”… hmm, <code class="sourceCode scala">indexOf</code> isn’t here…)</p>
<h2 id="function-compositionish">Function composition(ish)</h2>
<p>We currently have this:</p>
<pre><code>g(f(x))</code></pre>
<p>Now, if we were in Haskell-land, you could write:</p>
<pre><code>(g . f) x</code></pre>
<p>But we’re not. However, if f is a method on x, and g is a method on whatever if returned by f, you can have:</p>
<pre><code>x.f().g()</code></pre>
<p>Maybe a bit of a bad example, but <a href="http://airspeedvelocity.net/2015/06/23/protocol-extensions-and-the-death-of-the-pipe-forward-operator/">combine that with <code class="sourceCode scala">flatMap</code> and laziness and you’ve got some handsome-looking, powerful functions right there.</a></p>
<h2 id="easy-to-build-hierarchies">Easy-to-build hierarchies</h2>
<p>I find myself often getting a bit philosophical around all of these protocols (“yeah, but what does it <em>mean</em> to be <code class="sourceCode scala">IntegerLiteralConvertible</code>? I mean, aren’t we <em>all</em> <code class="sourceCode scala">IntegerLiteralConvertible</code>, in a way?”, “Woah”). I see places where I can extend a previous method to things I hadn’t even thought of applying it to. And with the quicklook, and the way the documentation is structured, none of this stuff becomes complicated.</p>
<p>Obviously this is a little bit of a straw man - there are some obvious cases where protocol extensions don’t make a lot of sense. Having “double” as an extension on <code class="sourceCode scala">IntegerArithmeticType</code> is sheer silliness - but I think something like <code class="sourceCode scala"><span class="fu">sqrt</span>()</code> would be odd, as well. If only because it decreases readability, I’m not sure that those kinds of things are good ideas. At the end of the day, you’re a reasonable, intelligent person, and you know where this stuff works. Just have it knocking around in your brain, so when you come across something that doesn’t work <em>quite right</em>, you’ll have protocol extensions as one of your other options.</p>
<p>If you want to see an example of protocols taken to the nth degree, the examples I’ve had here are taken from my library, <a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a>.</p>
<p>If you’ve kept reading this far, I’m going to I’m going to really test your patience with this next bit:</p>
<h1 id="what-do-i-want">What do I want?</h1>
<h2 id="beef-up-some-of-the-meta-language">Beef up some of the meta-language</h2>
<p>You know the tiny little meta-language for protocol extensions? The one that exists between the angle brackets, after the where?</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">
extension SomeProtocol <span class="fu">where</span> (This bit) {...

func f&lt;T : SomeProtocol <span class="fu">where</span> (This bit, also)...</code></pre></div>
<p>That needs to get more powerful. Swift is big on doing loads of stuff at compile-time, and that little meta-language is effectively a script that runs as your code compiles. When it’s between the angle brackets it’s ugly, and it seems like too small a place for a lot of code, but if you start doing anything complex with it, you hit its limits quickly. Say you want to write a recursive function that works with slices. This is the absolute minimum in the angle brackets you need:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">&lt;  
  S : Sliceable where S.<span class="fu">SubSlice</span> : Sliceable,  
  S.<span class="fu">SubSlice</span>.<span class="fu">Generator</span>.<span class="fu">Element</span> == S.<span class="fu">Generator</span>.<span class="fu">Element</span>,  
  S.<span class="fu">SubSlice</span>.<span class="fu">SubSlice</span> == S.<span class="fu">SubSlice</span>  
  &gt;</code></pre></div>
<p>And if you need anything complex, well…</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func bSearch&lt;
  S : Sliceable where S.<span class="fu">SubSlice</span> : Sliceable,
  S.<span class="fu">SubSlice</span>.<span class="fu">Generator</span>.<span class="fu">Element</span> == S.<span class="fu">Generator</span>.<span class="fu">Element</span>,
  S.<span class="fu">SubSlice</span>.<span class="fu">SubSlice</span> == S.<span class="fu">SubSlice</span>,
  S.<span class="fu">Generator</span>.<span class="fu">Element</span> : Comparable,
  S.<span class="fu">Index</span> : IntegerArithmeticType,
  S.<span class="fu">Index</span> : IntegerLiteralConvertible,
  S.<span class="fu">SubSlice</span>.<span class="fu">Index</span> == S.<span class="fu">Index</span>
  &gt;(el: S.<span class="fu">Generator</span>.<span class="fu">Element</span>, list: S) -&gt; S.<span class="fu">Generator</span>.<span class="fu">Element</span>? {

    <span class="kw">if</span> list.<span class="fu">isEmpty</span> { <span class="kw">return</span> nil }

    let midInd = list.<span class="fu">endIndex</span> / <span class="dv">2</span>

    let midEl: S.<span class="fu">Generator</span>.<span class="fu">Element</span> = list[midInd] 
    <span class="co">// type inference giving me some bugs here</span>

    <span class="kw">if</span> midEl == el {
      <span class="kw">return</span> el
    }

    <span class="kw">return</span> midEl &lt; el ?
      <span class="fu">bSearch</span>(el, list: list[midInd<span class="dv">+1</span>..&lt;list.<span class="fu">endIndex</span>]) :
      <span class="fu">bSearch</span>(el, list: list[<span class="dv">0</span>..&lt;midInd])
}</code></pre></div>
<p>Yeah. And it’s only going to get more and more complex: with every new beta, more functions become methods. This protocol business is going to cause more and more function signatures to end up looking like that. With that in mind, two things, in particular, need to go into the meta-language:</p>
<ul>
<li><p>A way to summarise all of those protocols into one. Like, I should be able to declare a protocol that’s just other protocols put together:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol RecursiveSliceable:
  Sliceable where SubSlice : Sliceable,
  SubSlice.<span class="fu">Generator</span>.<span class="fu">Element</span> == Generator.<span class="fu">Element</span>,
  SubSlice.<span class="fu">SubSlice</span> == SubSlice

protocol RecursiveSliceableIntegerIndices:
  RecursiveSliceable where
  Index : IntegerArithmeticType,
  Index : IntegerLiteralConvertible,
  SubSlice.<span class="fu">Index</span> == Index

func bSearch&lt;
  S : RecursiveSliceableIntegerIndices where
  S.<span class="fu">Generator</span>.<span class="fu">Element</span> : Comparable
  &gt;(seq: S)...</code></pre></div></li>
<li><p>Support for expressions, statements and whatnot, all of which get evaluated at compile-time.</p></li>
</ul>
<h2 id="more-pop-in-the-standard-library">More POP in the Standard Library</h2>
<p>The standard library, at the moment, still has not fully crossed over to the protocol way of doing things. It’s probably more to do with resource pressure than anything else, but I’m worried that some areas may not get the full protocol treatment. I’m talking about sequences. Currently, there are structs like <code class="sourceCode scala">AnySequence</code>, which represent the old, dark days of Swift 1.2. In its description:</p>
<blockquote>
<p>A type-erased sequence.</p>
</blockquote>
<blockquote>
<p>Forwards operations to an arbitrary underlying sequence having the same <code>Element</code> type, hiding the specifics of the underlying <code class="sourceCode scala">SequenceType</code>.</p>
</blockquote>
<p>That’s no good. You shouldn’t have to erase types - your methods and functions should act on <code class="sourceCode scala">SequenceType</code>, regardless of which <code class="sourceCode scala">SequenceType</code> it is. I’m not suggesting you should get rid of that struct - it’s trivial to come up with cases where it’s needed - I’m saying you shouldn’t be using it if you don’t have to. And in one particular area of the Swift standard library, they use structs where (I feel) they should be using protocols: <code class="sourceCode scala">LazySequence</code>. It’s a wrapper struct, mainly used for functional-style methods like <code class="sourceCode scala">map</code> and <code class="sourceCode scala">filter</code> that can act lazily. <em>Why isn’t it a protocol</em>?! Currently, the lazy versions of <code class="sourceCode scala">map</code> and <code class="sourceCode scala">filter</code> are defined as methods on <code class="sourceCode scala">LazySequence</code>. What they return is a <code class="sourceCode scala">MapSequenceView</code> <em>wrapped</em> in <code class="sourceCode scala">LazySequence</code>. That way, you can chain map and filter, keeping things lazy. But why not make <code class="sourceCode scala">LazySequenceType</code> a protocol, and have <code class="sourceCode scala">MapSequenceView</code> conform to it? There’s more - <code class="sourceCode scala">LazyRandomAccessCollection</code>, <code class="sourceCode scala">LazyForwardCollection</code>, etc. <em>These should all be protocols</em>. It’s a nightmare to try and deal with these things: if you want to write a lazy method on a sequence, you have to write one for <code class="sourceCode scala">LazySequence</code>, then one for <code class="sourceCode scala">LazyForwardCollection</code>, and so on. It would be so much easier to have.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension LazySequenceType where 
  Self: CollectionType, 
  Index: RandomAccessIndexType</code></pre></div>
<p>I really don’t know why it’s not this way. Again, the Swift team may well <em>want</em> to do it, but just hasn’t got round to it. I hope so. A very optimistic voice in my mind does keep whispering, though: “<em>they’re just waiting for recursive enums, so they can introduce lazy lists… they’ve been working on a whole load of lazy sequence functions… pattern matching… uncons…</em>”</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
