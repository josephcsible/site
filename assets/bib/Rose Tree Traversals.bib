
@inproceedings{bird_understanding_2013,
	title = {Understanding {Idiomatic} {Traversals} {Backwards} and {Forwards}},
	volume = {48},
	url = {http://www.cs.ox.ac.uk/jeremy.gibbons/publications/uitbaf.pdf},
	urldate = {2016-10-31},
	booktitle = {{ACM} {SIGPLAN} {Notices}},
	publisher = {ACM},
	author = {Bird, Richard and Gibbons, Jeremy and Mehner, Stefan and Schrijvers, Tom and Voigtlaender, Janis},
	year = {2013},
	pages = {25--36},
	file = {[PDF] ox.ac.uk:files/1193/Bird et al. - Understanding Idiomatic Traversals Backwards and F.pdf:application/pdf}
}

@inproceedings{okasaki_breadth-first_2000,
	address = {New York, NY, USA},
	series = {{ICFP} '00},
	title = {Breadth-first {Numbering}: {Lessons} from a {Small} {Exercise} in {Algorithm} {Design}},
	isbn = {978-1-58113-202-1},
	shorttitle = {Breadth-first {Numbering}},
	url = {https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf},
	doi = {10.1145/351240.351253},
	abstract = {Every programmer has blind spots. Breadth-first numbering is an interesting toy problem that exposes a blind spot common to many---perhaps most---functional programmers.},
	urldate = {2018-02-17},
	booktitle = {Proceedings of the {Fifth} {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Okasaki, Chris},
	year = {2000},
	keywords = {Breadth-first numbering, breadth-first traversal, views},
	pages = {131--136},
	file = {ACM Full Text PDF:files/3295/Okasaki - 2000 - Breadth-first Numbering Lessons from a Small Exer.pdf:application/pdf}
}

@misc{gibbons_breadth-first_2015,
	title = {Breadth-{First} {Traversal}},
	url = {https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/},
	abstract = {Recently Eitan Chatav asked in the Programming Haskell group on Facebook What is the correct way to write breadth first traversal of a \$latex \{[{\textbackslash}mathsf\{Tree\}]\}\&fg=000000\$? He’s thinking o…},
	language = {en},
	urldate = {2018-03-16},
	journal = {Patterns in Functional Programming},
	author = {Gibbons, Jeremy},
	month = mar,
	year = {2015},
	file = {Snapshot:files/3563/breadth-first-traversal.html:text/html}
}

@techreport{jones_linear-time_1993,
	title = {Linear-time {Breadth}-first {Tree} {Algorithms}: {An} {Exercise} in the {Arithmetic} of {Folds} and {Zips}},
	shorttitle = {Linear-time breadth-first tree algorithms},
	url = {http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/linear.ps.gz},
	abstract = {This paper is about an application of the mathematics of the zip, reduce (fold) and accumulate (scan) operations on lists. It gives an account of the derivation of a linear-time breadth-first tree traversal algorithm, and of a subtle and efficient breadth-first tree labelling algorithm.},
	number = {71},
	institution = {Dept of Computer Science, University of Auckland},
	author = {Jones, Geraint and Gibbons, Jeremy},
	month = may,
	year = {1993},
	file = {Citeseer - Snapshot:files/3527/summary.html:text/html;Jones and Gibbons - 1993 - Linear-time Breadth-first Tree Algorithms An Exer.pdf:files/3569/Jones and Gibbons - 1993 - Linear-time Breadth-first Tree Algorithms An Exer.pdf:application/pdf}
}

@misc{feuer_is_2015,
	type = {Question},
	title = {Is a lazy, breadth-first monadic rose tree unfold possible?},
	url = {https://stackoverflow.com/q/27748526},
	abstract = {Data.Tree includes unfoldTreeM\_BF and unfoldForestM\_BF functions to construct trees breadth-first using the results of monadic actions. The tree unfolder can be written easily using the forest unfolder, so I'll focus on the latter:

unfoldForestM\_BF :: Monad m ={\textgreater}
             (b -{\textgreater} m (a, [b])) -{\textgreater} [b] -{\textgreater} m [Tree a]
Starting with a list of seeds, it applies a function to each, generating actions that will produce the tree roots and the seeds for the next level of unfolding. The algorithm used is somewhat strict, so using unfoldForestM\_BF with the Identity monad is not exactly the same as using the pure unfoldForest. I've been trying to figure out if there's a way to make it lazy without sacrificing its O(n) time bound. If (as Edward Kmett suggested to me) this is impossible, I wonder if it would be possible to do it with a more constrained type, specifically requiring MonadFix rather than Monad. The concept there would be to (somehow) set up the pointers to the results of future computations while adding those computations to the to-do list, so if they are lazy in the effects of earlier computations they will be available immediately.},
	urldate = {2018-06-01},
	journal = {Stack Overflow},
	author = {Feuer, David},
	month = jan,
	year = {2015},
	file = {Snapshot:files/4154/27752984.html:text/html}
}

@misc{cirdec_answer_2015,
	type = {Answer},
	title = {Answer to: {Is} a lazy, breadth-first monadic rose tree unfold possible?},
	url = {https://stackoverflow.com/a/27752984/4892417},
	abstract = {Data.Tree includes unfoldTreeM\_BF and unfoldForestM\_BF functions to construct trees breadth-first using the results of monadic actions. The tree unfolder can be written easily using the forest unfolder, so I'll focus on the latter:

unfoldForestM\_BF :: Monad m ={\textgreater}
             (b -{\textgreater} m (a, [b])) -{\textgreater} [b] -{\textgreater} m [Tree a]
Starting with a list of seeds, it applies a function to each, generating actions that will produce the tree roots and the seeds for the next level of unfolding. The algorithm used is somewhat strict, so using unfoldForestM\_BF with the Identity monad is not exactly the same as using the pure unfoldForest. I've been trying to figure out if there's a way to make it lazy without sacrificing its O(n) time bound. If (as Edward Kmett suggested to me) this is impossible, I wonder if it would be possible to do it with a more constrained type, specifically requiring MonadFix rather than Monad. The concept there would be to (somehow) set up the pointers to the results of future computations while adding those computations to the to-do list, so if they are lazy in the effects of earlier computations they will be available immediately.},
	language = {en},
	journal = {Stack Overflow},
	author = {Cirdec},
	month = jan,
	year = {2015},
	file = {Snapshot:files/4157/27752984.html:text/html}
}

@misc{mazayong_breadth-first_2015,
	type = {Question},
	title = {Breadth-{First} {Search} using {State} monad in {Haskell}},
	url = {https://stackoverflow.com/questions/28573287/breadth-first-search-using-state-monad-in-haskell?noredirect=1&lq=1},
	urldate = {2018-06-01},
	journal = {Stack Overflow},
	author = {MazaYong},
	month = feb,
	year = {2015},
	file = {Snapshot:files/4159/breadth-first-search-using-state-monad-in-haskell.html:text/html}
}

@misc{cirdec_answer_2015-1,
	type = {Answer},
	title = {Answer to: {Breadth}-{First} {Search} using {State} monad in {Haskell}},
	url = {https://stackoverflow.com/a/28574768/4892417},
	urldate = {2018-06-01},
	journal = {Stack Overflow},
	author = {Cirdec},
	month = feb,
	year = {2015},
	file = {Snapshot:files/4163/28574768.html:text/html}
}

@misc{chatav_what_2015,
	title = {What is the correct way to write breadth first {Traversal} of a [{Tree}]?},
	url = {https://www.facebook.com/groups/programming.haskell/permalink/985981691412832/},
	abstract = {What is the correct way to write breadth first Traversal of a [Tree]? I tried this:

{\textgreater} data Tree a = Tree \{ label :: a, children :: [Tree a] \} deriving (Show)

{\textgreater} type Traversal s t a b = forall f....},
	language = {en},
	urldate = {2018-06-01},
	journal = {Facebook},
	author = {Chatav, Etian},
	month = mar,
	year = {2015},
	file = {Snapshot:files/4166/985981691412832.html:text/html}
}

@article{smith_lloyd_2009,
	title = {Lloyd {Allison}’s {Corecursive} {Queues}: {Why} {Continuations} {Matter}},
	volume = {14},
	url = {https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf},
	abstract = {In a purely functional setting, real-time queues are traditionally thought to be much harder to implement than either real-time stacks or amortized O(1) queues. In “Circular Programs and Self-Referential Structures,” [1] Lloyd Allison uses corecursion to implement a queue by deﬁning a lazy list in terms of itself. This provides a simple, eﬃcient, and attractive implementation of real-time queues.},
	language = {en},
	number = {14},
	journal = {The Monad.Reader},
	author = {Smith, Leon P},
	month = jul,
	year = {2009},
	pages = {28},
	file = {leon - Lloyd Allison’s Corecursive Queues Why Continuati.pdf:files/4169/leon - Lloyd Allison’s Corecursive Queues Why Continuati.pdf:application/pdf}
}

@article{allison_circular_2006,
	title = {Circular {Programs} and {Self}-{Referential} {Structures}},
	volume = {19},
	issn = {1097-024X},
	url = {http://users.monash.edu/~lloyd/tildeFP/1989SPE/},
	doi = {10.1002/spe.4380190202},
	abstract = {A circular program creates a data structure whose computation depends upon itself or refers to itself. The technique is used to implement the classic data structures circular and doubly-linked lists, threaded trees and queues, in a functional programming language. These structures are normally thought to require updatable variables found in imperative languages. For example, a functional program to perform the breadth-first traversal of a tree is given. Some of the examples result in circular data structures when evaluated. Some examples are particularly space-efficient by avoiding the creation of intermediate temporary structures which would otherwise later become garbage. Lastly, the technique can be applied in an imperative language to give an elegant program.},
	language = {en},
	number = {2},
	urldate = {2018-06-01},
	journal = {Software: Practice and Experience},
	author = {Allison, Lloyd},
	month = oct,
	year = {2006},
	pages = {99--109},
	file = {:files/4172/PP.html:text/html;Allison - 2006 - Circular Programs and Self-Referential Structures.pdf:files/4177/Allison - 2006 - Circular Programs and Self-Referential Structures.pdf:application/pdf;Circular Programs and Self-Referential Structures:files/4174/1989SPE.html:text/html;Snapshot:files/4176/spe.html:text/html}
}