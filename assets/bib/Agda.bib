
@article{schrijvers_monadic_2009,
  title = {Monadic Constraint Programming},
  volume = {19},
  doi = {10.1017/S0956796809990086},
  number = {6},
  journal = {J. Funct. Program.},
  url = {http://dx.doi.org/10.1017/S0956796809990086},
  author = {Schrijvers, Tom and Stuckey, Peter J. and Wadler, Philip},
  year = {2009},
  pages = {663--697},
  file = {/Users/doisinkidney/Zotero/storage/JWHRLTMP/Schrijvers et al. - 2009 - Monadic constraint programming.pdf},
  note = {https://people.cs.kuleuven.be/\textasciitilde{}tom.schrijvers/MCP/}
}

@inproceedings{brady_inductive_2004,
  series = {{{LNCS}}},
  title = {Inductive {{Families Need Not Store Their Indices}}},
  volume = {3085},
  booktitle = {Types for {{Proofs}} and {{Programs}}, {{Torino}}, 2003},
  publisher = {{Springer-Verlag}},
  author = {Brady, Edwin and McBride, Conor and McKinna, James},
  editor = {Berardi, Stefano and Coppo, Mario and Damiani, Ferrucio},
  year = {2004},
  keywords = {Alternative Implementation,Dependent Type,Elimination Rule,Functional Language,Type Theory},
  pages = {115-129},
  file = {/Users/doisinkidney/Zotero/storage/9Y2NHXFZ/Brady et al. - 2004 - Inductive Families Need Not Store Their Indices.pdf}
}

@inproceedings{kiselyov_embedded_2009,
  title = {Embedded Probabilistic Programming},
  booktitle = {Domain-{{Specific Languages}}},
  publisher = {{Springer}},
  url = {http://okmij.org/ftp/kakuritu/Hansei.html\#derivation},
  author = {Kiselyov, Oleg and Shan, Chung-Chieh},
  year = {2009},
  pages = {360--384},
  file = {/Users/doisinkidney/Zotero/storage/RAAKX9NM/dsl-paper.pdf}
}

@inproceedings{okasaki_fast_1999,
  title = {From {{Fast Exponentiation}} to {{Square Matrices}}: {{An Adventure}} in {{Types}}},
  volume = {34},
  shorttitle = {From {{Fast Exponentiation}} to {{Square Matrices}}},
  booktitle = {Proceedings of the {{ACM SIGPLAN International Conference}} on {{Functional Programming}} ({{ICFP}}'99), {{Paris}}, {{France}}, {{September}} 27-29, 1999},
  publisher = {{ACM}},
  url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&rep=rep1\&type=pdf},
  author = {Okasaki, Chris},
  year = {1999},
  keywords = {Data Structures,Haskell,Nested Types},
  pages = {28},
  file = {/Users/doisinkidney/Zotero/storage/3UGGUBQ5/Okasaki - From Fast Exponentiation to Square Matrices An Ad.pdf;/Users/doisinkidney/Zotero/storage/CJ887PD9/Okasaki - From Fast Exponentiation to Square Matrices An Ad.pdf;/Users/doisinkidney/Zotero/storage/CWBHZ7ZJ/Okasaki - From Fast Exponentiation to Square Matrices An Ad.pdf;/Users/doisinkidney/Zotero/storage/FUDZMXJC/Okasaki - From Fast Exponentiation to Square Matrices An Ad.pdf;/Users/doisinkidney/Zotero/storage/KUNSVH7E/Okasaki - From Fast Exponentiation to Square Matrices An Ad.pdf;/Users/doisinkidney/Zotero/storage/7PAEM9RB/citation.html;/Users/doisinkidney/Zotero/storage/BE6HVENT/summary.html;/Users/doisinkidney/Zotero/storage/EK75C6D7/cat.inist.fr.html;/Users/doisinkidney/Zotero/storage/PQFC4TKW/cat.inist.fr.html;/Users/doisinkidney/Zotero/storage/TPVFFHR9/cat.inist.fr.html}
}

@article{hutton_tutorial_1999,
  title = {A {{Tutorial}} on the {{Universality}} and {{Expressiveness}} of {{Fold}}},
  volume = {9},
  issn = {09567968},
  doi = {10.1017/S0956796899003500},
  abstract = {In functional programming, fold is a standard operator that encapsulates a simple pattern of recursion for processing lists. This article is a tutorial on two key aspects of the fold operator for lists. First of all, we emphasize the use of the universal property of fold both as a proof principle that avoids the need for inductive proofs, and as a definition principle that guides the transformation of recursive functions into definitions using fold. Secondly, we show that even though the pattern of recursion encapsulated by fold is simple, in a language with tuples and functions as first-class values the fold operator has greater expressive power than might first be expected.},
  language = {en},
  number = {4},
  urldate = {2016-09-29},
  journal = {Journal of Functional Programming},
  url = {http://www.cs.nott.ac.uk/~pszgmh/fold.pdf},
  author = {Hutton, Graham},
  year = {1999},
  pages = {355--372},
  file = {/Users/doisinkidney/Zotero/storage/AUIYTJFD/Hutton - 1999 - A tutorial on the universality and expressiveness .pdf;/Users/doisinkidney/Zotero/storage/XM59CHKC/HUTTON - 1999 - A tutorial on the universality and expressiveness .pdf}
}

@inproceedings{rivas_monoids_2015,
  title = {From Monoids to Near-Semirings: The Essence of {{MonadPlus}} and {{Alternative}}},
  isbn = {978-1-4503-3516-4},
  shorttitle = {From Monoids to Near-Semirings},
  doi = {10.1145/2790449.2790514},
  abstract = {It is well-known that monads are monoids in the category of endo-functors, and in fact so are applicative functors. Unfortunately, the benefits of this unified view are lost when the additional non-determinism structure of |MonadPlus| or |Alternative| is required.

This article recovers the essence of these two type classes by extending monoids to near-semirings with both additive and multiplicative structure. This unified algebraic view enables us to generically define the free construction as well as a novel double Cayley representation that optimises both left-nested sums and left-nested products.},
  language = {en},
  urldate = {2016-11-23},
  booktitle = {Proceedings of the 17th {{International Symposium}} on {{Principles}} and {{Practice}} of {{Declarative Programming}}},
  publisher = {{ACM}},
  url = {http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf},
  author = {Rivas, Exequiel and Jaskelioff, Mauro and Schrijvers, Tom},
  year = {2015},
  pages = {196-207},
  file = {/Users/doisinkidney/Zotero/storage/TQ2SUXE7/Rivas et al. - From monoids to near-semirings the essence of Mon.pdf}
}

@article{brady_idris_2013,
  title = {Idris, a General-Purpose Dependently Typed Programming Language: {{Design}} and Implementation},
  volume = {23},
  issn = {1469-7653},
  doi = {10.1017/S095679681300018X},
  number = {05},
  journal = {Journal of Functional Programming},
  url = {http://journals.cambridge.org/article_S095679681300018X},
  author = {Brady, Edwin},
  month = sep,
  year = {2013},
  pages = {552--593},
  file = {/Users/doisinkidney/Zotero/storage/AJNPHXQQ/impldtp.pdf}
}

@phdthesis{eisenberg_dependent_2016,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1610.07978},
  title = {Dependent {{Types}} in {{Haskell}}: {{Theory}} and {{Practice}}},
  shorttitle = {Dependent {{Types}} in {{Haskell}}},
  abstract = {Haskell, as implemented in the Glasgow Haskell Compiler (GHC), has been adding new type-level programming features for some time. Many of these features---chiefly: generalized algebraic datatypes (GADTs), type families, kind polymorphism, and promoted datatypes---have brought Haskell to the doorstep of dependent types. Many dependently typed programs can even currently be encoded, but often the constructions are painful. In this dissertation, I describe Dependent Haskell, which supports full dependent types via a backward-compatible extension to today's Haskell. An important contribution of this work is an implementation, in GHC, of a portion of Dependent Haskell, with the rest to follow. The features I have implemented are already released, in GHC 8.0. This dissertation contains several practical examples of Dependent Haskell code, a full description of the differences between Dependent Haskell and today's Haskell, a novel type-safe dependently typed lambda-calculus (called Pico) suitable for use as an intermediate language for compiling Dependent Haskell, and a type inference and elaboration algorithm, Bake, that translates Dependent Haskell to type-correct Pico.},
  language = {en},
  urldate = {2017-03-04},
  school = {University of Pennsylvania},
  url = {https://github.com/goldfirere/thesis/raw/master/built/thesis.pdf},
  author = {Eisenberg, Richard A.},
  month = oct,
  year = {2016},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/doisinkidney/Zotero/storage/NNSJJDCD/Eisenberg - Dependent Types in Haskell Theory and Practice.pdf;/Users/doisinkidney/Zotero/storage/SMC3TBG8/Eisenberg - 2016 - Dependent Types in Haskell Theory and Practice.pdf;/Users/doisinkidney/Zotero/storage/M9UDD9JG/1610.html;/Users/doisinkidney/Zotero/storage/XTQICH4T/summary.html}
}

@article{gibbons_metamorphisms_2007,
  title = {Metamorphisms: {{Streaming Representation}}-{{Changers}}},
  volume = {65},
  doi = {10.1016/j.scico.2006.01.006},
  abstract = {Unfolds generate data structures, and folds consume them. A hylomorphism is a fold after an unfold, generating then consuming a virtual data structure. A metamorphism is the opposite composition, an unfold after a fold; typically, it will convert from one data representation to another. In general, metamorphisms are less interesting than hylomorphisms: there is no automatic fusion to deforest the intermediate virtual data structure. However, under certain conditions fusion is possible: some of the work of the unfold can be done before all of the work of the fold is complete. This permits streaming metamorphisms, and among other things allows conversion of infinite data representations. We present a theory of metamorphisms and outline some examples.},
  language = {en},
  number = {2},
  journal = {Science of Computer Programming},
  url = {http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/metamorphisms-scp.pdf},
  author = {Gibbons, Jeremy},
  year = {2007},
  pages = {108-139},
  file = {/Users/doisinkidney/Zotero/storage/DXL5Y9FC/Gibbons - Metamorphisms Streaming Representation-Changers.pdf}
}

@techreport{hinze_numerical_1998,
  title = {Numerical {{Representations}} as {{Higher}}-{{Order Nested Datatypes}}},
  abstract = {Number systems serve admirably as templates for container types: a container object of size n is modelled after the representation of the number n and operations on container objects are modelled after their number-theoretic counterparts. Binomial queues are probably the first data structure that was designed with this analogy in mind. In this paper we show how to express these so-called numerical representations as higher-order nested datatypes. A nested datatype allows to capture the structural invariants of a numerical representation, so that the violation of an invariant can be detected at compile-time. We develop a programming method which allows to adapt algorithms to the new representation in a mostly straightforward manner. The framework is employed to implement three different container types: binary random-access lists, binomial queues, and 2-3 finger search trees. The latter data structure, which is treated in some depth, can be seen as the main innovation from a data-struct...},
  number = {IAI-TR-98-12},
  institution = {{Institut f\"ur Informatik III, Universit\"at Bonn}},
  url = {http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5},
  author = {Hinze, Ralf},
  month = dec,
  year = {1998},
  file = {/Users/doisinkidney/Zotero/storage/PHIN9HWW/Hinze - 1998 - Numerical Representations as Higher-Order Nested D.pdf;/Users/doisinkidney/Zotero/storage/EDDJFGES/summary.html}
}

@article{claessen_quickcheck_2011,
  title = {{{QuickCheck}}: {{A Lightweight Tool}} for {{Random Testing}} of {{Haskell Programs}}},
  volume = {46},
  issn = {0362-1340},
  shorttitle = {{{QuickCheck}}},
  doi = {10.1145/1988042.1988046},
  abstract = {QuickCheck is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are discribed as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffuces to obtain good coverage of the definition under test.},
  number = {4},
  urldate = {2017-06-28},
  journal = {SIGPLAN Not.},
  url = {https://pdfs.semanticscholar.org/f8a3/f613080f69d4d3e005f0133c64d44a5bb902.pdf},
  author = {Claessen, Koen and Hughes, John},
  month = may,
  year = {2011},
  pages = {53--64},
  file = {/Users/doisinkidney/Zotero/storage/2CXEEKFA/f613080f69d4d3e005f0133c64d44a5bb902.pdf}
}

@inproceedings{kiselyov_backtracking_2005,
  address = {New York, NY, USA},
  series = {{{ICFP}} '05},
  title = {Backtracking, {{Interleaving}}, and {{Terminating Monad Transformers}}: ({{Functional Pearl}})},
  isbn = {978-1-59593-064-4},
  shorttitle = {Backtracking, {{Interleaving}}, and {{Terminating Monad Transformers}}},
  doi = {10.1145/1086365.1086390},
  abstract = {We design and implement a library for adding backtracking computations to any Haskell monad. Inspired by logic programming, our library provides, in addition to the operations required by the MonadPlus interface, constructs for fair disjunctions, fair conjunctions, conditionals, pruning, and an expressive top-level interface. Implementing these additional constructs is easy in models of backtracking based on streams, but not known to be possible in continuation-based models. We show that all these additional constructs can be generically and monadically realized using a single primitive msplit. We present two implementations of the library: one using success and failure continuations; and the other using control operators for manipulating delimited continuations.},
  urldate = {2017-10-10},
  booktitle = {Proceedings of the {{Tenth ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  publisher = {{ACM}},
  url = {http://okmij.org/ftp/Computation/monads.html\#LogicT},
  author = {Kiselyov, Oleg and Shan, Chung-chieh and Friedman, Daniel P. and Sabry, Amr},
  year = {2005},
  keywords = {Backtracking,HASKELL,Haskell,Logic Monad,Prolog,continuations,control delimiters,logic programming,streams},
  pages = {192--203},
  file = {/Users/doisinkidney/Zotero/storage/5MZ2N74Z/LogicT.pdf;/Users/doisinkidney/Zotero/storage/AEDCPH4V/1dceb887ebbe0a16fa650a07d008ed62d96c.pdf}
}

@incollection{spivey_combinators_2003,
  series = {Cornerstones in {{Computing}}},
  title = {Combinators for Logic Programming},
  booktitle = {The {{Fun}} of {{Programming}}},
  publisher = {{Palgrave}},
  url = {https://www.cs.ox.ac.uk/publications/books/fop/dist/fop/chapters/9/Logic.hs},
  author = {Spivey, J. Michael and Seres, Silvija},
  month = mar,
  year = {2003},
  file = {/Users/doisinkidney/Zotero/storage/QVIRPZJZ/Logic.hs}
}

@article{spivey_algebras_2009,
  title = {Algebras for Combinatorial Search},
  volume = {19},
  issn = {1469-7653, 0956-7968},
  doi = {10.1017/S0956796809007321},
  abstract = {AbstractCombinatorial search strategies including depth-first, breadth-first and depth-bounded search are shown to be different implementations of a common algebraic specification that emphasizes the compositionality of the strategies. This specification is placed in a categorical setting that combines algebraic specifications and monads.},
  number = {3-4},
  urldate = {2017-10-13},
  journal = {Journal of Functional Programming},
  url = {https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf},
  author = {Spivey, J. Michael},
  month = jul,
  year = {2009},
  pages = {469-487},
  file = {/Users/doisinkidney/Zotero/storage/RJBV6ADB/373bb6e7e7837ebc524da0a25903958554ed.pdf;/Users/doisinkidney/Zotero/storage/HVBMPBM2/AB57FF99CEA76C1C31A336B560D6FD3C.html}
}

@article{mu_theory_2004,
  series = {Mathematics of {{Program Construction}} ({{MPC}} 2002)},
  title = {Theory and Applications of Inverting Functions as Folds},
  volume = {51},
  issn = {0167-6423},
  doi = {10.1016/j.scico.2003.09.003},
  abstract = {This paper is devoted to the proof, applications, and generalisation of a theorem, due to Bird and de Moor, that gave conditions under which a total function can be expressed as a relational fold. The theorem is illustrated with three problems, all dealing with constructing trees with various properties. It is then generalised to give conditions under which the inverse of a partial function can be expressed as a relational hylomorphism. Its proof makes use of Doornbos and Backhouse's theory on well-foundedness and reductivity. Possible applications of the generalised theorem is discussed.},
  language = {en},
  number = {1},
  urldate = {2018-02-17},
  journal = {Science of Computer Programming},
  url = {http://www.sciencedirect.com/science/article/pii/S0167642304000140},
  author = {Mu, Shin-Cheng and Bird, Richard},
  month = may,
  year = {2004},
  keywords = {Fold,Program derivation,Program inversion},
  pages = {87-116},
  file = {/Users/doisinkidney/Zotero/storage/3BIIK589/Mu and Bird - 2004 - Theory and applications of inverting functions as .pdf;/Users/doisinkidney/Zotero/storage/847R7SZS/Mu and Bird - 2004 - Theory and applications of inverting functions as .pdf;/Users/doisinkidney/Zotero/storage/2YTKFEZQ/S0167642304000140.html}
}

@misc{bakst_liquidhaskell_2018,
  title = {{{LiquidHaskell}}: {{Liquid Types For Haskell}}},
  shorttitle = {{{LiquidHaskell}}},
  urldate = {2018-02-19},
  howpublished = {ucsd-progsys},
  url = {https://github.com/ucsd-progsys/liquidhaskell},
  author = {Bakst, Alexander and Jhala, Ranjit and Kawaguchi, Ming and Rondon, Patrick and Seidel, Eric and Smith, Michael and Tondwalkar, Anish and Tetreault, Chris and Vazou, Niki},
  month = feb,
  year = {2018}
}

@inproceedings{goos_rebuilding_2003,
  address = {Berlin, Heidelberg},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Rebuilding a {{Tree}} from {{Its Traversals}}},
  volume = {2895},
  isbn = {978-3-540-20536-4 978-3-540-40018-9},
  shorttitle = {Rebuilding a {{Tree}} from {{Its Traversals}}},
  abstract = {Given the inorder and preorder traversal of a binary tree whose labels are all distinct, one can reconstruct the tree. This article examines two existing algorithms for rebuilding the tree in a functional framework, using existing theory on function inversion. We also present a new, although complicated, algorithm by trying another possibility not explored before.},
  language = {en},
  urldate = {2018-03-14},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-540-40018-9_18},
  author = {Mu, Shin-Cheng and Bird, Richard},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Ohori, Atsushi},
  year = {2003},
  keywords = {Binary Tree,Function Inversion,Functional Inverse,Program Inversion,Spine Representation},
  pages = {265-282},
  file = {/Users/doisinkidney/Zotero/storage/KIH6JYTC/Mu and Bird - 2003 - Rebuilding a Tree from Its Traversals.pdf;/Users/doisinkidney/Zotero/storage/NBSEZER7/Mu and Bird - 2003 - Rebuilding a Tree from Its Traversals.pdf},
  doi = {10.1007/978-3-540-40018-9_18}
}

@inproceedings{jones_call-pattern_2007,
  title = {Call-Pattern Specialisation for Haskell Programs},
  isbn = {978-1-59593-815-2},
  doi = {10.1145/1291151.1291200},
  abstract = {User-defined data types, pattern-matching, and recursion are ubiquitous features of Haskell programs. Sometimes a function is called with arguments that are statically known to be in constructor form, so that the work of pattern-matching is wasted. Even worse, the argument is sometimes freshly-allocated, only to be immediately decomposed by the function.},
  language = {en},
  urldate = {2018-03-21},
  publisher = {{ACM Press}},
  url = {https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/},
  author = {Jones, Simon Peyton},
  year = {2007},
  pages = {327},
  file = {/Users/doisinkidney/Zotero/storage/JMQ9HUQK/Jones - 2007 - Call-pattern specialisation for haskell programs.pdf;/Users/doisinkidney/Zotero/storage/MBT8QXM2/Jones - 2007 - Call-pattern specialisation for Haskell programs.pdf;/Users/doisinkidney/Zotero/storage/U38CF3T4/system-f-with-type-equality-coercions-2.html}
}

@article{mcbride_ornamental_2010,
  title = {Ornamental {{Algebras}}, {{Algebraic Ornaments}}},
  abstract = {This paper re-examines the presentation of datatypes in dependently typed languages, addressing in particular the issue of what it means for one datatype to be in various ways more informative than another. Informal human observations like `lists are natural numbers with extra labels' and `vectors are lists indexed by length' are expressed in a first class language of ornaments\textemdash{}presentations of fancy new types based on plain old ones.},
  language = {en},
  author = {McBride, Conor},
  year = {2010},
  pages = {8},
  file = {/Users/doisinkidney/Zotero/storage/34NGW93J/McBRIDE - 2010 - Ornamental Algebras, Algebraic Ornaments.pdf;/Users/doisinkidney/Zotero/storage/ZGWGNNDW/McBRIDE - 2011 - Ornamental Algebras, Algebraic Ornaments.pdf}
}

@article{rivas_unified_2018,
  title = {A Unified View of Monadic and Applicative Non-Determinism},
  volume = {152},
  issn = {01676423},
  doi = {10.1016/j.scico.2017.09.007},
  abstract = {It is well-known that monads are monoids in the category of endofunctors, and in fact so are applicative functors. Unfortunately, monoids do not have enough structure to account for computational effects with non-determinism operators.},
  language = {en},
  urldate = {2018-06-11},
  journal = {Science of Computer Programming},
  url = {http://linkinghub.elsevier.com/retrieve/pii/S0167642317301958},
  author = {Rivas, Exequiel and Jaskelioff, Mauro and Schrijvers, Tom},
  month = jan,
  year = {2018},
  pages = {70-98},
  file = {/Users/doisinkidney/Zotero/storage/2K23MT7N/Rivas et al. - 2018 - A unified view of monadic and applicative non-dete.pdf;/Users/doisinkidney/Zotero/storage/8MCP6ZRM/Rivas et al. - 2018 - A unified view of monadic and applicative non-dete.pdf}
}

@inproceedings{altenkirch_partiality_2017,
  address = {Berlin, Heidelberg},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Partiality, {{Revisited}}},
  volume = {10203},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_31},
  abstract = {Capretta's delay monad can be used to model partial computations, but it has the ``wrong'' notion of built-in equality, strong bisimilarity. An alternative is to quotient the delay monad by the ``right'' notion of equality, weak bisimilarity. However, recent work by Chapman et al. suggests that it is impossible to define a monad structure on the resulting construction in common forms of type theory without assuming (instances of) the axiom of countable choice.Using an idea from homotopy type theory\textemdash{}a higher inductive-inductive type\textemdash{}we construct a partiality monad without relying on countable choice. We prove that, in the presence of countable choice, our partiality monad is equivalent to the delay monad quotiented by weak bisimilarity. Furthermore we outline several applications.},
  language = {en},
  urldate = {2018-06-19},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-662-54458-7_31},
  author = {Altenkirch, Thorsten and Danielsson, Nils Anders and Kraus, Nicolai},
  month = apr,
  year = {2017},
  pages = {534-549},
  file = {/Users/doisinkidney/Zotero/storage/CTLM5XDQ/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/L8F98IQM/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/XGDP694U/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/XIJ9ASUQ/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/5NKZK8MQ/978-3-662-54458-7_31.html}
}

@inproceedings{danielsson_bag_2012,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Bag {{Equivalence}} via a {{Proof}}-{{Relevant Membership Relation}}},
  isbn = {978-3-642-32346-1 978-3-642-32347-8},
  doi = {10.1007/978-3-642-32347-8_11},
  abstract = {Two lists are bag equivalent if they are permutations of each other, i.e. if they contain the same elements, with the same multiplicity, but perhaps not in the same order. This paper describes how one can define bag equivalence as the presence of bijections between sets of membership proofs. This definition has some desirable properties: Many bag equivalences can be proved using a flexible form of equational reasoning. The definition generalises easily to arbitrary unary containers, including types with infinite values, such as streams. By using a slight variation of the definition one gets set equivalence instead, i.e. equality up to order and multiplicity. Other variations give the subset and subbag preorders. The definition works well in mechanised proofs.},
  language = {en},
  urldate = {2018-06-20},
  booktitle = {Interactive {{Theorem Proving}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  url = {https://link.springer.com/chapter/10.1007/978-3-642-32347-8_11},
  author = {Danielsson, Nils Anders},
  month = aug,
  year = {2012},
  pages = {149-165},
  file = {/Users/doisinkidney/Zotero/storage/48TN8RVW/Danielsson - 2012 - Bag Equivalence via a Proof-Relevant Membership Re.pdf;/Users/doisinkidney/Zotero/storage/6FHBRC2J/Danielsson - 2012 - Bag Equivalence via a Proof-Relevant Membership Re.pdf;/Users/doisinkidney/Zotero/storage/Z3C57Z7B/10.html}
}

@inproceedings{danielsson_lightweight_2008,
  address = {New York, NY, USA},
  series = {{{POPL}} '08},
  title = {Lightweight {{Semiformal Time Complexity Analysis}} for {{Purely Functional Data Structures}}},
  isbn = {978-1-59593-689-9},
  doi = {10.1145/1328438.1328457},
  abstract = {Okasaki and others have demonstrated how purely functional data structures that are efficient even in the presence of persistence can be constructed. To achieve good time bounds essential use is often made of laziness. The associated complexity analysis is frequently subtle, requiring careful attention to detail, and hence formalising it is valuable. This paper describes a simple library which can be used to make the analysis of a class of purely functional data structures and algorithms almost fully formal. The basic idea is to use the type system to annotate every function with the time required to compute its result. An annotated monad is used to combine time complexity annotations. The library has been used to analyse some existing data structures, for instance the deque operations of Hinze and Paterson's finger trees.},
  language = {en},
  urldate = {2018-06-20},
  booktitle = {Proceedings of the 35th {{Annual ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
  publisher = {{ACM}},
  url = {http://www.cse.chalmers.se/~nad/publications/danielsson-popl2008.pdf},
  author = {Danielsson, Nils Anders},
  year = {2008},
  keywords = {dependent types,lazy evaluation,purely functional data structures,amortised time complexity},
  pages = {133--144},
  file = {/Users/doisinkidney/Zotero/storage/8NI9UUMH/Danielsson - Lightweight Semiformal Time Complexity Analysis fo.pdf;/Users/doisinkidney/Zotero/storage/A9CNNCIR/Danielsson - Lightweight Semiformal Time Complexity Analysis fo.pdf}
}

@inproceedings{atkey_productive_2013,
  title = {Productive Coprogramming with Guarded Recursion},
  isbn = {978-1-4503-2326-0},
  doi = {10.1145/2500365.2500597},
  language = {en},
  urldate = {2018-06-21},
  publisher = {{ACM Press}},
  url = {https://bentnib.org/productive.html},
  author = {Atkey, Robert and McBride, Conor},
  year = {2013},
  pages = {197},
  file = {/Users/doisinkidney/Zotero/storage/SXKIJ6DE/Atkey and McBride - 2013 - Productive coprogramming with guarded recursion.pdf}
}

@inproceedings{mcbride_how_2014,
  address = {New York, NY, USA},
  series = {{{ICFP}} '14},
  title = {How to {{Keep Your Neighbours}} in {{Order}}},
  isbn = {978-1-4503-2873-9},
  doi = {10.1145/2628136.2628163},
  abstract = {I present a datatype-generic treatment of recursive container types whose elements are guaranteed to be stored in increasing order, with the ordering invariant rolled out systematically. Intervals, lists and binary search trees are instances of the generic treatment. On the journey to this treatment, I report a variety of failed experiments and the transferable learning experiences they triggered. I demonstrate that a total element ordering is enough to deliver insertion and flattening algorithms, and show that (with care about the formulation of the types) the implementations remain as usual. Agda's instance arguments and pattern synonyms maximize the proof search done by the typechecker and minimize the appearance of proofs in program text, often eradicating them entirely. Generalizing to indexed recursive container types, invariants such as size and balance can be expressed in addition to ordering. By way of example, I implement insertion and deletion for 2-3 trees, ensuring both order and balance by the discipline of type checking.},
  urldate = {2018-06-21},
  booktitle = {Proceedings of the 19th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  publisher = {{ACM}},
  url = {https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf},
  author = {McBride, Conor Thomas},
  year = {2014},
  keywords = {dependent types,sorting,agda,balancing,ordering},
  pages = {297--309},
  file = {/Users/doisinkidney/Zotero/storage/T8BXF2WX/McBride - How to Keep Your Neighbours in Order.pdf}
}

@inproceedings{ahman_when_2012,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {When {{Is}} a {{Container}} a {{Comonad}}?},
  isbn = {978-3-642-28728-2 978-3-642-28729-9},
  doi = {10.1007/978-3-642-28729-9_5},
  abstract = {Abbott, Altenkirch, Ghani and others have taught us that many parameterized datatypes (set functors) can be usefully analyzed via container representations in terms of a set of shapes and a set of positions in each shape. This paper builds on the observation that datatypes often carry additional structure that containers alone do not account for. We introduce directed containers to capture the common situation where every position in a datastructure determines another datastructure, informally, the sub-datastructure rooted by that position. Some natural examples are non-empty lists and node-labelled trees, and datastructures with a designated position (zippers). While containers denote set functors via a fully-faithful functor, directed containers interpret fully-faithfully into comonads. But more is true: every comonad whose underlying functor is a container is represented by a directed container. In fact, directed containers are the same as containers that are comonads. We also describe some constructions of directed containers. We have formalized our development in the dependently typed programming language Agda.},
  language = {en},
  urldate = {2018-06-27},
  booktitle = {Foundations of {{Software Science}} and {{Computational Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  url = {https://link.springer.com/chapter/10.1007/978-3-642-28729-9_5},
  author = {Ahman, Danel and Chapman, James and Uustalu, Tarmo},
  month = mar,
  year = {2012},
  pages = {74-88},
  file = {/Users/doisinkidney/Zotero/storage/D7FRX67R/Ahman et al. - 2012 - When Is a Container a Comonad.pdf;/Users/doisinkidney/Zotero/storage/RM2YW4IV/Ahman et al. - 2012 - When Is a Container a Comonad.pdf;/Users/doisinkidney/Zotero/storage/2N83EPYI/10.html;/Users/doisinkidney/Zotero/storage/3XC6FV22/978-3-642-28729-9_5.html}
}

@article{mcbride_polynomial_nodate,
  title = {A Polynomial Testing Principle},
  abstract = {Two polynomial functions of degree at most n agree on all inputs if they agree on n + 1 different inputs, e.g., on \{0, 1, 2, . . . , n\}. This fact gives us a simple procedure for testing equivalence in a language of polynomial expressions. Moreover, we may readily extend this language to include a summation operator and test standard results which are usually established inductively.},
  language = {en},
  author = {McBride, Conor},
  pages = {14},
  file = {/Users/doisinkidney/Zotero/storage/TJY6RASV/McBride - A polynomial testing principle.pdf}
}

@article{norell_dependently_2008,
  title = {Dependently {{Typed Programming}} in {{Agda}}},
  language = {en},
  author = {Norell, Ulf and Chapman, James},
  year = {2008},
  pages = {41},
  file = {/Users/doisinkidney/Zotero/storage/N2JXRX7J/Norell and Chapman - Dependently Typed Programming in Agda.pdf}
}

@article{dybjer_introduction_nodate,
  title = {An {{Introduction}} to {{Programming}} and {{Proving}} in {{Agda}} (Incomplete Draft)},
  language = {en},
  author = {Dybjer, Peter},
  pages = {24},
  file = {/Users/doisinkidney/Zotero/storage/TNAMXB5E/Dybjer - An Introduction to Programming and Proving in Agda.pdf}
}

@misc{danielsson_agda_2018,
  title = {The {{Agda}} Standard Library},
  urldate = {2018-07-28},
  url = {https://agda.github.io/agda-stdlib/README.html},
  author = {Danielsson, Nils Anders},
  collaborator = {Abel, Andreas and Andjelkovic, Stevan and Bernardy, Jean-Philippe and Berry, Peter and Hardy, Bradley and Breitner, Joachim and Bronson, Samuel and Brown, Daniel and Chapman, James and Chen, Liang-Ting and Daggitt, Matthew and Devriese, Dominique and Doel, Dan and Gerg{\H o}, \'Erdi and Grohne, Helmut and Foster, Simon and Hu, Liyang and Hu, Jason and Jansson, Patrik and Jeffrey, Alan and Kokke, Wen and Kotelnikov, Evgeny and Meshveliani, Sergei and Mertens, Eric and Morrison, Darin and Moulin, Guilhem and Mu, Shin-Cheng and Norell, Ulf and Ohkawa, Noriyuki and Pouillard, Nicolas and {Sicard-Ram\'irez}, Andr\'es and Zeilberger, Noam},
  month = jun,
  year = {2018}
}

@inproceedings{weirich_depending_2014,
  address = {New York, NY, USA},
  series = {{{ICFP}} '14},
  title = {Depending on {{Types}}},
  isbn = {978-1-4503-2873-9},
  doi = {10.1145/2628136.2631168},
  abstract = {Is Haskell a dependently typed programming language? Should it be? GHC's many type-system features, such as Generalized Algebraic Datatypes (GADTs), datatype promotion, multiparameter type classes, and type families, give programmers the ability to encode domain-specific invariants in their types. Clever Haskell programmers have used these features to enhance the reasoning capabilities of static type checking. But really, how far have we come? Could we do more? In this talk, I will discuss dependently typed programming in Haskell, through examples, analysis and comparisons with modern full-spectrum dependently typed languages, such as Coq, Agda and Idris. What sorts of dependently typed programming can be done in Haskell now? What could GHC learn from these languages? Conversely, what lessons can GHC offer in return?},
  urldate = {2018-07-29},
  booktitle = {Proceedings of the 19th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  publisher = {{ACM}},
  url = {https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf},
  author = {Weirich, Stephanie},
  year = {2014},
  keywords = {dependent types,haskell},
  pages = {241--241},
  file = {/Users/doisinkidney/Zotero/storage/D7QDGRXG/Weirich - 2014 - Depending on Types.pdf;/Users/doisinkidney/Zotero/storage/HNU7MRHG/icfp14.pdf}
}

@inproceedings{pfaff_performance_2004,
  address = {New York, NY, USA},
  series = {{{SIGMETRICS}} '04/{{Performance}} '04},
  title = {Performance {{Analysis}} of {{BSTs}} in {{System Software}}},
  isbn = {978-1-58113-873-3},
  doi = {10.1145/1005686.1005742},
  abstract = {Binary search tree (BST) based data structures, such as AVL trees, red-black trees, and splay trees, are often used in system software, such as operating system kernels. Choosing the right kind of tree can impact performance significantly, but the literature offers few empirical studies for guidance. We compare 20 BST variants using three experiments in real-world scenarios with real and artificial workloads. The results indicate that when input is expected to be randomly ordered with occasional runs of sorted order, red-black trees are preferred; when insertions often occur in sorted order, AVL trees excel for later random access, whereas splay trees perform best for later sequential or clustered access. For node representations, use of parent pointers is shown to be the fastest choice, with threaded nodes a close second choice that saves memory; nodes without parent pointers or threads suffer when traversal and modification are combined; maintaining a in-order doubly linked list is advantageous when traversal is very common; and right-threaded nodes perform poorly.},
  language = {en},
  urldate = {2018-07-29},
  booktitle = {Proceedings of the {{Joint International Conference}} on {{Measurement}} and {{Modeling}} of {{Computer Systems}}},
  publisher = {{ACM}},
  url = {https://benpfaff.org/papers/libavl.pdf},
  author = {Pfaff, Ben},
  year = {2004},
  keywords = {binary search tree,AVL tree,BST,red-black tree,splay tree,threaded tree},
  pages = {410--411},
  file = {/Users/doisinkidney/Zotero/storage/75V4WPKQ/Pfaﬀ - Performance Analysis of BSTs in System Software∗.pdf;/Users/doisinkidney/Zotero/storage/ERMAGWUW/Pfaff - 2004 - Performance Analysis of BSTs in System Software.pdf}
}

@article{cohen_cubical_2016,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1611.02108},
  primaryClass = {cs, math},
  title = {Cubical {{Type Theory}}: A Constructive Interpretation of the Univalence Axiom},
  shorttitle = {Cubical {{Type Theory}}},
  abstract = {This paper presents a type theory in which it is possible to directly manipulate \$n\$-dimensional cubes (points, lines, squares, cubes, etc.) based on an interpretation of dependent type theory in a cubical set model. This enables new ways to reason about identity types, for instance, function extensionality is directly provable in the system. Further, Voevodsky's univalence axiom is provable in this system. We also explain an extension with some higher inductive types like the circle and propositional truncation. Finally we provide semantics for this cubical type theory in a constructive meta-theory.},
  urldate = {2018-07-30},
  journal = {arXiv:1611.02108 [cs, math]},
  url = {http://arxiv.org/abs/1611.02108},
  author = {Cohen, Cyril and Coquand, Thierry and Huber, Simon and M\"ortberg, Anders},
  month = nov,
  year = {2016},
  keywords = {F.3.2,Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic},
  file = {/Users/doisinkidney/Zotero/storage/WNZZ885E/Cohen et al. - 2016 - Cubical Type Theory a constructive interpretation.pdf;/Users/doisinkidney/Zotero/storage/V8XZUFR6/1611.html}
}

@inproceedings{cheng_functional_2018,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Functional {{Pearl}}: {{Folding Polynomials}} of {{Polynomials}}},
  isbn = {978-3-319-90685-0 978-3-319-90686-7},
  shorttitle = {Functional {{Pearl}}},
  doi = {10.1007/978-3-319-90686-7_5},
  abstract = {Polynomials are a central concept to many branches in mathematics and computer science. In particular, manipulation of polynomial expressions can be used to model a wide variety of computation. In this paper, we consider a simple recursive construction of multivariate polynomials over a base ring such as the integers or a (finite) field. We show that this construction allows inductive implementation of polynomial operations such as arithmetic, evaluation, substitution, etc. Furthermore, we can transform a polynomial expression into in a sequence of arithmetic expressions in the base ring and prove the correctness of this transformation in Agda. Combined with our recursive construction, this allows for compiling polynomial expressions over a tower of extension fields into scalar expressions over the ground field, for example. Such a technique is not only interesting in its own right but also finds plentiful application in research areas such as cryptography.},
  language = {en},
  urldate = {2018-08-02},
  booktitle = {Functional and {{Logic Programming}}},
  publisher = {{Springer, Cham}},
  url = {https://link.springer.com/chapter/10.1007/978-3-319-90686-7_5},
  author = {Cheng, Chen-Mou and Hsu, Ruey-Lin and Mu, Shin-Cheng},
  month = may,
  year = {2018},
  pages = {68-83},
  file = {/Users/doisinkidney/Zotero/storage/D8GT5G46/Cheng et al. - 2018 - Functional Pearl Folding Polynomials of Polynomia.pdf;/Users/doisinkidney/Zotero/storage/CYZ5CHC3/978-3-319-90686-7_5.html}
}

@inproceedings{jeffrey_causality_2013,
  title = {Causality for Free!: Parametricity Implies Causality for Functional Reactive Programs},
  isbn = {978-1-4503-1860-0},
  shorttitle = {Causality for Free!},
  doi = {10.1145/2428116.2428127},
  abstract = {Functional Reactive Programming (FRP) is a model of reactive systems in which signals are time-dependent values, and signal functions are functions between signals. Signal functions are required to be causal, in that output behaviour at time t is only allowed to depend on input behaviour up to time t. In order to enforce causality, many FRP libraries are arrowized, in that they provide combinators for building signal functions, rather than allowing users to write functions directly. In this paper, we provide a definition of deep causality (which coincides with the usual definition on signals of base type, but differs on nested signals). We show that FRP types can be interpreted in System F{$\omega$} extended with a kind of time, and show that in this interpretation, a ``theorems for free'' argument shows that parametric functions are deep causal. Since all System F{$\omega$} functions are parametric, this implies that all implementable functions are deep causal. This model is the formal basis of the agda-frp-js FRP library for the dependently typed programming language Agda, which compiles to JavaScript and executes in the browser. Assuming parametricity of Agda, this allows reactive programs to be written as regular functions over signals, without sacrificing causality. All results in this paper have been mechanically verified in Agda.},
  language = {en},
  urldate = {2018-08-02},
  publisher = {{ACM Press}},
  url = {http://dl.acm.org/citation.cfm?doid=2428116.2428127},
  author = {Jeffrey, Alan},
  year = {2013},
  pages = {57},
  file = {/Users/doisinkidney/Zotero/storage/HH8UXHSG/Jeffrey - 2013 - Causality for free! parametricity implies causali.pdf}
}

@inproceedings{danielsson_total_2010-1,
  address = {New York, NY, USA},
  series = {{{ICFP}} '10},
  title = {Total {{Parser Combinators}}},
  isbn = {978-1-60558-794-3},
  doi = {10.1145/1863543.1863585},
  abstract = {A monadic parser combinator library which guarantees termination of parsing, while still allowing many forms of left recursion, is described. The library's interface is similar to those of many other parser combinator libraries, with two important differences: one is that the interface clearly specifies which parts of the constructed parsers may be infinite, and which parts have to be finite, using dependent types and a combination of induction and coinduction; and the other is that the parser type is unusually informative. The library comes with a formal semantics, using which it is proved that the parser combinators are as expressive as possible. The implementation is supported by a machine-checked correctness proof.},
  urldate = {2018-08-03},
  booktitle = {Proceedings of the 15th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  publisher = {{ACM}},
  url = {http://www.cse.chalmers.se/~nad/publications/danielsson-parser-combinators.html},
  author = {Danielsson, Nils Anders},
  year = {2010},
  keywords = {dependent types,mixed induction and coinduction,parser combinators,productivity,termination},
  pages = {285--296},
  file = {/Users/doisinkidney/Zotero/storage/HAZDEJPP/danielsson-parser-combinators.pdf;/Users/doisinkidney/Zotero/storage/TETBD5MS/Danielsson - 2010 - Total Parser Combinators.pdf}
}

@inproceedings{gregoire_proving_2005,
  address = {Berlin, Heidelberg},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Proving {{Equalities}} in a {{Commutative Ring Done Right}} in {{Coq}}},
  volume = {3603},
  isbn = {978-3-540-28372-0 978-3-540-31820-0},
  doi = {10.1007/11541868_7},
  abstract = {We present a new implementation of a reflexive tactic which solves equalities in a ring structure inside the Coq system. The efficiency is improved to a point that we can now prove equalities that were previously beyond reach. A special care has been taken to implement efficient algorithms while keeping the complexity of the correctness proofs low. This leads to a single tool, with a single implementation, which can be addressed for a ring or for a semi-ring, abstract or not, using the Leibniz equality or a setoid equality. This example shows that such reflective methods can be effectively used in symbolic computation.},
  language = {en},
  urldate = {2018-08-03},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/11541868_7},
  author = {Gr\'egoire, Benjamin and Mahboubi, Assia},
  year = {2005},
  pages = {98-113},
  file = {/Users/doisinkidney/Zotero/storage/GTPFHWSU/Grégoire and Mahboubi - 2005 - Proving Equalities in a Commutative Ring Done Righ.pdf;/Users/doisinkidney/Zotero/storage/KK2HQB4Z/11541868_7.html}
}

@article{main_free_1985,
  title = {Free Semiring-Representations and Nondeterminism},
  volume = {30},
  issn = {0022-0000},
  doi = {10.1016/0022-0000(85)90049-2},
  abstract = {Semirings provide a simple abstract model of the syntax for a nondeterministic programming language. Each element of a semiring is a nondeterministic program segment, and the semiring operations (+ and {$\uplus$}) correspond to nondeterministic or and program composition. This is analogous to using an algebraic theory for the abstract syntax of a deterministic language. In the case of algebraic theories, an algebra provides the semantics, and free algebras (which always exist) are particularly important. For a semiring, semantics is provided by a representation as a system of relations. This paper examines the question of when free representations exist. Unlike free algebras, free representations do not always exist. It is shown that a semiring has free representations generated by arbitrary sets of variables iff it has a free representation generated by a single variable. Examples of semirings are given that do not have free representations. However, for an important class of semirings, free representations are always available. This class consists of semirings which arise when nondeterminism is freely added to a deterministic programming language.},
  number = {3},
  urldate = {2018-08-03},
  journal = {Journal of Computer and System Sciences},
  url = {http://www.sciencedirect.com/science/article/pii/0022000085900492},
  author = {Main, Michael G. and Benson, David B.},
  month = jun,
  year = {1985},
  pages = {318-328},
  file = {/Users/doisinkidney/Zotero/storage/B2SDYE45/Main and Benson - 1985 - Free semiring-representations and nondeterminism.pdf;/Users/doisinkidney/Zotero/storage/4RXL7GYM/0022000085900492.html}
}

@inproceedings{oconnor_applications_2016,
  address = {New York, NY, USA},
  series = {{{TyDe}} 2016},
  title = {Applications of {{Applicative Proof Search}}},
  isbn = {978-1-4503-4435-7},
  doi = {10.1145/2976022.2976030},
  abstract = {In this paper, we develop a library of typed proof search procedures, and demonstrate their remarkable utility as a mechanism for proof-search and automation. We describe a framework for describing proof-search procedures in Agda, with a library of tactical combinators based on applicative functors. This framework is very general, so we demonstrate the approach with two common applications from the field of software verification: a library for property-based testing in the style of SmallCheck, and the embedding of a basic model checker inside our framework, which we use to verify the correctness of common concurrency algorithms.},
  urldate = {2018-08-03},
  booktitle = {Proceedings of the 1st {{International Workshop}} on {{Type}}-{{Driven Development}}},
  publisher = {{ACM}},
  url = {http://doi.acm.org/10.1145/2976022.2976030},
  author = {O'Connor, Liam},
  year = {2016},
  keywords = {Agda,automation,concurrency,critical section,model checking,proof,properties,testing},
  pages = {43--55},
  file = {/Users/doisinkidney/Zotero/storage/L9AIHCP8/O'Connor - 2016 - Applications of Applicative Proof Search.pdf}
}

@article{bernardy_certified_2016,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1601.07724},
  primaryClass = {cs},
  title = {Certified {{Context}}-{{Free Parsing}}: {{A}} Formalisation of {{Valiant}}'s {{Algorithm}} in {{Agda}}},
  shorttitle = {Certified {{Context}}-{{Free Parsing}}},
  abstract = {Valiant (1975) has developed an algorithm for recognition of context free languages. As of today, it remains the algorithm with the best asymptotic complexity for this purpose. In this paper, we present an algebraic specification, implementation, and proof of correctness of a generalisation of Valiant's algorithm. The generalisation can be used for recognition, parsing or generic calculation of the transitive closure of upper triangular matrices. The proof is certified by the Agda proof assistant. The certification is representative of state-of-the-art methods for specification and proofs in proof assistants based on type-theory. As such, this paper can be read as a tutorial for the Agda system.},
  urldate = {2018-08-04},
  journal = {arXiv:1601.07724 [cs]},
  url = {http://arxiv.org/abs/1601.07724},
  author = {Bernardy, Jean-Philippe and Jansson, Patrik},
  month = jan,
  year = {2016},
  keywords = {Computer Science - Logic in Computer Science,F.4.1,F.4.2},
  file = {/Users/doisinkidney/Zotero/storage/53P9TW38/Bernardy and Jansson - 2016 - Certified Context-Free Parsing A formalisation of.pdf;/Users/doisinkidney/Zotero/storage/SJE2AMQ7/Bernardy and Jansson - 2016 - Certified Context-Free Parsing A formalisation of.pdf;/Users/doisinkidney/Zotero/storage/3MG2VFP7/1601.html;/Users/doisinkidney/Zotero/storage/8D9MHWLY/1601.html}
}

@article{gumundsson_formalizing_2017,
  title = {Formalizing the Translation Method in {{Agda}}},
  abstract = {If \dbend\dbend\dbend\dbend\dbend\dbend{} and \dbend\dbend\dbend\dbend\dbend\dbend{} are sets of combinatorial objects, the translation method, introduced by Wood and Zeilberger (2009), allows one to turn an algebraic proof of the identity |\dbend\dbend\dbend\dbend\dbend\dbend{} | = |\dbend\dbend\dbend\dbend\dbend\dbend{}| into a bijection between \dbend\dbend\dbend\dbend\dbend\dbend{} and \dbend\dbend\dbend\dbend\dbend\dbend. We give a formalized implementation of the translation method in the programming language Agda. In contrast to the implementation previously given by Wood and Zeilberger, the bijections produced by our implementation are formally verified, making our implementation more robust. We also take advantage of the fact that Agda is a proof assistant, allowing users of our implementation to use the existing facilities provided by Agda for developing proofs. In particular, converting an existing algebraic proof for use in our implementation is often straightforward.},
  language = {en},
  author = {Gu\dh{}mundsson, Bjarki \'Ag\'ust},
  month = jun,
  year = {2017},
  pages = {112},
  file = {/Users/doisinkidney/Zotero/storage/IHJEUPEG/Guðmundsson - Formalizing the translation method in Agda.pdf}
}

@article{johnson_sparse_1974,
  title = {Sparse Polynomial Arithmetic},
  volume = {8},
  issn = {01635824},
  doi = {10.1145/1086837.1086847},
  abstract = {Sparse polynomial representations are used in a number of algebraic manipulation systems, including Aitran. This paper discusses the arithmetic operations with sparsely represented polynomials; we give particular attention to multiplication and division\textbullet{} We give new algorithms for multiplying two polynomials, with n and m terms, in time mnlogm; these algorithms have the property that, in the usual univariate dense case, the algorithm is bounded by ran. Division algorithms are discussed which run in comparable time.},
  language = {en},
  number = {3},
  urldate = {2018-08-07},
  journal = {ACM SIGSAM Bulletin},
  url = {http://portal.acm.org/citation.cfm?doid=1086837.1086847},
  author = {Johnson, Stephen C.},
  month = aug,
  year = {1974},
  pages = {63-71},
  file = {/Users/doisinkidney/Zotero/storage/N574968I/Johnson - 1974 - Sparse polynomial arithmetic.pdf}
}

@book{danielsson_functional_2007,
  address = {G\"oteborg},
  series = {Doktorsavhandlingar Vid {{Chalmers Tekniska H\"ogskola}}},
  title = {Functional Program Correctness through Types},
  isbn = {978-91-7385-034-6},
  abstract = {This thesis addresses the problem of avoiding errors in functional programs. The thesis has three parts, discussing different aspects of program correctness, with the unifying theme that types are an integral part of the methods used to establish correctness.},
  language = {en},
  number = {N.S., 2715},
  publisher = {{Chalmers Univ. of Technology}},
  author = {Danielsson, Nils Anders},
  year = {2007},
  file = {/Users/doisinkidney/Zotero/storage/9LF78LD6/Danielsson - 2007 - Functional program correctness through types.pdf},
  note = {OCLC: 551639193}
}

@article{meshveliani_dependent_2017,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1709.01810},
  primaryClass = {cs},
  title = {On Dependent Types and Intuitionism in Programming Mathematics},
  abstract = {It is discussed a practical possibility of a provable programming of mathematics basing on intuitionism and the dependent types feature of a programming language.The principles of constructive mathematics and provable programming are illustrated with examples taken from algebra. The discourse follows the experience in designing in Agda a computer algebra library DoCon-A, which deals with generic algebraic structures and also provides the needed machine-checked proofs. This paper is a revised translation of a certain paper published in Russian in 2014.},
  urldate = {2018-08-07},
  journal = {arXiv:1709.01810 [cs]},
  url = {http://arxiv.org/abs/1709.01810},
  author = {Meshveliani, Sergei D.},
  month = sep,
  year = {2017},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/Users/doisinkidney/Zotero/storage/B6BMMMVS/Meshveliani - 2017 - On dependent types and intuitionism in programming.pdf;/Users/doisinkidney/Zotero/storage/H6SGLFYG/Meshveliani - 2017 - On dependent types and intuitionism in programming.pdf;/Users/doisinkidney/Zotero/storage/CMU37WUY/1709.html;/Users/doisinkidney/Zotero/storage/HFMYLAK9/1709.html}
}

@techreport{meshveliani_dependent_2013,
  address = {Pereslavl-Zalessky, Russia},
  title = {Dependent {{Types}} for an {{Adequate Programming}} of {{Algebra}}},
  abstract = {This research compares the author's experience in programming algebra in Haskell and in Agda (currently the former experience is large, and the latter is small). There are discussed certain hopes and doubts related to the dependently typed and verified programming of symbolic computation. This concerns the 1) author's experience history, 2) algebraic class hierarchy design, 3) proof cost overhead in evaluation and in coding, 4) other subjects. Various examples are considered.},
  language = {en},
  institution = {{Program Systems Institute of Russian Academy of sciences}},
  url = {http://ceur-ws.org/Vol-1010/paper-05.pdf},
  author = {Meshveliani, Sergei D},
  year = {2013},
  pages = {15},
  file = {/Users/doisinkidney/Zotero/storage/SESGEH6A/Meshveliani - Dependent Types for an Adequate Programming of Alg.pdf}
}

@phdthesis{zalakain_evidence-providing_2017,
  address = {Strathclyde},
  type = {Submitted for the {{Degree}} of {{B}}.{{Sc}}. in {{Computer Science}}},
  title = {Evidence-Providing Problem Solvers in {{Agda}}},
  abstract = {The Curry-Howard correspondence draws a direct link between logic and computation: propositions are modelled as types and proofs as programs; to prove a proposition is to con- struct a program inhabiting its corresponding type. Several computer-assisted theorem provers have been developed under this idea. They are not just used to verify human reasoning: they are also often capable of generating proofs automatically.
This project considers the development of such automated theorem provers in Agda, a de- pendently typed programming language. As a warm-up, I present a verified solver for equations on monoids. Then, I comment on the solver for commutative rings included in Agda's stan- dard library. Finally, I develop a verified decision procedure for Presburger arithmetic \textemdash{} a decidable first-order predicate logic.},
  language = {en},
  urldate = {2018-03-08},
  school = {University of Strathclyde},
  url = {https://umazalakain.info/static/report.pdf},
  author = {Zalakain, Uma},
  year = {2017},
  file = {/Users/doisinkidney/Zotero/storage/HK3IVT32/report.pdf}
}

@article{fu_dependently_2018,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1806.05230},
  primaryClass = {cs},
  title = {Dependently {{Typed Folds}} for {{Nested Data Types}}},
  abstract = {We present an approach to develop folds for nested data types using dependent types. We call such folds \$\textbackslash{}textit\{dependently typed folds\}\$, they have the following properties. (1) Dependently typed folds are defined by well-founded recursion and they can be defined in a total dependently typed language. (2) Dependently typed folds do not depend on maps, map functions and many terminating functions can be defined using dependently typed folds. (3) The induction principles for nested data types follow from the definitions of dependently typed folds and the programs defined by dependently typed folds can be formally verified. (4) Dependently typed folds exist for any nested data types and they can be specialized to the traditional \$\textbackslash{}textit\{higher-order folds\}\$. Using various of examples, we show how to program and reason about dependently typed folds. We also show how to obtain dependently typed folds in general and how to specialize them to the corresponding higher-order folds.},
  urldate = {2018-08-15},
  journal = {arXiv:1806.05230 [cs]},
  url = {http://arxiv.org/abs/1806.05230},
  author = {Fu, Peng and Selinger, Peter},
  month = jun,
  year = {2018},
  keywords = {Computer Science - Programming Languages,Computer Science - Logic in Computer Science},
  file = {/Users/doisinkidney/Zotero/storage/3VTZEW3W/Fu and Selinger - 2018 - Dependently Typed Folds for Nested Data Types.pdf;/Users/doisinkidney/Zotero/storage/9I9EVTSR/Fu and Selinger - 2018 - Dependently Typed Folds for Nested Data Types.pdf;/Users/doisinkidney/Zotero/storage/5PE5R4LH/1806.html;/Users/doisinkidney/Zotero/storage/WEBYY88G/1806.html}
}

@article{dowek_theorem_2003,
  title = {Theorem {{Proving Modulo}}},
  volume = {31},
  issn = {0168-7433, 1573-0670},
  doi = {10.1023/A:1027357912519},
  abstract = {Deduction modulo is a way to remove computational arguments from proofs by reasoning modulo a congruence on propositions. Such a technique, issued from automated theorem proving, is of general interest because it permits one to separate computations and deductions in a clean way. The first contribution of this paper is to define a sequent calculus modulo that gives a proof-theoretic account of the combination of computations and deductions. The congruence on propositions is handled through rewrite rules and equational axioms. Rewrite rules apply to terms but also directly to atomic propositions.The second contribution is to give a complete proof search method, called extended narrowing and resolution (ENAR), for theorem proving modulo such congruences. The completeness of this method is proved with respect to provability in sequent calculus modulo.An important application is that higher-order logic can be presented as a theory in deduction modulo. Applying the ENAR method to this presentation of higher-order logic subsumes full higher-order resolution.},
  language = {en},
  number = {1},
  urldate = {2018-08-16},
  journal = {Journal of Automated Reasoning},
  url = {https://link.springer.com/article/10.1023/A:1027357912519},
  author = {Dowek, Gilles and Hardin, Th\'er\`ese and Kirchner, Claude},
  month = sep,
  year = {2003},
  pages = {33-72},
  file = {/Users/doisinkidney/Zotero/storage/3FJ82L3C/10.html}
}

@incollection{geuvers_automatically_2017,
  address = {Cham},
  title = {Automatically {{Proving Equivalence}} by {{Type}}-{{Safe Reflection}}},
  volume = {10383},
  isbn = {978-3-319-62074-9 978-3-319-62075-6},
  abstract = {One difficulty with reasoning and programming with dependent types is that proof obligations arise naturally once programs become even moderately sized. For example, implementing an adder for binary numbers indexed over their natural number equivalents naturally leads to proof obligations for equalities of expressions over natural numbers. The need for these equality proofs comes, in intensional type theories, from the fact that the propositional equality enables us to prove as equal terms that are not judgementally equal, which means that the typechecker can't always obtain equalities by reduction. As far as possible, we would like to solve such proof obligations automatically. In this paper, we show one way to automate these proofs by reflection in the dependently typed programming language Idris. We show how defining reflected terms indexed by the original Idris expression allows us to construct and manipulate proofs. We build a hierarchy of tactics for proving equivalences in semigroups, monoids, commutative monoids, groups, commutative groups, semi-rings and rings. We also show how each tactic reuses those from simpler structures, thus avoiding duplication of code and proofs.},
  language = {en},
  urldate = {2018-08-16},
  booktitle = {Intelligent {{Computer Mathematics}}},
  publisher = {{Springer International Publishing}},
  url = {http://link.springer.com/10.1007/978-3-319-62075-6_4},
  author = {Slama, Franck and Brady, Edwin},
  editor = {Geuvers, Herman and England, Matthew and Hasan, Osman and Rabe, Florian and Teschke, Olaf},
  year = {2017},
  pages = {40-55},
  file = {/Users/doisinkidney/Zotero/storage/PDB7LZPW/Slama and Brady - 2017 - Automatically Proving Equivalence by Type-Safe Ref.pdf},
  doi = {10.1007/978-3-319-62075-6_4}
}

@article{mu_algebra_2009,
  title = {Algebra of Programming in {{Agda}}: {{Dependent}} Types for Relational Program Derivation},
  volume = {19},
  issn = {1469-7653, 0956-7968},
  shorttitle = {Algebra of Programming in {{Agda}}},
  doi = {10.1017/S0956796809007345},
  abstract = {Relational program derivation is the technique of stepwise refining a relational specification to a program by algebraic rules. The program thus obtained is correct by construction. Meanwhile, dependent type theory is rich enough to express various correctness properties to be verified by the type checker. We have developed a library, AoPA (Algebra of Programming in Agda), to encode relational derivations in the dependently typed programming language Agda. A program is coupled with an algebraic derivation whose correctness is guaranteed by the type system. Two non-trivial examples are presented: an optimisation problem and a derivation of quicksort in which well-founded recursion is used to model terminating hylomorphisms in a language with inductive types.},
  language = {en},
  number = {5},
  urldate = {2018-08-17},
  journal = {Journal of Functional Programming},
  url = {https://github.com/scmu/aopa},
  author = {Mu, Shin-Cheng and Ko, Hsiang-Shang and Jansson, Patrik},
  month = sep,
  year = {2009},
  pages = {545-579},
  file = {/Users/doisinkidney/Zotero/storage/D7UWNTJ4/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/D8FNYT4X/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/5D6VGKJQ/ACA0C08F29621A892FB0C0B745254D15.html}
}

@misc{mu_aopa_2018,
  title = {Aopa: {{Algebra}} of {{Programming}} in {{Agda}}: {{Dependent Types}} for {{Relational Program Derivation}}},
  shorttitle = {Aopa},
  urldate = {2018-08-17},
  url = {https://github.com/scmu/aopa},
  author = {Mu, Shin-Cheng},
  month = aug,
  year = {2018}
}

@article{mu_programming_2012,
  series = {12th {{International Conference}} on {{Relational}} and {{Algebraic Methods}} in {{Computer Science}} ({{RAMiCS}} 2011)},
  title = {Programming from {{Galois}} Connections},
  volume = {81},
  issn = {1567-8326},
  doi = {10.1016/j.jlap.2012.05.003},
  abstract = {Problem statements often resort to superlatives such as in e.g. ``\ldots{} the smallest such number'', ``\ldots{} the best approximation'', ``\ldots{} the longest such list'' which lead to specifications made of two parts: one defining a broad class of solutions (the easy part) and the other requesting one particular such solution, optimal in some sense (the hard part). This article introduces a binary relational combinator which mirrors this linguistic structure and exploits its potential for calculating programs by optimization. This applies in particular to specifications written in the form of Galois connections, in which one of the adjoints delivers the optimal solution. The framework encompasses re-factoring of results previously developed by Bird and de Moor for greedy and dynamic programming, in a way which makes them less technically involved and therefore easier to understand and play with.},
  number = {6},
  urldate = {2018-08-18},
  journal = {The Journal of Logic and Algebraic Programming},
  url = {http://www.sciencedirect.com/science/article/pii/S1567832612000525},
  author = {Mu, Shin-Cheng and Oliveira, Jos\'e Nuno},
  month = aug,
  year = {2012},
  keywords = {Program derivation,Algebra of programming,Galois connection},
  pages = {680-704},
  file = {/Users/doisinkidney/Zotero/storage/9CVSDF8W/Mua and Oliveirab - Programming from Galois Connections.pdf;/Users/doisinkidney/Zotero/storage/BSN7ZWTQ/Mua and Oliveirab - Programming from Galois Connections.pdf;/Users/doisinkidney/Zotero/storage/C3VP3FGT/Mua and Oliveirab - Programming from Galois Connections.pdf;/Users/doisinkidney/Zotero/storage/DH8S72BQ/Mu and Oliveira - 2012 - Programming from Galois connections.pdf;/Users/doisinkidney/Zotero/storage/KP24NNPC/Mua and Oliveirab - Programming from Galois Connections.pdf;/Users/doisinkidney/Zotero/storage/TMNESM34/Mua and Oliveirab - Programming from Galois Connections.pdf;/Users/doisinkidney/Zotero/storage/VJG783ZD/Mu and Oliveira - 2012 - Programming from Galois connections.pdf;/Users/doisinkidney/Zotero/storage/3FES9GDK/S1567832612000525.html;/Users/doisinkidney/Zotero/storage/5PW4E5QS/24608.html;/Users/doisinkidney/Zotero/storage/DFIVUJSJ/bwmeta1.element.html;/Users/doisinkidney/Zotero/storage/F5RRMDCZ/S1567832612000525.html;/Users/doisinkidney/Zotero/storage/FMY882Y9/S1567832612000525.html}
}

@article{chiang_formal_2016,
  series = {Articles Dedicated to {{Prof}}. {{J}}. {{N}}. {{Oliveira}} on the Occasion of His 60th Birthday},
  title = {Formal Derivation of {{Greedy}} Algorithms from Relational Specifications: {{A}} Tutorial},
  volume = {85},
  issn = {2352-2208},
  shorttitle = {Formal Derivation of {{Greedy}} Algorithms from Relational Specifications},
  doi = {10.1016/j.jlamp.2015.12.003},
  abstract = {Many programming tasks can be specified as optimisation problems in which a relation is used to generate all possible solutions, from which we wish to choose an optimal one. A relational operator ``shrink'', developed by Jos\'e N. Oliveira, is particularly suitable for constructing greedy algorithms from such specifications. Meanwhile, it has become standard in many sub-fields in programming language that proofs must be machine-verified. This tutorial leads the readers through the development of algebraic derivations of three greedy algorithms, one fold-based and two unfold-based, using AoPA, a library designed for machine-verified relational program calculation.},
  number = {5, Part 2},
  urldate = {2018-08-18},
  journal = {Journal of Logical and Algebraic Methods in Programming},
  url = {http://www.sciencedirect.com/science/article/pii/S2352220815001492},
  author = {Chiang, Yu-Hsi and Mu, Shin-Cheng},
  month = aug,
  year = {2016},
  keywords = {Program derivation,Algebra of programming,Galois connection,Dependent type,Machine-aided theorem proving},
  pages = {879-905},
  file = {/Users/doisinkidney/Zotero/storage/ELC6ARTN/1-s2.0-S2352220815001492-main.pdf;/Users/doisinkidney/Zotero/storage/KWCCV77B/Chiang and Mu - 2016 - Formal derivation of Greedy algorithms from relati.pdf;/Users/doisinkidney/Zotero/storage/8JPBXYJD/S2352220815001492.html;/Users/doisinkidney/Zotero/storage/VD8GZPYV/S2352220815001492.html}
}

@inproceedings{audebaud_algebra_2008,
  address = {Berlin, Heidelberg},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Algebra of {{Programming Using Dependent Types}}},
  volume = {5133},
  isbn = {978-3-540-70593-2 978-3-540-70594-9},
  doi = {10.1007/978-3-540-70594-9_15},
  abstract = {Dependent type theory is rich enough to express that a program satisfies an input/output relational specification, but it could be hard to construct the proof term. On the other hand, squiggolists know very well how to show that one relation is included in another by algebraic reasoning. We demonstrate how to encode functional and relational derivations in a dependently typed programming language. A program is coupled with an algebraic derivation from a specification, whose correctness is guaranteed by the type system.},
  language = {en},
  urldate = {2018-08-18},
  booktitle = {Mathematics of {{Program Construction}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-540-70594-9_15},
  author = {Mu, Shin-Cheng and Ko, Hsiang-Shang and Jansson, Patrik},
  editor = {Audebaud, Philippe and {Paulin-Mohring}, Christine},
  year = {2008},
  pages = {268-283},
  file = {/Users/doisinkidney/Zotero/storage/ASKFWFTU/Mu et al. - Algebra of Programming Using Dependent Types.pdf;/Users/doisinkidney/Zotero/storage/5VKT7DWK/10.html}
}

@article{gibbons_third_1996-1,
  title = {The {{Third Homomorphism Theorem}}},
  volume = {6},
  abstract = {The Third Homomorphism Theorem is a folk theorem of the constructive algorithmics community. It states that a function on lists that can be computed both from left to right and from right to left is necessarily a list homomorphism - it can be computed according to any parenthesization of the list. We formalize and prove the theorem, and describe two practical applications: to fast parallel algorithms for language recognition problems and for downwards accumulations on trees.},
  language = {en-gb},
  number = {4},
  urldate = {2018-08-18},
  journal = {Journal of Functional Programming},
  url = {http://www.cs.ox.ac.uk/publications/publication2365-abstract.html},
  author = {Gibbons, Jeremy},
  year = {1996},
  file = {/Users/doisinkidney/Zotero/storage/8FS437A6/Gibbons - 1995 - The Third Homomorphism Theorem.pdf;/Users/doisinkidney/Zotero/storage/JRISL6I9/publication2365-abstract.html;/Users/doisinkidney/Zotero/storage/VX8PP8EU/summary.html}
}

@book{bird_algebra_1997,
  address = {London ; New York},
  series = {Prentice-{{Hall}} International Series in Computer Science},
  title = {Algebra of Programming},
  isbn = {978-0-13-507245-5},
  lccn = {QA76.6 .B567 1997},
  publisher = {{Prentice Hall}},
  author = {Bird, Richard and de Moor, Oege},
  year = {1997},
  keywords = {Computer algorithms,Computer programming,Programming (Mathematics)},
  file = {/Users/doisinkidney/Zotero/storage/X3N7TDKM/The-Algebra-of-Programming.pdf}
}

@article{feo_fast_nodate,
  title = {Fast {{Algorithms}} for {{Towers}} of {{Finite Fields}} and {{Isogenies}}},
  language = {en},
  author = {Feo, Luca De},
  pages = {191},
  file = {/Users/doisinkidney/Zotero/storage/AHVPAL6S/Feo - Fast Algorithms for Towers of Finite Fields and Is.pdf}
}

@misc{gibbons_horners_2011,
  title = {Horner's {{Rule}}},
  abstract = {This post is about my all-time favourite calculation, of a linear-time algorithm for the maximum segment sum problem, based on Horner's Rule. The problem was popularized in Jon Bentley'\ldots{}},
  language = {en},
  urldate = {2018-08-19},
  journal = {Patterns in Functional Programming},
  url = {https://patternsinfp.wordpress.com/2011/05/05/horners-rule/},
  author = {Gibbons, Jeremy},
  month = may,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/WRD6S87U/horners-rule.html}
}

@misc{gibbons_distributivity_2011,
  title = {Distributivity in {{Horner}}'s {{Rule}}},
  abstract = {This is a continuation of my previous post on Horner's Rule, and in particular, of the discussion there about distributivity in the datatype-generic version of the Maximum Segment Sum problem\ldots{}},
  language = {en},
  urldate = {2018-08-19},
  journal = {Patterns in Functional Programming},
  url = {https://patternsinfp.wordpress.com/2011/05/17/distributivity-in-horners-rule/},
  author = {Gibbons, Jeremy},
  month = may,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/QSZZFG3P/distributivity-in-horners-rule.html}
}

@article{mcbride_view_2004,
  title = {The {{View}} from the {{Left}}},
  volume = {14},
  issn = {0956-7968},
  doi = {10.1017/S0956796803004829},
  abstract = {Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways. First, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991). Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful. Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler's (1987) notion of `view'. The programmer wishing to introduce a new view of a type \$\textbackslash{}mathit\{T\}\$, and exploit it directly in pattern matching, may do so via a standard programming idiom. The type theorist, looking through the Curry\textendash{}Howard lens, may see this as proving a theorem, one which establishes the validity of a new induction principle for \$\textbackslash{}mathit\{T\}\$. We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is ipso facto a proof that typechecking is decidable.},
  number = {1},
  urldate = {2018-08-21},
  journal = {J. Funct. Program.},
  url = {http://strictlypositive.org/vfl.pdf},
  author = {McBride, Conor and McKinna, James},
  month = jan,
  year = {2004},
  pages = {69--111},
  file = {/Users/doisinkidney/Zotero/storage/JPF2T4CC/McBride and McKinna - 2004 - The View from the Left.pdf}
}

@article{cockx_pattern_nodate,
  title = {Pattern {{Matching Without K}}},
  abstract = {Dependent pattern matching is an intuitive way to write programs and proofs in dependently typed languages. It is reminiscent of both pattern matching in functional languages and case analysis in on-paper mathematics. However, in general it is incompatible with new type theories such as homotopy type theory (HoTT). As a consequence, proofs in such theories are typically harder to write and to understand. The source of this incompatibility is the reliance of dependent pattern matching on the so-called K axiom \textendash{} also known as the uniqueness of identity proofs \textendash{} which is inadmissible in HoTT. The Agda language supports an experimental criterion to detect definitions by pattern matching that make use of the K axiom, but so far it lacked a formal correctness proof. In this paper, we propose a new criterion for dependent pattern matching without K, and prove it correct by a translation to eliminators in the style of Goguen et al. (2006). Our criterion both allows more good definitions than existing proposals, and solves a previously undetected problem in the criterion offered by Agda. It has been implemented in Agda and is the first to be supported by a formal proof. Thus it brings the benefits of dependent pattern matching to contexts where we cannot assume K, such as HoTT. It also points the way to new forms of dependent pattern matching, for example on higher inductive types.},
  language = {en},
  author = {Cockx, Jesper and Devriese, Dominique and Piessens, Frank},
  pages = {12},
  file = {/Users/doisinkidney/Zotero/storage/DMX39U5W/Cockx et al. - Pattern Matching Without K.pdf}
}

@inproceedings{altenkirch_observational_2007,
  address = {Freiburg, Germany},
  title = {Observational Equality, Now!},
  isbn = {978-1-59593-677-6},
  doi = {10.1145/1292597.1292608},
  language = {en},
  urldate = {2018-08-22},
  booktitle = {Proceedings of the 2007 Workshop on {{Programming}} Languages Meets Program Verification  - {{PLPV}} '07},
  publisher = {{ACM Press}},
  url = {http://portal.acm.org/citation.cfm?doid=1292597.1292608},
  author = {Altenkirch, Thorsten and McBride, Conor and Swierstra, Wouter},
  year = {2007},
  pages = {57},
  file = {/Users/doisinkidney/Zotero/storage/Q7Z2XQGX/Altenkirch et al. - 2007 - Observational equality, now!.pdf}
}

@article{abel_programming_nodate,
  title = {Programming {{Infinite Structures}} by {{Observations}}},
  abstract = {Inductive datatypes provide mechanisms to define finite data such as finite lists and trees via constructors and allow programmers to analyze and manipulate finite data via pattern matching. In this paper, we develop a dual approach for working with infinite data structures such as streams. Infinite data inhabits coinductive datatypes which denote greatest fixpoints. Unlike finite data which is defined by constructors we define infinite data by observations. Dual to pattern matching, a tool for analyzing finite data, we develop the concept of copattern matching, which allows us to synthesize infinite data. This leads to a symmetric language design where pattern matching on finite and infinite data can be mixed.},
  language = {en},
  author = {Abel, Andreas and Pientka, Brigitte and Thibodeau, David and Setzer, Anton},
  pages = {13},
  file = {/Users/doisinkidney/Zotero/storage/ZCY9V457/Abel et al. - Programming Inﬁnite Structures by Observations.pdf}
}

@inproceedings{firsov_certified_2013,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Certified {{Parsing}} of {{Regular Languages}}},
  isbn = {978-3-319-03545-1},
  abstract = {We report on a certified parser generator for regular languages using the Agda programming language. Specifically, we programmed a transformation of regular expressions into a Boolean-matrix based representation of nondeterministic finite automata (NFAs). And we proved (in Agda) that a string matches a regular expression if and only if the NFA accepts it. The proof of the if-part is effectively a function turning acceptance of a string into a parse tree while the only-if part gives a function turning rejection into a proof of impossibility of a parse tree.},
  language = {en},
  booktitle = {Certified {{Programs}} and {{Proofs}}},
  publisher = {{Springer International Publishing}},
  author = {Firsov, Denis and Uustalu, Tarmo},
  editor = {Gonthier, Georges and Norrish, Michael},
  year = {2013},
  keywords = {Incidence Matrix,Parse Tree,Pattern Match,Regular Expression,Regular Language},
  pages = {98-113}
}

@techreport{russino_polynomial_2017,
  title = {Polynomial {{Terms}} and {{Sparse Horner Normal Form}}},
  language = {en},
  url = {http://www.russinoff.com/papers/shnf.pdf},
  author = {Russinoff, David M},
  month = jul,
  year = {2017},
  pages = {8},
  file = {/Users/doisinkidney/Zotero/storage/XGCQCLFR/Russinoﬀ - Polynomial Terms and Sparse Horner Normal Form.pdf}
}

@misc{mcbride_polynomial_2018,
  type = {Tweet},
  title = {A {{Polynomial Testing Principle}}},
  abstract = {A polynomial testing principle gives a machine-checked proof that, under suitably controlled circumstances, in a small but familiar domain, testing can reveal the absence of bugs.},
  language = {en},
  urldate = {2018-08-23},
  journal = {Conor McBride's Twitter Feed},
  url = {https://twitter.com/pigworker/status/1013535783234473984},
  author = {McBride, Conor},
  month = jul,
  year = {2018},
  file = {/Users/doisinkidney/Zotero/storage/DB4NV3DI/1013535783234473984.html}
}

@inproceedings{kiselyov_extensible_2013-2,
  address = {New York, NY, USA},
  series = {Haskell '13},
  title = {Extensible {{Effects}}: {{An Alternative}} to {{Monad Transformers}}},
  isbn = {978-1-4503-2383-3},
  shorttitle = {Extensible {{Effects}}},
  doi = {10.1145/2503778.2503791},
  abstract = {We design and implement a library that solves the long-standing problem of combining effects without imposing restrictions on their interactions (such as static ordering). Effects arise from interactions between a client and an effect handler (interpreter); interactions may vary throughout the program and dynamically adapt to execution conditions. Existing code that relies on monad transformers may be used with our library with minor changes, gaining efficiency over long monad stacks. In addition, our library has greater expressiveness, allowing for practical idioms that are inefficient, cumbersome, or outright impossible with monad transformers. Our alternative to a monad transformer stack is a single monad, for the coroutine-like communication of a client with its handler. Its type reflects possible requests, i.e., possible effects of a computation. To support arbitrary effects and their combinations, requests are values of an extensible union type, which allows adding and, notably, subtracting summands. Extending and, upon handling, shrinking of the union of possible requests is reflected in its type, yielding a type-and-effect system for Haskell. The library is lightweight, generalizing the extensible exception handling to other effects and accurately tracking them in types.},
  language = {en},
  urldate = {2018-08-24},
  booktitle = {Proceedings of the 2013 {{ACM SIGPLAN Symposium}} on {{Haskell}}},
  publisher = {{ACM}},
  url = {http://okmij.org/ftp/Haskell/extensible/},
  author = {Kiselyov, Oleg and Sabry, Amr and Swords, Cameron},
  year = {2013},
  keywords = {Effects,Haskell,coroutine,effect handler,effect interaction,monad,monad transformer,open union,type and effect system},
  pages = {59--70},
  file = {/Users/doisinkidney/Zotero/storage/PDUC9QH6/exteff.pdf;/Users/doisinkidney/Zotero/storage/XTZHSAEH/Kiselyov et al. - 2013 - Extensible Effects An Alternative to Monad Transf.pdf}
}

@misc{meshveliani_docon-provable_2018,
  address = {Pereslavl - Zalessky},
  title = {{{DoCon}}-{{A}} a {{Provable Algebraic Domain Constructor}}},
  urldate = {2018-08-24},
  url = {http://www.botik.ru/pub/local/Mechveliani/docon-A/2.02/},
  author = {Meshveliani, Sergei D.},
  month = apr,
  year = {2018},
  file = {/Users/doisinkidney/Zotero/storage/KJL3PGNM/manual.pdf}
}

@article{coquand_isomorphism_2013,
  title = {Isomorphism Is Equality},
  volume = {24},
  issn = {00193577},
  doi = {10.1016/j.indag.2013.09.002},
  abstract = {The setting of this work is dependent type theory extended with the univalence axiom. We prove that, for a large class of algebraic structures, isomorphic instances of a structure are equal\textemdash{}in fact, isomorphism is in bijective correspondence with equality. The class of structures includes monoids whose underlying types are ``sets'', and also posets where the underlying types are sets and the ordering relations are pointwise ``propositional''. For monoids on sets equality coincides with the usual notion of isomorphism from universal algebra, and for posets of the kind mentioned above equality coincides with order isomorphism.},
  language = {en},
  number = {4},
  urldate = {2018-08-25},
  journal = {Indagationes Mathematicae},
  url = {http://www.cse.chalmers.se/~nad/publications/coquand-danielsson-isomorphism-is-equality.html},
  author = {Coquand, Thierry and Danielsson, Nils Anders},
  month = nov,
  year = {2013},
  pages = {1105-1120},
  file = {/Users/doisinkidney/Zotero/storage/8X25PWGE/Coquand and Danielsson - 2013 - Isomorphism is equality.pdf}
}

@inproceedings{oury_power_2008-1,
  address = {New York, NY, USA},
  series = {{{ICFP}} '08},
  title = {The {{Power}} of {{Pi}}},
  isbn = {978-1-59593-919-7},
  doi = {10.1145/1411204.1411213},
  abstract = {This paper exhibits the power of programming with dependent types by dint of embedding three domain-specific languages: Cryptol, a language for cryptographic protocols; a small data description language; and relational algebra. Each example demonstrates particular design patterns inherent to dependently-typed programming. Documenting these techniques paves the way for further research in domain-specific embedded type systems.},
  urldate = {2018-08-25},
  booktitle = {Proceedings of the 13th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  publisher = {{ACM}},
  url = {http://doi.acm.org/10.1145/1411204.1411213},
  author = {Oury, Nicolas and Swierstra, Wouter},
  year = {2008},
  keywords = {dependent types,domain-specific embedded languages},
  pages = {39--50},
  file = {/Users/doisinkidney/Zotero/storage/44IEPBZG/Oury and Swierstra - 2008 - The Power of Pi.pdf}
}

@article{curtis_calculating_2015,
  title = {Calculating a Linear-Time Solution to the Densest-Segment Problem},
  volume = {25},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S095679681500026X},
  abstract = {The problem of finding a densest segment of a list is similar to the well-known maximum segment sum problem, but its solution is surprisingly challenging. We give a general specification of such problems, and formally develop a linear-time online solution, using a sliding-window style algorithm. The development highlights some elegant properties of densities, involving partitions that are decreasing and all right-skew.},
  language = {en},
  urldate = {2018-08-26},
  journal = {Journal of Functional Programming},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/calculating-a-lineartime-solution-to-the-densestsegment-problem/B7A7F3DB6A6220FB95F819F91BA94DCE},
  author = {Curtis, Sharon and Mu, Shin-Cheng},
  year = {2015/ed},
  file = {/Users/doisinkidney/Zotero/storage/5K72WV57/Curtis and Mu - 2015 - Calculating a linear-time solution to the densest-.pdf;/Users/doisinkidney/Zotero/storage/8LJU85AM/B7A7F3DB6A6220FB95F819F91BA94DCE.html}
}

@phdthesis{lioubartsev_constructing_2016,
  address = {Stockholm, Sweden},
  title = {Constructing a {{Computer Algebra System Capable}} of {{Generating Pedagogical Step}}-by-{{Step Solutions}}},
  abstract = {For the problem of producing pedagogical step-by-step so- lutions to mathematical problems in education, standard methods and algorithms used in construction of computer algebra systems are often not suitable. A method of us- ing rules to manipulate mathematical expressions in small steps is suggested and implemented. The problem of creat- ing a step-by-step solution by choosing which rule to apply and when to do it is redefined as a graph search problem and variations of the A* algorithm are used to solve it. It is all put together into one prototype solver that was evalu- ated in a study. The study was a questionnaire distributed among high school students. The results showed that while the solutions were not as good as human-made ones, they were competent. Further improvements of the method are suggested that would probably lead to better solutions.},
  urldate = {2016-08-26},
  school = {KTH Royal Institue of Technology},
  url = {http://www.diva-portal.se/smash/get/diva2:945222/FULLTEXT01.pdf},
  author = {Lioubartsev, Dmitrij},
  year = {2016},
  file = {/Users/doisinkidney/Zotero/storage/2Z62FSZP/FULLTEXT01.pdf}
}

@article{wood_translation_2009,
  title = {A {{Translation Method}} for {{Finding Combinatorial Bijections}}},
  volume = {13},
  issn = {0219-3094},
  doi = {10.1007/s00026-009-0024-y},
  abstract = {Consider a combinatorial identity that can be proved by induction. In this paper, we describe a general method for translating the inductive proof into a recursive bijection. Furthermore, we will demonstrate that the resulting recursive bijection can often be defined in a direct, non-recursive way. Thus, the translation method often results in a bijective proof of the identity that helps illuminate the underlying combinatorial structures. This paper has two main parts: First, we describe the translation method and the accompanying Maple code; and second, we give a few examples of how the method has been used to discover new bijections.},
  language = {en},
  number = {3},
  urldate = {2018-08-29},
  journal = {Annals of Combinatorics},
  url = {https://doi.org/10.1007/s00026-009-0024-y},
  author = {Wood, Philip Matchett and Zeilberger, Doron},
  month = oct,
  year = {2009},
  keywords = {05A19,bijection,bijective proof,combinatorial identity},
  pages = {383},
  file = {/Users/doisinkidney/Zotero/storage/6UJ9BBPT/Wood and Zeilberger - 2009 - A Translation Method for Finding Combinatorial Bij.pdf}
}

@phdthesis{van_der_walt_reflection_2012,
  type = {Master's {{Thesis}}},
  title = {Reflection in {{Agda}}},
  abstract = {This project explores the recent addition to Agda enabling reflection, in the style of Lisp, MetaML, and Template Haskell. It illustrates several possible applications of reflection that arise in dependently typed programming, and details the limitations of the current implementation of reflection. Examples of type-safe metaprograms are given that illustrate the power of reflection coupled with a dependently typed language. Among other things the limitations inherent in having quote and unquote implemented as keywords are highlighted. The fact that lambda terms are returned without typing information is discussed, and a solution is presented. Also provided is a detailed users' guide to the reflection API and a library of working code examples to illustrate how various common tasks can be performed, along with suggestions for an updated reflection API in a future version of Agda.},
  language = {en},
  urldate = {2018-09-16},
  school = {Universiteit of Utrecht},
  url = {https://dspace.library.uu.nl/handle/1874/256628},
  author = {{van der Walt}, P. D.},
  month = oct,
  year = {2012},
  file = {/Users/doisinkidney/Zotero/storage/X358AMNW/van der Walt - 2012 - Reflection in Agda.pdf;/Users/doisinkidney/Zotero/storage/8ZQY4FCH/256628.html}
}

@inproceedings{lindley_hasochism_2013,
  address = {New York, NY, USA},
  series = {Haskell '13},
  title = {Hasochism: {{The Pleasure}} and {{Pain}} of {{Dependently Typed Haskell Programming}}},
  isbn = {978-1-4503-2383-3},
  shorttitle = {Hasochism},
  doi = {10.1145/2503778.2503786},
  abstract = {Haskell's type system has outgrown its Hindley-Milner roots to the extent that it now stretches to the basics of dependently typed programming. In this paper, we collate and classify techniques for programming with dependent types in Haskell, and contribute some new ones. In particular, through extended examples---merge-sort and rectangular tilings---we show how to exploit Haskell's constraint solver as a theorem prover, delivering code which, as Agda programmers, we envy. We explore the compromises involved in simulating variations on the theme of the dependent function space in an attempt to help programmers put dependent types to work, and to inform the evolving language design both of Haskell and of dependently typed languages more broadly.},
  urldate = {2018-08-29},
  booktitle = {Proceedings of the 2013 {{ACM SIGPLAN Symposium}} on {{Haskell}}},
  publisher = {{ACM}},
  url = {http://doi.acm.org/10.1145/2503778.2503786},
  author = {Lindley, Sam and McBride, Conor},
  year = {2013},
  keywords = {dependent types,singletons,data type promotion,invariants,proof search},
  pages = {81--92},
  file = {/Users/doisinkidney/Zotero/storage/U7CFKDH5/Lindley and McBride - 2013 - Hasochism The Pleasure and Pain of Dependently Ty.pdf}
}

@book{martin-lof_intuitionistic_1980,
  address = {Padua},
  title = {Intuitionistic {{Type Theory}}},
  url = {http://www.cse.chalmers.se/~peterd/papers/MartinL\%00f6f1984.pdf},
  author = {{Martin-L\"of}, Per},
  month = jun,
  year = {1980},
  file = {/Users/doisinkidney/Zotero/storage/IQS3729C/MartinLöf1984.pdf}
}

@misc{the_coq_development_team_2018_1219885,
  title = {The {{Coq Proof Assistant}}, Version 8.8.0},
  url = {https://doi.org/10.5281/zenodo.1219885},
  author = {Team, The Coq Development},
  month = apr,
  year = {2018}
}

@misc{escardo_libraries_2018,
  title = {Libraries for {{Bin}}},
  language = {en},
  urldate = {2018-09-12},
  url = {https://lists.chalmers.se/pipermail/agda/2018/010379.html},
  author = {Escardo, Martin},
  month = jul,
  year = {2018}
}

@misc{meshveliani_binary-4_2018,
  title = {Binary-4 \textendash{} a {{Pure Binary Natural Number Arithmetic}} Library for {{Agda}}},
  shorttitle = {Binary-4},
  abstract = {Binary-4 is a pure, regular-performance, complete, and certified binary arithmetic for natural numbers written in Agda.},
  url = {http://www.botik.ru/pub/local/Mechveliani/binNat/},
  author = {Meshveliani, Sergei},
  year = {21-Aug-2018}
}

@article{loulergue_calculating_2017,
  title = {Calculating {{Parallel Programs}} in {{Coq Using List Homomorphisms}}},
  volume = {45},
  issn = {0885-7458, 1573-7640},
  doi = {10.1007/s10766-016-0415-8},
  abstract = {SyDPaCC is a set of libraries for the Coq proof assistant. It allows to write naive functional programs (i.e. with high complexity) that are considered as specifications, and to transform them into more efficient versions. These more efficient versions can then be automatically parallelised before being extracted from Coq into source code for the functional language OCaml together with calls to the Bulk Synchronous Parallel ML (BSML) library. In this paper we present a new core version of SyDPaCC for the development of parallel programs correct-by-construction using the theory of list homomorphisms and algorithmic skeletons implemented and verified in Coq. The framework is illustrated on the maximum prefix sum problem.},
  language = {en},
  number = {2},
  urldate = {2018-09-13},
  journal = {International Journal of Parallel Programming},
  url = {http://link.springer.com/10.1007/s10766-016-0415-8},
  author = {Loulergue, Fr\'ed\'eric and Bousdira, Wadoud and Tesson, Julien},
  month = apr,
  year = {2017},
  pages = {300-319},
  file = {/Users/doisinkidney/Zotero/storage/UK3HBZKP/Loulergue et al. - 2017 - Calculating Parallel Programs in Coq Using List Ho.pdf}
}

@article{chuang_extraction_nodate,
  title = {Extraction of {{Programs}} for {{Exact Real Number Computation Using Agda}}},
  language = {en},
  author = {Chuang, Chi Ming},
  pages = {213},
  file = {/Users/doisinkidney/Zotero/storage/VTEGICG8/Chuang - Extraction of Programs for Exact Real Number Compu.pdf}
}

@article{ferreira_principles_nodate,
  title = {Principles and {{Applications}} of {{Algorithmic Problem Solving}}},
  language = {en},
  author = {Ferreira, Jo\~ao Fernando Peixoto},
  pages = {345},
  file = {/Users/doisinkidney/Zotero/storage/RF69IQLC/Ferreira - Principles and Applications of Algorithmic Problem.pdf}
}

@article{kokke_programming_nodate,
  title = {Programming Proof Search Using Reflection},
  abstract = {As proofs in type theory become increasingly complex, there is a growing need to provide better proof automation. This paper shows how to implement a Prolog-style resolution procedure in the dependently typed programming language Agda. Connecting this resolution procedure to Agda's reflection mechanism provides a first-class proof search tactic for first-order Agda terms. As a result, writing proof automation tactics need not be different from writing any other program.},
  language = {en},
  author = {Kokke, Pepijn and Swierstra, Wouter},
  pages = {27},
  file = {/Users/doisinkidney/Zotero/storage/8H5U9HPU/Kokke and Swierstra - Programming proof search using reﬂection.pdf}
}

@incollection{hutchison_tool_2006,
  address = {Berlin, Heidelberg},
  title = {A {{Tool}} for {{Automated Theorem Proving}} in {{Agda}}},
  volume = {3839},
  isbn = {978-3-540-31428-8 978-3-540-31429-5},
  abstract = {We present a tool for automated theorem proving in Agda, an implementation of Martin-L\"of's intuitionistic type theory. The tool is intended to facilitate interactive proving by relieving the user from filling in simple but tedious parts of a proof. The proof search is conducted directly in type theory and produces proof terms. Any proof term is verified by the Agda type-checker, which ensures soundness of the tool. Some effort has been spent on trying to produce human readable results, which allows the user to examine the generated proofs. We have tested the tool on examples mainly in the area of (functional) program verification. Most examples we have considered contain induction, and some contain generalisation. The contribution of this work outside the Agda community is to extend the experience of automated proof for intuitionistic type theory.},
  language = {en},
  urldate = {2018-09-13},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/11617990_10},
  author = {Lindblad, Fredrik and Benke, Marcin},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Filli\^atre, Jean-Christophe and {Paulin-Mohring}, Christine and Werner, Benjamin},
  year = {2006},
  pages = {154-169},
  file = {/Users/doisinkidney/Zotero/storage/2LIWNNNY/Lindblad and Benke - 2006 - A Tool for Automated Theorem Proving in Agda.pdf},
  doi = {10.1007/11617990_10}
}

@inproceedings{kokke_auto_2015,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Auto in {{Agda}}},
  isbn = {978-3-319-19797-5},
  abstract = {As proofs in type theory become increasingly complex, there is a growing need to provide better proof automation. This paper shows how to implement a Prolog-style resolution procedure in the dependently typed programming language Agda. Connecting this resolution procedure to Agda's reflection mechanism provides a first-class proof search tactic for first-order Agda terms. As a result, writing proof automation tactics need not be different from writing any other program.},
  language = {en},
  booktitle = {Mathematics of {{Program Construction}}},
  publisher = {{Springer International Publishing}},
  url = {http://www.staff.science.uu.nl/~swier004/publications/2015-mpc.pdf},
  author = {Kokke, Pepijn and Swierstra, Wouter},
  editor = {Hinze, Ralf and Voigtl\"ander, Janis},
  year = {2015},
  keywords = {Abstract Syntax Tree,Goal Type,Implicit Argument,Proof Search,Unification Algorithm},
  pages = {276-301},
  file = {/Users/doisinkidney/Zotero/storage/8E57HAPM/Kokke and Swierstra - 2015 - Auto in Agda.pdf;/Users/doisinkidney/Zotero/storage/HPTCKCL2/Kokke and Swierstra - Programming proof search using reﬂection.pdf}
}

@incollection{thiemann_extensible_2016,
  address = {Berlin, Heidelberg},
  title = {Extensible and {{Efficient Automation Through Reflective Tactics}}},
  volume = {9632},
  isbn = {978-3-662-49497-4 978-3-662-49498-1},
  abstract = {Foundational proof assistants simultaneously offer both expressive logics and strong guarantees. The price they pay for this flexibility is often the need to build and check explicit proof objects which can be expensive. In this work we develop a collection of techniques for building reflective automation, where proofs are witnessed by verified decision procedures rather than verbose proof objects. Our techniques center around a verified domain specific language for proving, Rtac, written in Gallina, Coq's logic. The design of tactics makes it easy to combine them into higher-level automation that can be proved sound in a mostly automated way. Furthermore, unlike traditional uses of reflection, Rtac tactics are independent of the underlying problem domain. This allows them to be re-tasked to automate new problems with very little effort. We demonstrate the usability of Rtac through several case studies demonstrating orders of magnitude speedups for relatively little engineering work.},
  language = {en},
  urldate = {2018-09-15},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-662-49498-1_21},
  author = {Malecha, Gregory and Bengtson, Jesper},
  editor = {Thiemann, Peter},
  year = {2016},
  pages = {532-559},
  file = {/Users/doisinkidney/Zotero/storage/DG5QW9GB/Malecha and Bengtson - 2016 - Extensible and Efficient Automation Through Reflec.pdf},
  doi = {10.1007/978-3-662-49498-1_21}
}

@incollection{bobaru_integrating_2011,
  address = {Berlin, Heidelberg},
  title = {Integrating an {{Automated Theorem Prover}} into {{Agda}}},
  volume = {6617},
  isbn = {978-3-642-20397-8 978-3-642-20398-5},
  abstract = {Agda is a dependently typed functional programming language and a proof assistant in which developing programs and proving their correctness is one activity. We show how this process can be enhanced by integrating external automated theorem provers, provide a prototypical integration of the equational theorem prover Waldmeister, and give examples of how this proof automation works in practice.},
  language = {en},
  urldate = {2018-09-15},
  booktitle = {{{NASA Formal Methods}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-642-20398-5_10},
  author = {Foster, Simon and Struth, Georg},
  editor = {Bobaru, Mihaela and Havelund, Klaus and Holzmann, Gerard J. and Joshi, Rajeev},
  year = {2011},
  pages = {116-130},
  file = {/Users/doisinkidney/Zotero/storage/KURGY5CK/Foster and Struth - 2011 - Integrating an Automated Theorem Prover into Agda.pdf},
  doi = {10.1007/978-3-642-20398-5_10}
}

@incollection{scholz_parsing_2011,
  address = {Berlin, Heidelberg},
  title = {Parsing {{Mixfix Operators}}},
  volume = {5836},
  isbn = {978-3-642-24451-3 978-3-642-24452-0},
  abstract = {A simple grammar scheme for expressions containing mixfix operators is presented. The scheme is parameterised by a precedence relation which is only restricted to be a directed acyclic graph; this makes it possible to build up precedence relations in a modular way. Efficient and simple implementations of parsers for languages with user-defined mixfix operators, based on the grammar scheme, are also discussed. In the future we plan to replace the support for mixfix operators in the language Agda with a grammar scheme and an implementation based on this work.},
  language = {en},
  urldate = {2018-09-16},
  booktitle = {Implementation and {{Application}} of {{Functional Languages}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-642-24452-0_5},
  author = {Danielsson, Nils Anders and Norell, Ulf},
  editor = {Scholz, Sven-Bodo and Chitil, Olaf},
  year = {2011},
  pages = {80-99},
  file = {/Users/doisinkidney/Zotero/storage/JFL9L879/Danielsson and Norell - 2011 - Parsing Mixfix Operators.pdf},
  doi = {10.1007/978-3-642-24452-0_5}
}

@article{danielsson_dependent_nodate,
  title = {Dependent Lenses},
  abstract = {Very well-behaved lenses provide a convenient mechanism for defining setters and getters for nested records (among other things). However, they do not work very well for dependent records, in which one field's type can depend on the value of a previous field.},
  language = {en},
  author = {Danielsson, Nils Anders},
  pages = {11},
  file = {/Users/doisinkidney/Zotero/storage/2JWJKWWL/Danielsson - Dependent lenses.pdf}
}

@article{allais_certied_nodate,
  title = {Certified {{Proof Search}} for {{Intuitionistic Linear Logic}}},
  abstract = {In this article we show the difficulties a type-theorist may face when attempting to formalise a decidability result described informally. We then demonstrate how generalising the problem and switching to a more structured presentation can alleviate her suffering.},
  language = {en},
  author = {Allais, Guillaume and McBride, Conor},
  pages = {15},
  file = {/Users/doisinkidney/Zotero/storage/4K9GKNQM/Allais and McBride - Certiﬁed Proof Search for Intuitionistic Linear Lo.pdf}
}

@article{allais_using_2011,
  title = {Using Reflection to Solve Some Differential Equations},
  abstract = {On top of coqtail's libraries that provide a formalization of power series, we added a small development that aims at simplifying proofs that given power series are solutions of specific differential equations. The use of reflection allows to prove general facts about differential equations which can then be used to simplify the proofs thanks to an Ltac machinery that performs the tedious conversions.},
  language = {en},
  author = {Allais, Guillaume},
  month = jun,
  year = {2011},
  pages = {6},
  file = {/Users/doisinkidney/Zotero/storage/CHYR3YFF/Allais - Using reﬂection to solve some diﬀerential equation.pdf}
}

@inproceedings{allais_new_2013,
  address = {Boston, Massachusetts, USA},
  title = {New Equations for Neutral Terms: A Sound and Complete Decision Procedure, Formalized},
  isbn = {978-1-4503-2384-0},
  shorttitle = {New Equations for Neutral Terms},
  doi = {10.1145/2502409.2502411},
  abstract = {The definitional equality of an intensional type theory is its test of type compatibility. Today's systems rely on ordinary evaluation semantics to compare expressions in types, frustrating users with type errors arising when evaluation fails to identify two `obviously' equal terms. If only the machine could decide a richer theory! We propose a way to decide theories which supplement evaluation with `{$\nu$}-rules', rearranging the neutral parts of normal forms, and report a successful initial experiment.},
  language = {en},
  urldate = {2018-09-16},
  booktitle = {Proceedings of the 2013 {{ACM SIGPLAN}} Workshop on {{Dependently}}-Typed Programming - {{DTP}} '13},
  publisher = {{ACM Press}},
  url = {http://dl.acm.org/citation.cfm?doid=2502409.2502411},
  author = {Allais, Guillaume and McBride, Conor and Boutillier, Pierre},
  year = {2013},
  pages = {13},
  file = {/Users/doisinkidney/Zotero/storage/Y6EL76MR/Allais et al. - 2013 - New equations for neutral terms a sound and compl.pdf}
}

@article{allais_deciding_nodate,
  title = {Deciding {{Presburger}} Arithmetic Using Reflection},
  abstract = {The need to prove or disprove a formula of Presburger arithmetic is quite frequent in certified software development (constraints generated automatically) or when working on higher arithmetic (number theory). The fact that this theory is decidable and that Agda is now mature enough to be able to implement such a solver pushed us to try to tackle this problem.},
  language = {en},
  author = {Allais, G},
  pages = {14},
  file = {/Users/doisinkidney/Zotero/storage/7JJJTEUI/Allais - Deciding Presburger arithmetic using reﬂection.pdf}
}

@incollection{hinze_engineering_2013,
  address = {Berlin, Heidelberg},
  title = {Engineering {{Proof}} by {{Reflection}} in {{Agda}}},
  volume = {8241},
  isbn = {978-3-642-41581-4 978-3-642-41582-1},
  abstract = {This paper explores the recent addition to Agda enabling reflection, in the style of Lisp and Template Haskell. It gives a brief introduction to using reflection, and details the complexities encountered when automating certain proofs with proof by reflection. It presents a library that can be used for automatically quoting a class of concrete Agda terms to a non-dependent, user-defined inductive data type, alleviating some of the burden a programmer faces when using reflection in a practical setting.},
  language = {en},
  urldate = {2018-09-16},
  booktitle = {Implementation and {{Application}} of {{Functional Languages}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-642-41582-1_10},
  author = {{van der Walt}, Paul and Swierstra, Wouter},
  editor = {Hinze, Ralf},
  year = {2013},
  pages = {157-173},
  file = {/Users/doisinkidney/Zotero/storage/66IQWHX3/van der Walt and Swierstra - 2013 - Engineering Proof by Reflection in Agda.pdf},
  doi = {10.1007/978-3-642-41582-1_10}
}

@article{korkut_intrinsic_nodate,
  title = {Intrinsic {{Verification}} of a {{Regular Expression Matcher}}},
  abstract = {Harper's 1999 Functional Pearl on regular expression matching is a strong example of the interplay between programming and proof, and has been used for many years in introductory functional programming classes. In this paper, we revisit this algorithm from the point of view of dependently typed programming. In the process of formalizing the algorithm and its correctness using the Agda proof assistant, we found three interesting variations. First, defunctionalizing the matcher allows Agda to see termination without an explicit metric, and provides a simple first-order matcher with a clear relationship to the original, giving an alternative to a later Educational Pearl by Yi. Second, intrinsically verifying the soundness of the algorithm has useful computational content, allowing the extraction of matching strings from the parse tree. Third, while Harper uses a negative definition of standard regular expressions (no starred subexpression accepts the empty string), using a syntactic definition of standardness simplifies the staging of the development. These variations provide a nice illustration of the benefits of thinking in a dependently typed language, and have some pedagogical value for streamlining and extending the presentation of this material. {${_\ast}$}This material is based on research sponsored in part by by The United States Air Force Research Laboratory under agreement number FA9550-15-1-0053. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the United States Air Force Research Laboratory, the U.S. Government or Carnegie Mellon University.},
  language = {en},
  author = {Korkut, Joomy and Trifunovski, Maksim and Licata, Daniel R},
  pages = {25},
  file = {/Users/doisinkidney/Zotero/storage/HTMKSUNR/Korkut et al. - Intrinsic Veriﬁcation of a Regular Expression Matc.pdf;/Users/doisinkidney/Zotero/storage/P934KSVE/Korkut et al. - Intrinsic Veriﬁcation of a Regular Expression Matc.pdf;/Users/doisinkidney/Zotero/storage/UK7N74L9/Korkut et al. - Intrinsic Veriﬁcation of a Regular Expression Matc.pdf}
}

@inproceedings{ml10sectyp,
  title = {Security-{{Typed Programming}} within {{Dependently}}-{{Typed Programming}}},
  booktitle = {International {{Conference}} on {{Functional Programming}}},
  author = {Morgenstern, Jamie and Licata, Daniel R.},
  year = {2010},
  file = {/Users/doisinkidney/Zotero/storage/WL4LDTFI/Morgenstern and Licata - 2010 - Security-Typed Programming within Dependently-Type.pdf}
}

@misc{allais_three_2016,
  title = {Three {{Tricks}} to Make {{Termination Obvious}}},
  abstract = {Two weeks ago I spent some time implementing Wadler's "Prettier Printer". The implementation is fairly straightforward except for three functions that are not seen as terminating. Here are the three tricks that made them go through.},
  urldate = {2018-09-16},
  journal = {gallais' blog},
  url = {https://gallais.github.io/blog/termination-tricks.html},
  author = {Allais, Guillaume},
  month = nov,
  year = {2016},
  file = {/Users/doisinkidney/Zotero/storage/ITLVNI2H/termination-tricks.html}
}

@inproceedings{abel_miniagda_2010,
  title = {{{MiniAgda}}: {{Integrating}} Sized and Dependent Types},
  shorttitle = {Miniagda},
  abstract = {Sized types are a modular and theoretically well-understood tool for checking termination of recursive and productivity of corecursive definitions. The essential idea is to track structural descent and guardedness in the type system to make termination checking robust and suitable for strong abstractions like higher-order functions and polymorphism. To study the application of sized types to proof assistants and programming languages based on dependent type theory, we have implemented a core language, MiniAgda, with explicit handling of sizes. New considerations were necessary to soundly integrate sized types with dependencies and pattern matching, which was made possible by modern concepts such as inaccessible patterns and parametric function spaces. This paper provides an introduction to MiniAgda by example and informal explanations of the underlying principles. 1},
  language = {en},
  booktitle = {{{PAR}}, Volume 43 of {{EPTCS}}},
  author = {Abel, Andreas},
  year = {2010},
  pages = {14--28},
  file = {/Users/doisinkidney/Zotero/storage/C8SGX7MN/Abel - 2010 - Miniagda Integrating sized and dependent types.pdf;/Users/doisinkidney/Zotero/storage/KP266WFQ/Abel - MiniAgda Integrating Sized and Dependent Types.pdf;/Users/doisinkidney/Zotero/storage/LCKS32ZV/summary\;jsessionid=11EAC1E0ADB87A0CC4E950303BE9DB40.html}
}

@misc{jedynak_simple_2018,
  title = {A Simple Demonstration of the {{Agda Reflection API}}.},
  urldate = {2018-09-17},
  url = {https://github.com/wjzz/Agda-reflection-for-semiring-solver},
  author = {Jedynak, Wojciech},
  month = sep,
  year = {2018}
}

@misc{norell_agda-prelude_2018,
  title = {Agda-Prelude: {{Programming}} Library for {{Agda}}},
  copyright = {MIT},
  shorttitle = {Agda-Prelude},
  abstract = {This is an alternative to the Agda standard library that focuses more on programming and type checking time performance.

Notable features:

Makes heavy use of instance arguments.

Efficient decision procedures for natural number arithmetic (Tactic.Nat).

Evidence-producing and efficient gcd and primality testing (Data.Nat.GCD and Data.Nat.Prime).

This is very much work in progress, so expect major changes. In particular the proof-side of things is very much unstructured.},
  urldate = {2018-09-17},
  url = {https://github.com/UlfNorell/agda-prelude},
  author = {Norell, Ulf},
  month = aug,
  year = {2018}
}

@phdthesis{christiansen_practical_2015,
  title = {Practical {{Reflection}} and {{Metaprogramming}} for {{Dependent Types}}},
  abstract = {Embedded domain-specific languages are special-purpose programming languages that are implemented within existing generalpurpose programming languages. Dependent type systems allow strong invariants to be encoded in representations of domain-specific languages, but it can also make it difficult to program in these embedded languages. Interpreters and compilers must always take these invariants into account at each stage, and authors of embedded languages must work hard to relieve users of the burden of proving these properties.},
  language = {en},
  school = {IT University of Copenhagen},
  url = {http://davidchristiansen.dk/david-christiansen-phd.pdf},
  author = {Christiansen, David Raymond},
  month = nov,
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/NRBJRYLX/Christiansen - Practical Reflection and Metaprogramming for Depen.pdf}
}

@article{weirich_arity-generic_nodate,
  title = {Arity-{{Generic Datatype}}-{{Generic Programming}}},
  abstract = {Some programs are doubly-generic. For example, map is datatypegeneric in that many different data structures support a mapping operation. A generic programming language like Generic Haskell can use a single definition to generate map for each type. However, map is also arity-generic because it belongs to a family of related operations that differ in the number of arguments. For lists, this family includes repeat, map, zipWith, zipWith3, zipWith4, etc. With dependent types or clever programming, one can unify all of these functions together in a single definition.},
  language = {en},
  author = {Weirich, Stephanie and Casinghino, Chris},
  pages = {12},
  file = {/Users/doisinkidney/Zotero/storage/UM4HL7ZW/Weirich and Casinghino - Arity-Generic Datatype-Generic Programming.pdf}
}

@phdthesis{mu_calculational_2003-1,
  type = {Ph.{{D}}.},
  title = {A Calculational Approach to Program Inversion},
  language = {eng},
  urldate = {2018-09-18},
  school = {University of Oxford},
  url = {https://ethos.bl.uk/OrderDetails.do;jsessionid=797639DAEAA5E69A0BE5E51DACA5044F?uin=uk.bl.ethos.275405},
  author = {Mu, Shin-Cheng},
  month = jan,
  year = {2003},
  file = {/Users/doisinkidney/Zotero/storage/28FA7TKN/Mu - 2003 - A calculational approach to program inversion.pdf;/Users/doisinkidney/Zotero/storage/36Q9CI7P/Mu - 2003 - A calculational approach to program inversion.pdf;/Users/doisinkidney/Zotero/storage/4ZU2NBJK/Mu - A CALCULATIONAL APPROACH TO PROGRAM INVERSION.pdf;/Users/doisinkidney/Zotero/storage/BKUWKM3E/Mu - 2003 - A Calculational Approach to Program Inversion.pdf;/Users/doisinkidney/Zotero/storage/BS5W6V3A/Mu - 2003 - A Calculational Approach to Program Inversion.pdf;/Users/doisinkidney/Zotero/storage/DSZ23VZC/Mu - 2003 - A Calculational Approach to Program Inversion.pdf;/Users/doisinkidney/Zotero/storage/E54CP6N7/Mu - A CALCULATIONAL APPROACH TO PROGRAM INVERSION.pdf;/Users/doisinkidney/Zotero/storage/LENLXK88/thesis.pdf;/Users/doisinkidney/Zotero/storage/NRH5HGEB/Mu - 2003 - A Calculational Approach to Program Inversion.pdf;/Users/doisinkidney/Zotero/storage/VY4BY2SP/Mu - 2003 - A Calculational Approach to Program Inversion.pdf;/Users/doisinkidney/Zotero/storage/XCX94TJ3/Mu - A CALCULATIONAL APPROACH TO PROGRAM INVERSION.pdf;/Users/doisinkidney/Zotero/storage/XNJEQ9HW/Mu - A CALCULATIONAL APPROACH TO PROGRAM INVERSION.pdf;/Users/doisinkidney/Zotero/storage/ZLHTA8KC/Mu - 2003 - A Calculational Approach to Program Inversion.pdf;/Users/doisinkidney/Zotero/storage/PGMNKEZ7/OrderDetails.html;/Users/doisinkidney/Zotero/storage/X8F873MY/OrderDetails.html}
}

@misc{yang_well-founded_2010,
  title = {Well-Founded Recursion in {{Agda}}},
  shorttitle = {Well-Founded Recursion in {{Agda}}},
  language = {en-US},
  urldate = {2018-09-19},
  journal = {Inside 245-5D},
  url = {http://blog.ezyang.com/2010/06/well-founded-recursion-in-agda/},
  author = {Yang, Edward Z.},
  month = jun,
  year = {2010},
  file = {/Users/doisinkidney/Zotero/storage/IPAIWHEA/well-founded-recursion-in-agda.html}
}

@misc{diatchki_introducing_2010,
  title = {Introducing {{Well}}-{{Founded Recursion}}},
  shorttitle = {Galois \guilsinglright{} {{Blog}} \guilsinglright{} {{Blog}} \guillemotright{} {{Tech Talk}}},
  urldate = {2018-09-19},
  journal = {Galois {$>$} Blog},
  url = {https://web.archive.org/web/20100822202828/http://www.galois.com/blog/2010/06/11/tech-talk-introducing-well-founded-recursion/},
  author = {Diatchki, Iavor S.},
  month = jun,
  year = {2010},
  file = {/Users/doisinkidney/Zotero/storage/29UCZ6R2/tech-talk-introducing-well-founded-recursion.html}
}

@article{bove_modelling_2005,
  title = {Modelling General Recursion in Type Theory},
  volume = {15},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129505004822},
  language = {en},
  number = {4},
  urldate = {2018-09-19},
  journal = {Mathematical Structures in Computer Science},
  url = {http://www.journals.cambridge.org/abstract_S0960129505004822},
  author = {Bove, Ana and Capretta, Venanzio},
  month = jul,
  year = {2005},
  pages = {671-708},
  file = {/Users/doisinkidney/Zotero/storage/XJH42CYY/Bove and Capretta - 2005 - Modelling general recursion in type theory.pdf}
}

@article{nordstrom_terminating_1987,
  title = {Terminating General Recursion},
  volume = {28},
  issn = {0006-3835, 1572-9125},
  doi = {10.1007/BF01941137},
  abstract = {In Martin-Lof's type theory, general recursion is not available. The only iterating constructs are primitive recursion over natural numbers and other inductive sets. The paper describes a way to allow a general recursion operator in type theory (extended with propositions). A proof rule for the new operator is presented. The addition of the new operator will not distroy the property that all well-typed programs terminate. An advantage of the new program construct is that it is possible to separate the termination proof of the program from the proof of other properties.},
  language = {en},
  number = {3},
  urldate = {2018-09-19},
  journal = {BIT},
  url = {http://link.springer.com/10.1007/BF01941137},
  author = {Nordstr\"om, Bengt},
  month = sep,
  year = {1987},
  pages = {605-619},
  file = {/Users/doisinkidney/Zotero/storage/UKPV6PBD/Nordström - 1988 - Terminating general recursion.pdf}
}

@article{abel_wellfounded_2013,
  title = {Wellfounded {{Recursion}} with {{Copatterns}}},
  abstract = {In this paper, we study strong normalization of a core language based on System F{$\omega$} which supports programming with finite and infinite structures. Building on our prior work, finite data such as finite lists and trees are defined via constructors and manipulated via pattern matching, while infinite data such as streams and infinite trees is defined by observations and synthesized via copattern matching. In this work, we take a type-based approach to strong normalization by tracking size information about finite and infinite data in the type. This guarantees compositionality. More importantly, the duality of pattern and copatterns provide a unifying semantic concept which allows us for the first time to elegantly and uniformly support both well-founded induction and coinduction by mere rewriting. The strong normalization proof is structured around Girard's reducibility candidates. As such our system allows for non-determinism and does not rely on coverage. Since System F{$\omega$} is general enough that it can be the target of compilation for the Calculus of Constructions, this work is a significant step towards representing observation-centric infinite data in proof assistants such as Coq and Agda.},
  language = {en},
  url = {http://www2.tcs.ifi.lmu.de/\%7Eabel/icfp13-long.pdf},
  author = {Abel, Andreas and Pientka, Brigitte},
  month = jun,
  year = {2013},
  pages = {25},
  file = {/Users/doisinkidney/Zotero/storage/27CYWC4L/Abel and Pientka - Wellfounded Recursion with Copatterns.pdf}
}

@misc{mertens_introducing_2010,
  address = {Galois Inc. 421 SW 6th Ave. Suite 300, Portland, OR, USA},
  title = {Introducing {{Well}}-Founded {{Recursion}}},
  abstract = {Implementing recursive functions can be tricky when you want to be certain that they eventually terminate. This talk introduces the concept of well-founded recursion as a tool for implementing recursive functions. It implements these concepts in the Agda programming language and demonstrates the technique by implementing a simple version of Quicksort.},
  language = {en},
  urldate = {2016-04-26},
  url = {https://web.archive.org/web/20160426192417/http://code.galois.com/talk/2010/10-06-mertens.pdf},
  author = {Mertens, Eric},
  month = jun,
  year = {2010},
  file = {/Users/doisinkidney/Zotero/storage/AYDUTTXY/Mertens - Introducing Well-founded Recursion.pdf}
}

@misc{paulson2016future,
  title = {The {{Future}} of {{Formalised Mathematics}}},
  abstract = {Recent years have witnessed tremendous achievements in formalised mathe- matics, including the completion of the Flyspeck project (a machine-checked proof of the Kepler Conjecture) and the formalisation of the odd order theorem, the central limit the- orem and G\"odel's second incompleteness theorem. Formalised mathematics has started to attract the attention of mainstream mathematicians such as Harvey Friedman, Tim Gow- ers and Tom Hales. Nevertheless, there is much disagreement on the details of formalisms (constructive or classical, typed or typeless), proof languages (linear or structured) and automation (minimal, heuristic or algorithmic). The recent translation of the HOL Light multivariate analysis library to Isabelle highlights some of these di􏰀erences. The speaker will address these issues, referencing recent developments in the formalisation of real alge- braic geometry.},
  language = {en},
  url = {https://www.cl.cam.ac.uk/~lp15/papers/Formath/Future\%20of\%20formalised\%20maths.pdf},
  author = {Paulson, Lawrence C},
  year = {2016},
  file = {/Users/doisinkidney/Zotero/storage/R9S6SV6Y/Paulson - The Future of Formalised Mathematics.pdf}
}

@book{abel_foetus_1998,
  title = {Foetus \textendash{} {{Termination Checker}} for {{Simple Functional Programs}}},
  abstract = {We introduce a simple functional language foetus (lambda calculus with tuples, constructors and pattern matching) supplied with a termination checker. This checker tries to find a well-founded structural order on the parameters on the given function to prove termination. The components of the check algorithm are: function call extraction out of the program text, call graph completion and finding a lexical order for the function parameters. The HTML version of this paper contains many ready-to-run Web-based examples.},
  author = {Abel, Andreas},
  year = {1998},
  file = {/Users/doisinkidney/Zotero/storage/6RRBVHKX/Abel - 1998 - foetus – Termination Checker for Simple Functional.pdf;/Users/doisinkidney/Zotero/storage/K7PV9HSB/summary.html}
}

@inproceedings{atkey_syntax_2018,
  address = {Oxford, United Kingdom},
  title = {Syntax and {{Semantics}} of {{Quantitative Type Theory}}},
  isbn = {978-1-4503-5583-4},
  doi = {10.1145/3209108.3209189},
  abstract = {We present Quantitative Type Theory, a Type Theory that records usage information for each variable in a judgement, based on a previous system by McBride. The usage information is used to give a realizability semantics using a variant of Linear Combinatory Algebras, refining the usual realizability semantics of Type Theory by accurately tracking resource behaviour. We define the semantics in terms of Quantitative Categories with Families, a novel extension of Categories with Families for modelling resource sensitive type theories.},
  language = {en},
  urldate = {2018-09-20},
  booktitle = {Proceedings of the 33rd {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}  - {{LICS}} '18},
  publisher = {{ACM Press}},
  url = {http://dl.acm.org/citation.cfm?doid=3209108.3209189},
  author = {Atkey, Robert},
  year = {2018},
  pages = {56-65},
  file = {/Users/doisinkidney/Zotero/storage/3XYITYUB/Atkey - 2018 - Syntax and Semantics of Quantitative Type Theory.pdf}
}

@article{abel_resourceful_nodate,
  title = {Resourceful {{Dependent Types}}},
  language = {en},
  author = {Abel, Andreas},
  pages = {2},
  file = {/Users/doisinkidney/Zotero/storage/VQE7K7YK/Abel - Resourceful Dependent Types.pdf}
}

@article{shulman_type_nodate,
  title = {Type Theory and Category Theory},
  language = {en},
  author = {Shulman, Michael},
  pages = {126},
  file = {/Users/doisinkidney/Zotero/storage/UYEH5SND/Shulman - Type theory and category theory.pdf}
}

@article{isaza_category_2014,
  title = {Category {{Theory Applied}} to {{Functional Programming}}},
  language = {en},
  author = {Isaza, Juan Pedro Villa},
  year = {2014},
  pages = {131},
  file = {/Users/doisinkidney/Zotero/storage/ZEA9EU2W/Isaza - 2014 - Category Theory Applied to Functional Programming.pdf}
}

@phdthesis{blaguszewski_implementing_2010,
  address = {G\"oteborg, Sweden},
  type = {Master of {{Science Thesis}} in the {{Program CSALL}}},
  title = {Implementing and {{Optimizing}} a {{Simple}}, {{Dependently}}-{{Typed Language}}},
  abstract = {This thesis presents a compiler for the simple functional programming language LambdaPi, which includes dependent types. The compiler is written in Haskell and uses LLVM, a framework for building optimizing compiler backends. It can compile the complete standard library provided by LambdaPi's authors into native machine code. It is not much of an optimizing compiler, but several obvious opportunities for improvement exist.
First I discuss the theoretical background of project: the principles of dependent types and the languages which include them. I also give a brief overview of the LLVM system and of related work. The second section describes the process of implementation, which was done in stages from a trivial calculator language up to full LambdaPi. And finally we consider opportunities for optimization. Some of these stem from Edwin Brady's [2005] analysis of Epigram, while others are lower-level and can be performed for us by LLVM.},
  language = {en},
  urldate = {2018-09-20},
  school = {Chalmers University of Technology},
  url = {http://publications.lib.chalmers.se/records/fulltext/124826.pdf},
  author = {Blaguszewski, Michael},
  month = apr,
  year = {2010},
  file = {/Users/doisinkidney/Zotero/storage/PBMHDGYH/124826.pdf},
  note = {https://archives.haskell.org/code.haskell.org/LambdaPiC/}
}

@article{harper_foundations_nodate,
  title = {Foundations and {{Applications}} of {{Higher}}-{{Dimensional Directed Type Theory}}},
  language = {en},
  author = {Harper, Robert and Licata, Daniel R},
  year = {http://www.cs.cmu.edu/afs/.cs.cmu.edu/Web/People/drl/pubs/lh102dttnsf/lh102dttnsf.pdf},
  pages = {19},
  file = {/Users/doisinkidney/Zotero/storage/QYIZ3T43/Harper and Licata - Foundations and Applications of Higher-Dimensional.pdf}
}

@incollection{hutchison_bounded_2014,
  address = {Berlin, Heidelberg},
  title = {Bounded {{Linear Types}} in a {{Resource Semiring}}},
  volume = {8410},
  isbn = {978-3-642-54832-1 978-3-642-54833-8},
  abstract = {Bounded linear types have proved to be useful for automated resource analysis and control in functional programming languages. In this paper we introduce a bounded linear typing discipline on a general notion of resource which can be modeled in a semiring. For this type system we provide both a general type-inference procedure, parameterized by the decision procedure of the semiring equational theory, and a (coherent) categorical semantics. This could be a useful type-theoretic and denotational framework for resource-sensitive compilation, and it represents a generalization of several existing type systems. As a nontrivial instance, motivated by hardware compilation, we present a complex new application to calculating and controlling timing of execution in a (recursion-free) higher-order functional programming language with local store.},
  language = {en},
  urldate = {2018-09-20},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-642-54833-8_18},
  author = {Ghica, Dan R. and Smith, Alex I.},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Shao, Zhong},
  year = {2014},
  pages = {331-350},
  file = {/Users/doisinkidney/Zotero/storage/I5EDLGEL/Ghica and Smith - 2014 - Bounded Linear Types in a Resource Semiring.pdf},
  doi = {10.1007/978-3-642-54833-8_18}
}

@article{abel_foetus_nodate,
  title = {Foetus - {{Termination Checker}} for {{Simple Functional Programs}}},
  abstract = {We introduce a simple functional language foetus (lambda calculus with tuples, constructors and pattern matching) supplied with a termination checker. This checker tries to find a well-founded structural order on the parameters on the given function to prove termination. The components of the check algorithm are: function call extraction out of the program text, call graph completion and finding a lexical order for the function parameters. The HTML version of this paper contains many ready-to-run Web-based examples.},
  language = {en},
  author = {Abel, Andreas},
  pages = {24},
  file = {/Users/doisinkidney/Zotero/storage/Q7LKRL9U/Abel - foetus - Termination Checker for Simple Functional.pdf}
}

@article{ko_programming_nodate,
  title = {Programming {{Metamorphic Algorithms}} in {{Agda}} ({{Functional Pearl}})},
  volume = {0},
  language = {en},
  number = {0},
  journal = {Proceedings of the ACM on Programming Languages},
  author = {Ko, Hsiang-Shang},
  pages = {26},
  file = {/Users/doisinkidney/Zotero/storage/8K25FUEB/Ko - Programming Metamorphic Algorithms in Agda (Functi.pdf;/Users/doisinkidney/Zotero/storage/8W52A5R5/Ko - Programming Metamorphic Algorithms in Agda (Functi.pdf}
}

@misc{licata_just_2011,
  title = {Just {{Kidding}}: {{Understanding Identity Elimination}} in {{Homotopy Type Theory}}},
  shorttitle = {Just {{Kidding}}},
  abstract = {Several current proof assistants, such as Agda and Epigram, provide uniqueness of identity proofs (UIP): any two proofs of the same propositional equality are themselves propositionally equal. Homo\ldots{}},
  language = {en},
  urldate = {2018-10-10},
  journal = {Homotopy Type Theory},
  url = {https://homotopytypetheory.org/2011/04/10/just-kidding-understanding-identity-elimination-in-homotopy-type-theory/},
  author = {Licata, Dan},
  month = apr,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/XP9CAKLA/just-kidding-understanding-identity-elimination-in-homotopy-type-theory.html}
}

@article{wadler_propositions_2015-1,
  title = {Propositions {{As Types}}},
  volume = {58},
  issn = {0001-0782},
  doi = {10.1145/2699407},
  abstract = {Connecting mathematical logic and computation, it ensures that some aspects of programming are absolute.},
  number = {12},
  urldate = {2018-10-10},
  journal = {Commun. ACM},
  url = {http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf},
  author = {Wadler, Philip},
  month = nov,
  year = {2015},
  pages = {75--84},
  file = {/Users/doisinkidney/Zotero/storage/6QXRH73L/propositions-as-types.pdf;/Users/doisinkidney/Zotero/storage/X6HFPXQN/propositions-as-types.pdf}
}

@article{coquand_equality_nodate,
  title = {Equality and Dependent Type Theory},
  language = {en},
  author = {Coquand, Thierry},
  pages = {59},
  file = {/Users/doisinkidney/Zotero/storage/HY4TXI2B/Coquand - Equality and dependent type theory.pdf}
}

@article{chapman_biased_nodate,
  title = {A Biased History of Equality in Type Theory},
  language = {en},
  author = {Chapman, James},
  pages = {22},
  file = {/Users/doisinkidney/Zotero/storage/LY5XPTFM/Chapman - A biased history of equality in type theory.pdf}
}

@book{whitehead_principia_1910,
  title = {Principia {{Mathematica}}. {{Vol}}. {{I}}},
  language = {English},
  urldate = {2018-10-13},
  url = {https://zbmath.org/?q=an\%3A41.0083.02},
  author = {Whitehead, A. N. and Russell, B.},
  year = {1910},
  file = {/Users/doisinkidney/Zotero/storage/CQPMGYHN/zbmath.org.html}
}

@book{whitehead_principia_1913,
  title = {Principia Mathematica. {{Vol}}. {{III}}},
  language = {English},
  urldate = {2018-10-13},
  url = {https://zbmath.org/?q=an\%3A44.0068.01},
  author = {Whitehead, A. N. and Russell, B.},
  year = {1913},
  file = {/Users/doisinkidney/Zotero/storage/8KS6FPTF/zbmath.org.html},
  note = {Published: Cambridge: University Press. X u. 491 S. \$8\^\textbackslash{}circ\$ (1913).}
}

@book{whitehead_principia_1912,
  title = {Principia {{Mathematica}}. {{Vol}}. {{II}}},
  language = {English},
  urldate = {2018-10-13},
  url = {https://zbmath.org/?q=an\%3A43.0093.03},
  author = {Whitehead, A. N. and Russell, B.},
  year = {1912},
  file = {/Users/doisinkidney/Zotero/storage/YCYKF384/zbmath.org.html},
  note = {Published: Cambridge: University Press. xxxiv, 772 S. \$8\^\textbackslash{}circ\$ (1912).
MSC2010: 
                                                03-02
                                             = 
                                                Research monographs (mathematical logic)}
}

@article{gonthier_formal_2008,
  title = {Formal {{Proof}}\textemdash{{The Four}}-{{Color Theorem}}},
  volume = {55},
  language = {en},
  number = {11},
  journal = {Notices of the AMS},
  author = {Gonthier, Georges},
  year = {2008},
  pages = {12},
  file = {/Users/doisinkidney/Zotero/storage/254L4UBG/Gonthier - 2008 - Formal Proof—The Four- Color Theorem.pdf;/Users/doisinkidney/Zotero/storage/JNKRWD79/Gonthier - 2008 - Formal Proof—The Four- Color Theorem.pdf}
}

@article{appel_solution_1977,
  title = {The {{Solution}} of the {{Four}}-{{Color}}-{{Map Problem}}},
  volume = {237},
  issn = {0036-8733},
  number = {4},
  urldate = {2018-10-14},
  journal = {Scientific American},
  url = {http://www.jstor.org/stable/24953967},
  author = {Appel, Kenneth and Haken, Wolfgang},
  year = {1977},
  pages = {108-121},
  file = {/Users/doisinkidney/Zotero/storage/ZJTJRIZC/Appel and Haken - 1977 - The Solution of the Four-Color-Map Problem.pdf}
}

@misc{abel_sized_2008,
  address = {Sendai, Japan},
  title = {Sized {{Types}} in {{Agda}}},
  language = {en},
  urldate = {2018-10-16},
  url = {http://www.cse.chalmers.se/~abela/talkAIM2008Sendai.pdf},
  author = {Abel, Andreas},
  month = nov,
  year = {2008},
  file = {/Users/doisinkidney/Zotero/storage/GQYYZM4K/Abel - Sized Types in Agda.pdf}
}

@article{danielsson_up-techniques_2017,
  title = {Up-to Techniques Using Sized Types},
  volume = {2},
  issn = {24751421},
  doi = {10.1145/3158131},
  language = {en},
  number = {POPL},
  urldate = {2018-10-16},
  journal = {Proceedings of the ACM on Programming Languages},
  url = {http://dl.acm.org/citation.cfm?doid=3177123.3158131},
  author = {Danielsson, Nils Anders},
  month = dec,
  year = {2017},
  pages = {1-28},
  file = {/Users/doisinkidney/Zotero/storage/E6LZEWWR/Danielsson - 2017 - Up-to techniques using sized types.pdf}
}

@article{danielsson_beating_2010,
  title = {Beating the {{Productivity Checker Using Embedded Languages}}},
  volume = {43},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.43.3},
  language = {en},
  urldate = {2018-10-16},
  journal = {Electronic Proceedings in Theoretical Computer Science},
  url = {http://arxiv.org/abs/1012.4898v1},
  author = {Danielsson, Nils Anders},
  month = dec,
  year = {2010},
  pages = {29-48},
  file = {/Users/doisinkidney/Zotero/storage/6M8A74JC/Danielsson - 2010 - Beating the Productivity Checker Using Embedded La.pdf}
}

@article{wadler_programming_nodate,
  title = {Programming {{Language Foundations}} in {{Agda}}},
  abstract = {One of the leading textbooks for formal methods is Software Foundations (SF), written by Benjamin Pierce in collaboration with others, and based on Coq. After five years using SF in the classroom, I have come to the conclusion that Coq is not the best vehicle for this purpose, as too much of the course needs to focus on learning tactics for proof derivation, to the cost of learning programming language theory. Accordingly, I have written a new textbook, Programming Language Foundations in Agda (PLFA). PLFA covers much of the same ground as SF, although it is not a slavish imitation.},
  language = {en},
  author = {Wadler, Philip},
  pages = {18},
  file = {/Users/doisinkidney/Zotero/storage/KYHSNBQ8/Wadler - Programming Language Foundations in Agda.pdf}
}

@incollection{hinze_turing-completeness_2015,
  address = {Cham},
  title = {Turing-{{Completeness Totally Free}}},
  volume = {9129},
  isbn = {978-3-319-19796-8 978-3-319-19797-5},
  abstract = {In this paper, I show that general recursive definitions can be represented in the free monad which supports the `effect' of making a recursive call, without saying how these calls should be executed. Diverse semantics can be given within a total framework by suitable monad morphisms. The Bove-Capretta construction of the domain of a general recursive function can be presented datatype-generically as an instance of this technique. The paper is literate Agda, but its key ideas are more broadly transferable.},
  language = {en},
  urldate = {2018-10-17},
  booktitle = {Mathematics of {{Program Construction}}},
  publisher = {{Springer International Publishing}},
  url = {http://link.springer.com/10.1007/978-3-319-19797-5_13},
  author = {McBride, Conor},
  editor = {Hinze, Ralf and Voigtl\"ander, Janis},
  year = {2015},
  pages = {257-275},
  file = {/Users/doisinkidney/Zotero/storage/NGRE4RGY/McBride - 2015 - Turing-Completeness Totally Free.pdf},
  doi = {10.1007/978-3-319-19797-5_13}
}

@phdthesis{girard_interpretation_1972,
  type = {{PhD Thesis}},
  title = {{Interpr\'etation fonctionelle et \'elimination des coupures de l'arithm\'etique d'ordre sup\'erieur}},
  language = {fr},
  school = {PhD thesis, Universit\'e Paris VII},
  author = {Girard, Jean-Yves},
  year = {1972},
  file = {/Users/doisinkidney/Zotero/storage/QLIN2G73/Girard - Interprétation fonctionnelle et élimination des co.pdf}
}

@article{zach_hilberts_2005,
  title = {Hilbert's {{Program Then}} and {{Now}}},
  doi = {10.1016/B978-044451541-4/50014-2},
  language = {en},
  urldate = {2018-11-13},
  url = {https://arxiv.org/abs/math/0508572},
  author = {Zach, Richard},
  month = aug,
  year = {2005},
  file = {/Users/doisinkidney/Zotero/storage/UDKTVSPU/Zach - 2005 - Hilbert's Program Then and Now.pdf;/Users/doisinkidney/Zotero/storage/FGBXZSY7/0508572.html}
}

@misc{might_missing_2015,
  title = {Missing Method: {{How}} to Delete from {{Okasaki}}'s Red-Black Trees},
  urldate = {2018-11-19},
  journal = {matt.might.net},
  url = {http://matt.might.net/articles/red-black-delete/},
  author = {Might, Matthew},
  month = nov,
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/3DCFH2UZ/red-black-delete.html}
}

@article{johann_haskell_nodate,
  title = {Haskell {{Programming}} with {{Nested Types}}: {{A Principled Approach}}},
  abstract = {Initial algebra semantics is one of the cornerstones of the theory of modern functional programming languages. For each inductive data type, it provides a Church encoding for that type, a build combinator which constructs data of that type, a fold combinator which encapsulates structured recursion over data of that type, and a fold/build rule which optimises modular programs by eliminating from them data constructed using the build combinator, and immediately consumed using the fold combinator, for that type. It has long been thought that initial algebra semantics is not expressive enough to provide a similar foundation for programming with nested types in Haskell. Specifically, the standard folds derived from initial algebra semantics have been considered too weak to capture commonly occurring patterns of recursion over data of nested types in Haskell, and no build combinators or fold/build rules have until now been defined for nested types. This paper shows that standard folds are, in fact, sufficiently expressive for programming with nested types in Haskell. It also defines build combinators and fold/build fusion rules for nested types. It thus shows how initial algebra semantics provides a principled, expressive, and elegant foundation for programming with nested types in Haskell.},
  language = {en},
  author = {Johann, Patricia and Ghani, Neil},
  pages = {48},
  file = {/Users/doisinkidney/Zotero/storage/3XNE6NQU/Johann and Ghani - Haskell Programming with Nested Types A Principle.pdf}
}

@phdthesis{bayley_generic_2001,
  type = {{{PhD Thesis}}},
  title = {Generic Operations on Nested Datatypes},
  school = {University of Oxford},
  author = {Bayley, Ian},
  year = {2001},
  file = {/Users/doisinkidney/Zotero/storage/NN39JBC3/Bayley - 2001 - Generic operations on nested datatypes.pdf}
}

@inproceedings{goos_nested_1998-1,
  address = {Berlin, Heidelberg},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Nested Datatypes},
  volume = {1422},
  isbn = {978-3-540-64591-7 978-3-540-69345-1},
  abstract = {A nested datatype, also known as a non-regular datatype, is a parametrised datatype whose declaration involves different instances of the accompanying type parameters. Nested datatypes have been mostly ignored in functional programming until recently, but they are turning out to be both theoretically important and useful in practice. The aim of this paper is to suggest a functorial semantics for such datatypes, with an associated calculational theory that mirrors and extends the standard theory for regular datatypes. Though elegant and generic, the proposed approach appears more limited than one would like, and some of the limitations are discussed.},
  language = {en},
  urldate = {2018-11-19},
  booktitle = {Mathematics of {{Program Construction}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {https://pdfs.semanticscholar.org/7f7b/0305ca441e3509750b24cff1f2b415d1020e.pdf},
  author = {Bird, Richard and Meertens, Lambert},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Jeuring, Johan},
  year = {1998},
  keywords = {Functional Programming,Functorial Semantic,Standard Semantic,Type Constructor,Type Nest},
  pages = {52-67},
  file = {/Users/doisinkidney/Zotero/storage/A4BNWD5F/Bird and Meertens - 1998 - Nested datatypes.pdf;/Users/doisinkidney/Zotero/storage/CPVGXSKB/Bird and Meertens - 1998 - Nested datatypes.pdf},
  doi = {10.1007/BFb0054285}
}

@book{mcbride_datatypes_2015,
  title = {Datatypes of {{Datatypes}}},
  author = {McBride, Conor},
  month = jul,
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/QKDM8YLS/conor.pdf}
}

@book{hinze_perfect_1999,
  title = {Perfect {{Trees}} and {{Bit}}-Reversal {{Permutations}}},
  abstract = {A famous algorithm is the Fast Fourier Transform, or FFT. An efficient iterative version of the FFT algorithm performs as a first step a bit-reversal permutation of the input list. The bit-reversal permutation swaps elements whose indices have binary representations that are the reverse of each other. Using an amortized approach this operation can be made to run in linear time on a random-access machine. An intriguing question is whether a linear-time implementation is also feasible on a pointer machine, that is in a purely functional setting. We show that the answer to this question is in the affirmative. In deriving a solution we employ several advanced programming language concepts such as nested datatypes, associated fold and unfold operators, rank-2 types, and polymorphic recursion. 1 Introduction A bit-reversal permutation operates on lists whose length is n = 2 k for some natural number k and swaps elements whose indices have binary representations that are the reverse of eac...},
  author = {Hinze, Ralf},
  year = {1999},
  file = {/Users/doisinkidney/Zotero/storage/4YL437LK/Hinze - 1999 - Perfect Trees and Bit-reversal Permutations.pdf;/Users/doisinkidney/Zotero/storage/36WDN5QJ/summary.html}
}

@article{breitner_ready_2018-1,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1803.06960},
  title = {Ready, {{Set}}, {{Verify}}! {{Applying Hs}}-to-Coq to {{Real}}-World {{Haskell Code}} ({{Experience Report}})},
  volume = {2},
  issn = {2475-1421},
  doi = {10.1145/3236784},
  abstract = {Good tools can bring mechanical verification to programs written in mainstream functional languages. We use hs-to-coq to translate significant portions of Haskell's containers library into Coq, and verify it against specifications that we derive from a variety of sources including type class laws, the library's test suite, and interfaces from Coq's standard library. Our work shows that it is feasible to verify mature, widely-used, highly optimized, and unmodified Haskell code. We also learn more about the theory of weight-balanced trees, extend hs-to-coq to handle partiality, and \textendash{} since we found no bugs \textendash{} attest to the superb quality of well-tested functional code.},
  number = {ICFP},
  urldate = {2018-11-19},
  journal = {Proc. ACM Program. Lang.},
  url = {http://doi.acm.org/10.1145/3236784},
  author = {Breitner, Joachim and {Spector-Zabusky}, Antal and Li, Yao and Rizkallah, Christine and Wiegley, John and Weirich, Stephanie},
  month = jul,
  year = {2018},
  keywords = {Computer Science - Programming Languages,Coq,Haskell,verification},
  pages = {89:1--89:16},
  file = {/Users/doisinkidney/Zotero/storage/47CZT66A/Breitner et al. - 2018 - Ready, Set, Verify! Applying hs-to-coq to real-wor.pdf;/Users/doisinkidney/Zotero/storage/CVI5SUYL/Breitner et al. - 2018 - Ready, Set, Verify! Applying Hs-to-coq to Real-wor.pdf;/Users/doisinkidney/Zotero/storage/JNAKLLCA/Breitner et al. - 2018 - Ready, Set, Verify! Applying Hs-to-coq to Real-wor.pdf;/Users/doisinkidney/Zotero/storage/MQGZJBF3/Breitner et al. - 2018 - Ready, Set, Verify! Applying hs-to-coq to real-wor.pdf;/Users/doisinkidney/Zotero/storage/W3P8LJJX/Breitner et al. - 2018 - Ready, Set, Verify! Applying Hs-to-coq to Real-wor.pdf;/Users/doisinkidney/Zotero/storage/3NXQ32D7/1803.html;/Users/doisinkidney/Zotero/storage/ERIANH6Y/1803.html}
}

@misc{erdi_basics_2012,
  title = {Basics for a Modular Arithmetic Type in {{Agda}}},
  urldate = {2018-11-19},
  journal = {Cactus},
  url = {https://gergo.erdi.hu/blog/2012-03-11-basics_for_a_modular_arithmetic_type_in_agda/},
  author = {\'Erdi, Gerg{\H o}},
  month = mar,
  year = {2012},
  file = {/Users/doisinkidney/Zotero/storage/HRLQEN6M/2012-03-11-basics_for_a_modular_arithmetic_type_in_agda.html}
}

@misc{erdi_mod-n_2012,
  title = {Mod-{{N}} Counters in {{Agda}}},
  urldate = {2018-11-19},
  journal = {Cactus},
  url = {https://gergo.erdi.hu/blog/2012-02-19-mod-n_counters_in_agda/},
  author = {\'Erdi, Gerg{\H o}},
  month = feb,
  year = {2012},
  file = {/Users/doisinkidney/Zotero/storage/L2NKVBUF/2012-02-19-mod-n_counters_in_agda.html}
}

@misc{komuves_nested-sequence_2016,
  title = {Nested-Sequence: {{List}}-like Data Structures with {{O}}(Log(n)) Random Access},
  shorttitle = {Nested-Sequence},
  abstract = {List-like data structures implemented using nested data types and polymorphic recursion. Also called "n-ary random access lists". They supports O(log(n)) lookup while still having amortized O(1) access to the left end of the sequence. Somewhat similar to finger trees, but much simpler, and the ternary and quaternary versions are also more memory efficient; however, modifying the right end of the sequence is still slow. See Data.Nested.Seq for general comments and Data.Nested.Seq.Binary.Lazy for an explanation of the data structure.},
  urldate = {2018-11-19},
  url = {http://hackage.haskell.org/package/nested-sequence},
  author = {Komuves, Balazs and Divianszky, Peter},
  month = jul,
  year = {2016},
  file = {/Users/doisinkidney/Zotero/storage/TZ3MQZRN/nested-sequence.html}
}

@article{ben-amram_pointers_1992,
  title = {On {{Pointers Versus Addresses}}},
  volume = {39},
  issn = {0004-5411},
  doi = {10.1145/146637.146666},
  number = {3},
  urldate = {2018-11-19},
  journal = {J. ACM},
  url = {http://doi.acm.org/10.1145/146637.146666},
  author = {{Ben-Amram}, Amir M. and Galil, Zvi},
  month = jul,
  year = {1992},
  keywords = {incompressibility,pointer structures,random access memory},
  pages = {617--648},
  file = {/Users/doisinkidney/Zotero/storage/FK6IETSX/Ben-Amram and Galil - 1992 - On Pointers Versus Addresses.pdf}
}

@book{okasaki_purely_1999,
  title = {Purely {{Functional Data Structures}}},
  isbn = {978-0-521-66350-2},
  abstract = {Most books on data structures assume an imperative language such as C or C++. However, data structures for these languages do not always translate well to functional languages such as Standard ML, Haskell, or Scheme. This book describes data structures from the point of view of functional languages, with examples, and presents design techniques that allow programmers to develop their own functional data structures. The author includes both classical data structures, such as red-black trees and binomial queues, and a host of new data structures developed exclusively for functional languages. All source code is given in Standard ML and Haskell, and most of the programs are easily adaptable to other functional languages. This handy reference for professional programmers working with functional languages can also be used as a tutorial or for self-study.},
  language = {en},
  publisher = {{Cambridge University Press}},
  author = {Okasaki, Chris},
  month = jun,
  year = {1999},
  keywords = {Computers / Databases / General,Computers / Programming Languages / General,Computers / Software Development \& Engineering / General}
}

@misc{weirich_dependent_2017,
  address = {St. Louis, MO, USA},
  title = {Dependent {{Types}} in {{Haskell}}},
  abstract = {What has dependent type theory done for Haskell? Over the past ten years, the Glasgow Haskell compiler (GHC) has adopted many type system features inspired by dependent type theory. In this talk, I will discuss the influence of dependent types on the design of GHC and on the practice of Haskell programmers. In particular, I will walk through an extended example and use it to analyze what it means to program with with dependent types in Haskell. Throughout, I will will discuss what we have learned from this experiment in language design: what works now, what doesn't work yet, and what surprised us along the way.},
  urldate = {2018-11-19},
  url = {https://www.youtube.com/watch?v=wNa3MMbhwS4},
  author = {Weirich, Stephanie},
  month = sep,
  year = {2017}
}

@inproceedings{otwani_thoralf_2018,
  address = {New York, NY, USA},
  series = {Haskell 2018},
  title = {The {{Thoralf Plugin}}: {{For Your Fancy Type Needs}}},
  isbn = {978-1-4503-5835-4},
  shorttitle = {The {{Thoralf Plugin}}},
  doi = {10.1145/3242744.3242754},
  abstract = {Many fancy types (e.g., generalized algebraic data types, type families) require a type checker plugin. These fancy types have a type index (e.g., type level natural numbers) with an equality relation that is difficult or impossible to represent using GHC's built-in type equality. The most practical way to represent these equality relations is through a plugin that asserts equality constraints. However, such plugins are difficult to write and reason about.   In this paper, we (1) present a formal theory of reasoning about the correctness of type checker plugins for type indices, and, (2) apply this theory in creating Thoralf, a generic and extensible plugin for type indices that translates GHC constraint problems to queries to an external SMT solver. By "generic and extensible", we mean the restrictions on extending Thoralf are slight, and, if some type index could be encoded as an SMT sort, then a programmer could extend Thoralf by providing this encoding function.},
  urldate = {2018-11-21},
  booktitle = {Proceedings of the 11th {{ACM SIGPLAN International Symposium}} on {{Haskell}}},
  publisher = {{ACM}},
  url = {http://doi.acm.org/10.1145/3242744.3242754},
  author = {Otwani, Divesh and Eisenberg, Richard A.},
  year = {2018},
  keywords = {SMT,GHC,constraint solver,type checker plugin},
  pages = {106--118}
}

@article{danielsson_total_nodate,
  title = {Total {{Definitional Interpreters}} for {{Time}} and {{Space Complexity}}},
  language = {en},
  author = {Danielsson, Nils Anders},
  pages = {13},
  file = {/Users/doisinkidney/Zotero/storage/EVARU4C7/Danielsson - Total Definitional Interpreters for Time and Space.pdf}
}

@misc{wiedijk_formalizing_2018,
  title = {Formalizing 100 {{Theorems}}},
  abstract = {There used to exist a "top 100" of mathematical theorems on the web, which is a rather arbitrary list (and most of the theorems seem rather elementary), but still is nice to look at. On the current page I will keep track of which theorems from this list have been formalized. Currently the fraction that already has been formalized seems to be
93\%

The page does not keep track of all formalizations of these theorems. It just shows formalizations in systems that have formalized a significant number of theorems, or that have formalized a theorem that none of the others have done. The systems that this page refers to are (in order of the number of theorems that have been formalized, so the more interesting systems for mathematics are near the top):
HOL Light 	86
Isabelle 	80
Coq 	69
Mizar 	69
Metamath 	69
ProofPower 	43
nqthm/ACL2 	18
PVS 	16
NuPRL/MetaPRL 	8

Theorems in the list which have not been formalized yet are in italics. Formalizations of constructive proofs are in italics too. The difficult proofs in the list (according to John all the others are not a serious challenge "given a week or two") have been underlined. The formalizations under a theorem are in the order of the list of systems, and not in chronological order.},
  urldate = {2018-11-27},
  url = {http://www.cs.ru.nl/~freek/100/},
  author = {Wiedijk, Freek},
  month = oct,
  year = {2018},
  file = {/Users/doisinkidney/Zotero/storage/9H2EFAFC/100.html}
}

@book{megill_metamath_2007,
  address = {Morrisville},
  title = {Metamath: A Computer Language for Pure Mathematics},
  isbn = {978-1-4116-3724-5},
  shorttitle = {Metamath},
  language = {en},
  publisher = {{Lulu Press}},
  author = {Megill, Norman},
  year = {2007},
  file = {/Users/doisinkidney/Zotero/storage/PRRBLF3A/Megill - 2007 - Metamath a computer language for pure mathematics.pdf},
  note = {OCLC: 924789462}
}

@article{loh_tutorial_2010,
  title = {A {{Tutorial Implementation}} of a {{Dependently Typed Lambda Calculus}}},
  volume = {102},
  issn = {0169-2968},
  abstract = {We present the type rules for a dependently typed core calculus together with a straightforward implementation in Haskell. We explicitly highlight the changes necessary to shift from a simply-typed lambda calculus to the dependently typed lambda calculus. We also describe how to extend our core language with data types and write several small example programs. The article is accompanied by an executable interpreter and example code that allows immediate experimentation with the system we describe.},
  language = {en},
  number = {2},
  urldate = {2018-11-30},
  journal = {Fundamenta Informaticae},
  url = {https://www.andres-loeh.de/LambdaPi/},
  author = {L\"oh, Andres and McBride, Conor and Swierstra, Wouter},
  month = jan,
  year = {2010},
  pages = {177-207},
  file = {/Users/doisinkidney/Zotero/storage/W8UML2IR/Loh et al. - A tutorial implementation of a dependently typed l.pdf}
}

@inproceedings{boutin_using_1997,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Using Reflection to Build Efficient and Certified Decision Procedures},
  isbn = {978-3-540-69530-1},
  abstract = {In this paper we explain how computational reflection can help build efficient certified decision procedure in reduction systems. We have developed a decision procedure on abelian rings in the Coq system but the approach we describe applies to all reduction systems that allow the definition of concrete types (or datatypes). We show that computational reflection is more efficient than an LCF-like approach to implement decision procedures in a reduction system. We discuss the concept of total reflection, which we have investigated in Coq using two facts: the extraction process available in Coq and the fact that the implementation language of the Coq system can be considered as a sublanguage of Coq. Total reflection is not yet implemented in Coq but we can test its performance as the extraction process is effective. Both reflection and total reflection are conservative extensions of the reduction system in which they are used. We also discuss performance and related approaches. In the paper,we assume basic knowledges of ML and proof-checkers.},
  language = {en},
  booktitle = {Theoretical {{Aspects}} of {{Computer Software}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Boutin, Samuel},
  editor = {Abadi, Mart\'in and Ito, Takayasu},
  year = {1997},
  keywords = {Computer Algebra System,Decision Procedure,Object Language,Order Theory,Reduction System},
  pages = {515-529},
  file = {/Users/doisinkidney/Zotero/storage/F9JMVUGU/Boutin - 1997 - Using reflection to build efficient and certified .pdf}
}

@book{Coq:manual,
  title = {The {{Coq Proof Assistant Reference Manual}}, Version 7.2},
  url = {http://coq.inria.fr},
  author = {Coq Development Team, The},
  year = {2002}
}

@book{peyton_jones_haskell_2003,
  address = {Cambridge, U.K. ; New York},
  title = {Haskell 98 Language and Libraries: The Revised Report},
  isbn = {978-0-521-82614-3},
  lccn = {QA76.73.H37 H37 2003},
  shorttitle = {Haskell 98 Language and Libraries},
  publisher = {{Cambridge University Press}},
  editor = {Peyton Jones, Simon L.},
  year = {2003},
  keywords = {Haskell (Computer program language)},
  note = {OCLC: ocm51271691}
}

@article{wadler_programming_nodate-1,
  title = {Programming {{Language Foundations}} in {{Agda}}},
  abstract = {One of the leading textbooks for formal methods is Software Foundations (SF), written by Benjamin Pierce in collaboration with others, and based on Coq. After five years using SF in the classroom, I have come to the conclusion that Coq is not the best vehicle for this purpose, as too much of the course needs to focus on learning tactics for proof derivation, to the cost of learning programming language theory. Accordingly, I have written a new textbook, Programming Language Foundations in Agda (PLFA). PLFA covers much of the same ground as SF, although it is not a slavish imitation.},
  language = {en},
  author = {Wadler, Philip},
  pages = {18},
  file = {/Users/doisinkidney/Zotero/storage/9JWDH3DW/Wadler - Programming Language Foundations in Agda.pdf}
}

@article{swierstra_verifying_2011,
  title = {Verifying the {{Problem}} of the {{Dutch National Flag}} in {{Agda}}},
  language = {en},
  author = {Swierstra, Wouter},
  year = {2011},
  pages = {12},
  file = {/Users/doisinkidney/Zotero/storage/AW25ZTCW/Swierstra - 2011 - Verifying the Problem of the Dutch National Flag i.pdf}
}

@article{antoy_proving_2017,
  title = {Proving {{Non}}-{{Deterministic Computations}} in {{Agda}}},
  volume = {234},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.234.13},
  language = {en},
  urldate = {2018-12-17},
  journal = {Electronic Proceedings in Theoretical Computer Science},
  url = {http://arxiv.org/abs/1701.00636},
  author = {Antoy, Sergio and Hanus, Michael and Libby, Steven},
  month = jan,
  year = {2017},
  pages = {180-195},
  file = {/Users/doisinkidney/Zotero/storage/74HVVLN7/Antoy et al. - 2017 - Proving Non-Deterministic Computations in Agda.pdf}
}

@inproceedings{copello_case_2014,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Case of ({{Quite}}) {{Painless Dependently Typed Programming}}: {{Fully Certified Merge Sort}} in {{Agda}}},
  isbn = {978-3-319-11863-5},
  shorttitle = {Case of ({{Quite}}) {{Painless Dependently Typed Programming}}},
  abstract = {We present a full certification of merge sort in the language Agda. It features: termination warrant without explicit proof, no proof cost to ensure that the output is sorted, and a succinct proof that the output is a permutation of the input.},
  language = {en},
  booktitle = {Programming {{Languages}}},
  publisher = {{Springer International Publishing}},
  author = {Copello, Ernesto and Tasistro, \'Alvaro and Bianchi, Bruno},
  editor = {Quint\~ao Pereira, Fernando Magno},
  year = {2014},
  keywords = {Executable Code,Proof Obligation,Recursive Call,Termination Proof,Type Check},
  pages = {62-76},
  file = {/Users/doisinkidney/Zotero/storage/USMHHAXV/Copello et al. - 2014 - Case of (Quite) Painless Dependently Typed Program.pdf}
}

@article{meshveliani_provable_nodate,
  title = {Provable Programming of Algebra: Particular Points, Examples.},
  abstract = {It is discussed an experience in provable programming of a computer algebra library with using a purely functional language with dependent types (Agda). There are given several examples illustrating particular points of implementing the approach of constructive mathematics.},
  language = {en},
  author = {Meshveliani, Sergei D},
  pages = {5},
  file = {/Users/doisinkidney/Zotero/storage/NS5Q2FTS/Meshveliani - Provable programming of algebra particular points.pdf}
}

@article{dagand_essence_2017,
  title = {The Essence of Ornaments},
  volume = {27},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796816000356},
  abstract = {Functional programmers from all horizons strive to use, and sometimes abuse, their favorite type system in order to capture the invariants of their programs. A widely used tool in that trade consists in defining finely indexed datatypes. Operationally, these types classify the programmer's data, following the ML tradition. Logically, these types enforce the program invariants in a novel manner. This new programming pattern, by which one programs over inductive definitions to account for some invariants, lead to the development of a theory of ornaments (McBride, 2011 Ornamental Algebras, Algebraic Ornaments. Unpublished). However, ornaments originate as a dependently-typed object and may thus appear rather daunting to a functional programmer of the non-dependent kind. This article aims at presenting ornaments from first-principles and, in particular, to declutter their presentation from syntactic considerations. To do so, we shall give a sufficiently abstract model of indexed datatypes by means of many-sorted signatures. In this process, we formalize our intuition that an indexed datatype is the combination of a data-structure and a data-logic. Over this abstraction of datatypes, we shall recast the definition of ornaments, effectively giving a model of ornaments. Benefiting both from the operational and abstract nature of many-sorted signatures, ornaments should appear applicable and, one hopes, of interest beyond the type-theoretic circles, case in point being languages with generalized abstract datatypes or refinement types.},
  language = {en},
  urldate = {2019-01-11},
  journal = {Journal of Functional Programming},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/essence-of-ornaments/4D2DF6F4FE23599C8C1FEA6C921A3748},
  author = {Dagand, Pierre-Evariste},
  year = {2017/ed},
  file = {/Users/doisinkidney/Zotero/storage/TLH8A8K7/4D2DF6F4FE23599C8C1FEA6C921A3748.html}
}

@misc{the_development_team_step-by-step_2009,
  title = {Step-by-{{Step Math}}},
  language = {en},
  urldate = {2019-01-12},
  journal = {Wolfram|Alpha Blog},
  url = {http://blog.wolframalpha.com/2009/12/01/step-by-step-math/},
  author = {{The Development Team}},
  month = dec,
  year = {2009},
  file = {/Users/doisinkidney/Zotero/storage/AJUGXPVM/step-by-step-math.html}
}

@misc{wolfram_research_inc._wolframalpha_2019,
  title = {Wolfram|{{Alpha}}},
  urldate = {2019-01-12},
  howpublished = {Wolfram Research, Inc.},
  url = {https://www.wolframalpha.com/},
  author = {{Wolfram Research, Inc.}},
  year = {2019}
}

@misc{kahl_hundred_2004,
  title = {The {{Hundred Greatest Theorems}}},
  abstract = {The millenium seemed to spur a lot of people to compile "Top 100" or "Best 100" lists of many things, including movies (by the American Film Institute) and books (by the Modern Library). Mathematicians were not immune, and at a mathematics conference in July, 1999, Paul and Jack Abad presented their list of "The Hundred Greatest Theorems." Their ranking is based on the following criteria: "the place the theorem holds in the literature, the quality of the proof, and the unexpectedness of the result."

The list is of course as arbitrary as the movie and book list, but the theorems here are all certainly worthy results. I hope to over time include links to the proofs of them all; for now, you'll have to content yourself with the list itself and the biographies of the principals.},
  urldate = {2019-01-13},
  url = {http://web.archive.org/web/20080105074243/http://personal.stevens.edu/~nkahl/Top100Theorems.html},
  author = {Kahl, Nathan W.},
  year = {2004},
  file = {/Users/doisinkidney/Zotero/storage/44SQ7P3J/Top100Theorems.html}
}

@inproceedings{osera_programming_2016,
  address = {New York, NY, USA},
  series = {{{TyDe}} 2016},
  title = {Programming {{Assistance}} for {{Type}}-Directed {{Programming}} ({{Extended Abstract}})},
  isbn = {978-1-4503-4435-7},
  doi = {10.1145/2976022.2976027},
  abstract = {Type-directed programming is a powerful programming paradigm where rich types dictate the structure of the program, making design largely automatic. While mechanical, this paradigm still requires manual reasoning that is both tedious and error-prone. We propose using type-directed program synthesis techniques to build an interactive programming assistant for type-directed programming. This tool bridges the gaps between simple auto-completion engines and program synthesis, complementing the strengths of each.},
  urldate = {2019-01-15},
  booktitle = {Proceedings of the 1st {{International Workshop}} on {{Type}}-{{Driven Development}}},
  publisher = {{ACM}},
  url = {http://doi.acm.org/10.1145/2976022.2976027},
  author = {Osera, Peter-Michael},
  year = {2016},
  keywords = {Program Synthesis,Type-directed Programming},
  pages = {56--57}
}

@inproceedings{osera_programming_2016-1,
  address = {Nara, Japan},
  title = {Programming Assistance for Type-Directed Programming (Extended Abstract)},
  isbn = {978-1-4503-4435-7},
  doi = {10.1145/2976022.2976027},
  abstract = {Type-directed programming is a powerful programming paradigm where rich types dictate the structure of the program, making design largely automatic. While mechanical, this paradigm still requires manual reasoning that is both tedious and error-prone. We propose using type-directed program synthesis techniques to build an interactive programming assistant for type-directed programming. This tool bridges the gaps between simple auto-completion engines and program synthesis, complementing the strengths of each.},
  language = {en},
  urldate = {2019-01-15},
  booktitle = {Proceedings of the 1st {{International Workshop}} on {{Type}}-{{Driven Development}} - {{TyDe}} 2016},
  publisher = {{ACM Press}},
  url = {http://dl.acm.org/citation.cfm?doid=2976022.2976027},
  author = {Osera, Peter-Michael},
  year = {2016},
  pages = {56-57},
  file = {/Users/doisinkidney/Zotero/storage/RJ53MDBI/Osera - 2016 - Programming assistance for type-directed programmi.pdf}
}

@inproceedings{sandberg_eriksson_agda_2016,
  address = {Nara, Japan},
  title = {An Agda Formalisation of the Transitive Closure of Block Matrices (Extended Abstract)},
  isbn = {978-1-4503-4435-7},
  doi = {10.1145/2976022.2976025},
  abstract = {We define a block based matrix representation in Agda and lift various algebraic structures (semi-near-rings, semi-rings and closed semi-rings) to matrices in order to verify algorithms that can be implemented using the closure operation in a semi-ring.},
  language = {en},
  urldate = {2019-01-15},
  booktitle = {Proceedings of the 1st {{International Workshop}} on {{Type}}-{{Driven Development}} - {{TyDe}} 2016},
  publisher = {{ACM Press}},
  url = {http://dl.acm.org/citation.cfm?doid=2976022.2976025},
  author = {Sandberg Eriksson, Adam and Jansson, Patrik},
  year = {2016},
  pages = {60-61},
  file = {/Users/doisinkidney/Zotero/storage/GDBW8VYF/Sandberg Eriksson and Jansson - 2016 - An agda formalisation of the transitive closure of.pdf}
}

@inproceedings{paykin_choose_2016,
  address = {Nara, Japan},
  title = {Choose Your Own Derivative (Extended Abstract)},
  isbn = {978-1-4503-4435-7},
  doi = {10.1145/2976022.2976024},
  language = {en},
  urldate = {2019-01-15},
  booktitle = {Proceedings of the 1st {{International Workshop}} on {{Type}}-{{Driven Development}} - {{TyDe}} 2016},
  publisher = {{ACM Press}},
  url = {http://dl.acm.org/citation.cfm?doid=2976022.2976024},
  author = {Paykin, Jennifer and {Spector-Zabusky}, Antal and Foner, Kenneth},
  year = {2016},
  pages = {58-59},
  file = {/Users/doisinkidney/Zotero/storage/7P3JCCPE/Paykin et al. - 2016 - choose your own derivative (extended abstract).pdf}
}

@inproceedings{diehl_generic_2016,
  title = {Generic Lookup and Update for Infinitary Inductive-Recursive Types},
  isbn = {978-1-4503-4435-7},
  doi = {10.1145/2976022.2976031},
  urldate = {2019-01-15},
  booktitle = {Proceedings of the 1st {{International Workshop}} on {{Type}}-{{Driven Development}}},
  publisher = {{ACM}},
  url = {http://dl.acm.org/citation.cfm?id=2976022.2976031},
  author = {Diehl, Larry and Sheard, Tim},
  month = sep,
  year = {2016},
  pages = {1-12}
}

@inproceedings{lindblad_tool_2006,
  address = {Berlin, Heidelberg},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {A {{Tool}} for {{Automated Theorem Proving}} in {{Agda}}},
  volume = {3839},
  isbn = {978-3-540-31429-5},
  abstract = {We present a tool for automated theorem proving in Agda, an implementation of Martin-L\"of's intuitionistic type theory. The tool is intended to facilitate interactive proving by relieving the user from filling in simple but tedious parts of a proof. The proof search is conducted directly in type theory and produces proof terms. Any proof term is verified by the Agda type-checker, which ensures soundness of the tool. Some effort has been spent on trying to produce human readable results, which allows the user to examine the generated proofs. We have tested the tool on examples mainly in the area of (functional) program verification. Most examples we have considered contain induction, and some contain generalisation. The contribution of this work outside the Agda community is to extend the experience of automated proof for intuitionistic type theory.},
  language = {en},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {https://pdfs.semanticscholar.org/58e3/fa23cabe27915bc467994efd3f1fbd2143a5.pdf},
  author = {Lindblad, Fredrik and Benke, Marcin},
  editor = {Filli\^atre, Jean-Christophe and {Paulin-Mohring}, Christine and Werner, Benjamin},
  year = {2006},
  keywords = {Elimination Rule,Type Theory,Logical Framework,Meta Variable,Proof Assistant},
  pages = {154-169},
  file = {/Users/doisinkidney/Zotero/storage/BNCI9EYW/Lindblad and Benke - 2006 - A Tool for Automated Theorem Proving in Agda.pdf},
  doi = {10.1007/11617990_10}
}

@misc{noauthor_running_nodate,
  title = {Running the Classical Pigeonhole Principle in {{Agda}}},
  urldate = {2019-01-27},
  url = {http://www.cs.bham.ac.uk/~mhe/pigeon/},
  file = {/Users/doisinkidney/Zotero/storage/7U4XW4DX/pigeon.html}
}

@article{escardo_programs_nodate,
  title = {Programs from {{Proofs III Classical}} Countable Choice via Products of Selection Functions},
  language = {en},
  author = {Escardo, Mart\i{}n},
  pages = {53},
  file = {/Users/doisinkidney/Zotero/storage/EYSSR2J2/Escardo - Programs from Proofs III Classical countable choic.pdf}
}

@unpublished{allais_deciding_2011,
  title = {Deciding {{Presburger}} Arithmetic Using Reflection},
  abstract = {The need to prove or disprove a formula of Presburger arithmetic is quite frequent in certified software development (constraints generated automatically) or when working on higher arithmetic (number theory). The fact that this theory is decidable and that Agda is now mature enough to be able to implement such a solver pushed us to try to tackle this problem.},
  language = {en},
  url = {https://gallais.github.io/pdf/presburger10.pdf},
  author = {Allais, G},
  month = may,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/564IKBT9/Allais - Deciding Presburger arithmetic using reﬂection.pdf}
}

@article{gilbert_definitional_2019,
  title = {Definitional {{Proof}}-{{Irrelevance}} without {{K}}},
  doi = {10.1145/329031610.1145/3290316},
  abstract = {Definitional equality\textemdash{}or conversion\textemdash{}for a type theory with a decidable type checking is the simplest tool to prove that two objects are the same, letting the system decide just using computation. Therefore, the more things are equal by conversion, the simpler it is to use a language based on type theory. Proof-irrelevance, stating that any two proofs of the same proposition are equal, is a possible way to extend conversion to make a type theory more powerful. However, this new power comes at a price if we integrate it naively, either by making type checking undecidable or by realizing new axioms\textemdash{}such as uniqueness of identity proofs (UIP)\textemdash{}that are incompatible with other extensions, such as univalence. In this paper, taking inspiration from homotopy type theory, we propose a general way to extend a type theory with definitional proof irrelevance, in a way that keeps type checking decidable and is compatible with univalence. We provide a new criterion to decide whether a proposition can be eliminated over a type (correcting and improving the so-called singleton elimination of Coq) by using techniques coming from recent development on dependent pattern matching without UIP. We show the generality of our approach by providing implementations for both Coq and Agda, both of which are planned to be integrated in future versions of those proof assistants.},
  language = {en},
  urldate = {2019-02-18},
  journal = {Proceedings of the ACM on Programming Languages},
  url = {https://hal.inria.fr/hal-01859964/document},
  author = {Gilbert, Ga\"etan and Cockx, Jesper and Sozeau, Matthieu and Tabareau, Nicolas},
  month = jan,
  year = {2019},
  pages = {1-28},
  file = {/Users/doisinkidney/Zotero/storage/M2BHRXQ2/Gilbert et al. - 2019 - Definitional Proof-Irrelevance without K.pdf;/Users/doisinkidney/Zotero/storage/W2JCHYP3/hal-01859964.html}
}

@book{jones_scipy_2001,
  title = {{{SciPy}}: {{Open}} Source Scientific Tools for {{Python}}},
  url = {http://www.scipy.org/},
  author = {Jones, Eric and Oliphant, Travis and Peterson, Pearu and others},
  year = {2001}
}

@book{r_core_team_r_2013,
  address = {Vienna, Austria},
  title = {R: {{A Language}} and {{Environment}} for {{Statistical Computing}}},
  publisher = {{R Foundation for Statistical Computing}},
  url = {http://www.R-project.org/},
  author = {{R Core Team}},
  year = {2013}
}

@article{danielsson_total_nodate-1,
  title = {Total {{Definitional Interpreters}} for {{Time}} and {{Space Complexity}}},
  language = {en},
  author = {Danielsson, Nils Anders},
  pages = {13},
  file = {/Users/doisinkidney/Zotero/storage/U7Q7J7DD/Danielsson - Total Definitional Interpreters for Time and Space.pdf}
}

@article{mahboubi_machine-checked_2016,
  title = {Machine-Checked Mathematics},
  volume = {5/17},
  abstract = {In this article she gives an overview about machine-checked mathematics.},
  language = {en},
  number = {3},
  urldate = {2019-02-21},
  journal = {Nieuw Archief voor Wiskunde},
  url = {https://hal.inria.fr/hal-01363284/document},
  author = {Mahboubi, Assia},
  month = sep,
  year = {2016},
  pages = {5},
  file = {/Users/doisinkidney/Zotero/storage/K4YFJJ3Y/Mahboubi - 2016 - Machine-checked mathematics.pdf;/Users/doisinkidney/Zotero/storage/33SI4PH7/hal-01363284.html}
}

@inproceedings{mahboubi_canonical_2013,
  title = {Canonical {{Structures}} for the Working {{Coq}} User},
  volume = {7998},
  doi = {10.1007/978-3-642-39634-2_5},
  abstract = {This paper provides a gentle introduction to the art of programming type inference with the mechanism of Canonical Structures. Programmable type inference has been one of the key ingredients for the successful formalization of the Odd Order Theorem using the Coq proof assistant. The paper concludes comparing the language of Canonical Structures to the one of Type Classes and Unification Hints.},
  language = {en},
  urldate = {2019-02-21},
  booktitle = {{{ITP}} 2013, 4th {{Conference}} on {{Interactive Theorem Proving}}},
  publisher = {{Springer}},
  url = {https://hal.inria.fr/hal-00816703/document},
  author = {Mahboubi, Assia and Tassi, Enrico},
  month = jul,
  year = {2013},
  pages = {19-34},
  file = {/Users/doisinkidney/Zotero/storage/3NBZE3DT/Mahboubi and Tassi - 2013 - Canonical Structures for the working Coq user.pdf;/Users/doisinkidney/Zotero/storage/R7NZ7LRQ/hal-00816703v2.html}
}

@article{hudson_certified_2015,
  title = {Certified {{Cost Bounds}} in {{Agda}}: {{A Step Towards Automated Complexity Analysis}}},
  shorttitle = {Certified {{Cost Bounds}} in {{Agda}}},
  journal = {Honors Theses - All},
  url = {https://wesscholar.wesleyan.edu/etd_hon_theses/1484},
  author = {Hudson, Bowornmet},
  month = apr,
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/66ZL8F5E/1484.html}
}

@inproceedings{sozeau_program-ing_2007,
  address = {New York, NY, USA},
  series = {{{ICFP}} '07},
  title = {Program-Ing {{Finger Trees}} in {{Coq}}},
  isbn = {978-1-59593-815-2},
  doi = {10.1145/1291151.1291156},
  abstract = {Finger Trees (Hinze \& Paterson, 2006) are a general purpose persistent data structure with good performance. Their genericity permits developing a wealth of structures like ordered sequences or interval trees on top of a single implementation. However, the type systems used by current functional languages do not guarantee the coherent parameterization and specialization of Finger Trees, let alone the correctness of their implementation. We present a certified implementation of Finger Trees solving these problems using the Program extension of Coq. We not only implement the structure but also prove its invariants along the way, which permit building certified structures on top of Finger Trees in an elegant way.},
  language = {en},
  urldate = {2019-02-23},
  booktitle = {Proceedings of the 12th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  publisher = {{ACM}},
  url = {https://www.irif.fr/~sozeau/research/publications/Program-ing_Finger_Trees_in_Coq.pdf},
  author = {Sozeau, Matthieu},
  year = {2007},
  keywords = {dependent types,C<scp>oq</scp>,certification,finger trees},
  pages = {13--24},
  file = {/Users/doisinkidney/Zotero/storage/UCNWHJF9/Sozeau - Program-ing Finger Trees in Coq.pdf}
}

@article{alvarez-picallo_change_2019,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1902.05465},
  primaryClass = {cs},
  title = {Change {{Actions}}: {{Models}} of {{Generalised Differentiation}}},
  shorttitle = {Change {{Actions}}},
  abstract = {Cai et al. have recently proposed change structures as a semantic framework for incremental computation. We generalise change structures to arbitrary cartesian categories and propose the notion of change action model as a categorical model for (higher-order) generalised differentiation. Change action models naturally arise from many geometric and computational settings, such as (generalised) cartesian differential categories, group models of discrete calculus, and Kleene algebra of regular expressions. We show how to build canonical change action models on arbitrary cartesian categories, reminiscent of the F\textbackslash{}`aa di Bruno construction.},
  urldate = {2019-02-25},
  journal = {arXiv:1902.05465 [cs]},
  url = {http://arxiv.org/abs/1902.05465},
  author = {{Alvarez-Picallo}, Mario and Ong, C.-H. Luke},
  month = feb,
  year = {2019},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/Users/doisinkidney/Zotero/storage/STD7IWA7/Alvarez-Picallo and Ong - 2019 - Change Actions Models of Generalised Differentiat.pdf;/Users/doisinkidney/Zotero/storage/JCD8WGLB/1902.html}
}

@article{alvarez-picallo_fixing_2018,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1811.06069},
  primaryClass = {cs},
  title = {Fixing {{Incremental Computation}}: {{Derivatives}} of {{Fixpoints}}, and the {{Recursive Semantics}} of {{Datalog}}},
  shorttitle = {Fixing {{Incremental Computation}}},
  abstract = {Incremental computation has recently been studied using the concepts of change structures and derivatives of programs, where the derivative of a function allows updating the output of the function based on a change to its input. We generalise change structures to change actions, and study their algebraic properties. We develop change actions for common structures in computer science, including directed-complete partial orders and Boolean algebras. We then show how to compute derivatives of fixpoints. This allows us to perform incremental evaluation and maintenance of recursively defined functions with particular application to generalised Datalog programs. Moreover, unlike previous results, our techniques are modular in that they are easy to apply both to variants of Datalog and to other programming languages.},
  urldate = {2019-02-25},
  journal = {arXiv:1811.06069 [cs]},
  url = {http://arxiv.org/abs/1811.06069},
  author = {{Alvarez-Picallo}, Mario and {Eyers-Taylor}, Alex and Jones, Michael Peyton and Ong, C.-H. Luke},
  month = nov,
  year = {2018},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/doisinkidney/Zotero/storage/DRLGGEHA/Alvarez-Picallo et al. - 2018 - Fixing Incremental Computation Derivatives of Fix.pdf;/Users/doisinkidney/Zotero/storage/HZVQ5KSF/1811.html}
}


