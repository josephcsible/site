
@article{okasaki_three_1997,
  title = {Three {{Algorithms}} on {{Braun Trees}}},
  volume = {7},
  issn = {0956-7968},
  doi = {10.1017/S0956796897002876},
  abstract = {Among the many flavours of balanced binary trees, Braun trees (Braun and Rem, 1983) are perhaps the most circumscribed. For any given node of a Braun tree, the left subtree is either exactly the same size as the right subtree, or one element larger. Braun trees always have minimum height, and the shape of each Braun tree is completely determined by its size. In return for this rigor, algorithms that manipulate Braun trees are often exceptionally simple and elegant, and need not maintain any explicit balance information.Braun trees have been used to implement both flexible arrays (Braun and Rem, 1983; Hoogerwoord, 1992; Paulson, 1996) and priority queues (Paulson, 1996; Bird, 1996). Most operations involving a single element (e.g. adding, removing, inspecting or updating an element) take O(log n) time, since the trees are balanced. We consider three algorithmically interesting operations that manipulate entire trees. First, we give an O(log2 n) algorithm for calculating the size of a tree. Second, we show how to create a tree containing n copies of some element x in O(log n) time. Finally, we describe an order-preserving algorithm for converting a list to a tree in O(n) time. This last operation is not nearly as straightforward as it sounds!},
  number = {6},
  urldate = {2017-04-11},
  journal = {Journal of Functional Programming},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/three-algorithms-on-braun-trees/59CF6B17F75EC216EBCA8A08E8780DFF},
  author = {Okasaki, Chris},
  month = nov,
  year = {1997},
  pages = {661--666},
  file = {/Users/doisinkidney/Zotero/storage/BZAMGNE6/three-algorithms-on-braun-trees.pdf;/Users/doisinkidney/Zotero/storage/7C5PEIN4/59CF6B17F75EC216EBCA8A08E8780DFF.html}
}

@inproceedings{lampropoulos_ode_2017,
  title = {Ode on a Random Urn (Functional Pearl)},
  isbn = {978-1-4503-5182-9},
  doi = {10.1145/3122955.3122959},
  abstract = {We present the urn, a simple tree-based data structure that supports sampling from and updating discrete probability distributions in logarithmic time. We avoid the usual complexity of traditional selfbalancing binary search trees by not keeping values in a specific order. Instead, we keep the tree maximally balanced at all times using a single machine word of overhead: its size.},
  language = {en},
  urldate = {2018-06-05},
  publisher = {{ACM Press}},
  url = {http://dl.acm.org/citation.cfm?doid=3122955.3122959},
  author = {Lampropoulos, Leonidas and {Spector-Zabusky}, Antal and Foner, Kenneth},
  year = {2017},
  pages = {26-37},
  file = {/Users/doisinkidney/Zotero/storage/GP6HZ52R/Lampropoulos et al. - 2017 - Ode on a random urn (functional pearl).pdf;/Users/doisinkidney/Zotero/storage/XSGUQKV2/Lampropoulos et al. - 2017 - Ode on a random urn (functional pearl).pdf}
}

@misc{kmett_-line_2015,
  title = {On-Line {{Lowest Common Ancestor}}},
  urldate = {2018-12-21},
  journal = {School of Haskell},
  url = {https://www.schoolofhaskell.com/user/edwardk/online-lca},
  author = {Kmett, Edward},
  month = aug,
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/2IY9PSK6/online-lca.html}
}


