
@inproceedings{rivas_monoids_2015,
  title = {From Monoids to Near-Semirings: The Essence of {{MonadPlus}} and {{Alternative}}},
  isbn = {978-1-4503-3516-4},
  shorttitle = {From Monoids to Near-Semirings},
  doi = {10.1145/2790449.2790514},
  abstract = {It is well-known that monads are monoids in the category of endo-functors, and in fact so are applicative functors. Unfortunately, the benefits of this unified view are lost when the additional non-determinism structure of |MonadPlus| or |Alternative| is required.

This article recovers the essence of these two type classes by extending monoids to near-semirings with both additive and multiplicative structure. This unified algebraic view enables us to generically define the free construction as well as a novel double Cayley representation that optimises both left-nested sums and left-nested products.},
  language = {en},
  urldate = {2016-11-23},
  url = {http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf},
  booktitle = {Proceedings of the 17th {{International Symposium}} on {{Principles}} and {{Practice}} of {{Declarative Programming}}},
  publisher = {{ACM}},
  author = {Rivas, Exequiel and Jaskelioff, Mauro and Schrijvers, Tom},
  year = {2015},
  pages = {196-207},
  file = {/Users/doisinkidney/Zotero/storage/TQ2SUXE7/Rivas et al. - From monoids to near-semirings the essence of Mon.pdf},
  note = {https://www.reddit.com/r/haskell/comments/3dlz6b/from\_monoids\_to\_nearsemirings\_the\_essence\_of/?}
}

@article{mcbride_polynomial_nodate,
  title = {A Polynomial Testing Principle},
  abstract = {Two polynomial functions of degree at most n agree on all inputs if they agree on n + 1 different inputs, e.g., on \{0, 1, 2, . . . , n\}. This fact gives us a simple procedure for testing equivalence in a language of polynomial expressions. Moreover, we may readily extend this language to include a summation operator and test standard results which are usually established inductively.},
  language = {en},
  author = {McBride, Conor},
  pages = {14},
  file = {/Users/doisinkidney/Zotero/storage/TJY6RASV/McBride - A polynomial testing principle.pdf}
}

@inproceedings{hutchison_proving_2005,
  address = {Berlin, Heidelberg},
  series = {Lecture Notes in Computer Science},
  title = {Proving {{Equalities}} in a {{Commutative Ring Done Right}} in {{Coq}}},
  volume = {3603},
  isbn = {978-3-540-28372-0 978-3-540-31820-0},
  doi = {10.1007/11541868_7},
  abstract = {We present a new implementation of a reflexive tactic which solves equalities in a ring structure inside the Coq system. The efficiency is improved to a point that we can now prove equalities that were previously beyond reach. A special care has been taken to implement efficient algorithms while keeping the complexity of the correctness proofs low. This leads to a single tool, with a single implementation, which can be addressed for a ring or for a semi-ring, abstract or not, using the Leibniz equality or a setoid equality. This example shows that such reflective methods can be effectively used in symbolic computation.},
  language = {en},
  urldate = {2018-08-03},
  url = {http://link.springer.com/10.1007/11541868_7},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Gr\'egoire, Benjamin and Mahboubi, Assia},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Hurd, Joe and Melham, Tom},
  year = {2005},
  pages = {98-113},
  file = {/Users/doisinkidney/Zotero/storage/GTPFHWSU/Gr√©goire and Mahboubi - 2005 - Proving Equalities in a Commutative Ring Done Righ.pdf;/Users/doisinkidney/Zotero/storage/KK2HQB4Z/11541868_7.html}
}

@phdthesis{zalakain_evidence-providing_2017,
  address = {Strathclyde},
  type = {Submitted for the {{Degree}} of {{B}}.{{Sc}}. in {{Computer Science}}},
  title = {Evidence-Providing Problem Solvers in {{Agda}}},
  abstract = {The Curry-Howard correspondence draws a direct link between logic and computation: propositions are modelled as types and proofs as programs; to prove a proposition is to con- struct a program inhabiting its corresponding type. Several computer-assisted theorem provers have been developed under this idea. They are not just used to verify human reasoning: they are also often capable of generating proofs automatically.
This project considers the development of such automated theorem provers in Agda, a de- pendently typed programming language. As a warm-up, I present a verified solver for equations on monoids. Then, I comment on the solver for commutative rings included in Agda's stan- dard library. Finally, I develop a verified decision procedure for Presburger arithmetic \textemdash{} a decidable first-order predicate logic.},
  language = {en},
  urldate = {2018-03-08},
  url = {https://umazalakain.info/static/report.pdf},
  school = {University of Strathclyde},
  author = {Zalakain, Uma},
  year = {2017},
  file = {/Users/doisinkidney/Zotero/storage/HK3IVT32/report.pdf}
}

@incollection{geuvers_automatically_2017,
  address = {Cham},
  title = {Automatically {{Proving Equivalence}} by {{Type}}-{{Safe Reflection}}},
  volume = {10383},
  isbn = {978-3-319-62074-9 978-3-319-62075-6},
  abstract = {One difficulty with reasoning and programming with dependent types is that proof obligations arise naturally once programs become even moderately sized. For example, implementing an adder for binary numbers indexed over their natural number equivalents naturally leads to proof obligations for equalities of expressions over natural numbers. The need for these equality proofs comes, in intensional type theories, from the fact that the propositional equality enables us to prove as equal terms that are not judgementally equal, which means that the typechecker can't always obtain equalities by reduction. As far as possible, we would like to solve such proof obligations automatically. In this paper, we show one way to automate these proofs by reflection in the dependently typed programming language Idris. We show how defining reflected terms indexed by the original Idris expression allows us to construct and manipulate proofs. We build a hierarchy of tactics for proving equivalences in semigroups, monoids, commutative monoids, groups, commutative groups, semi-rings and rings. We also show how each tactic reuses those from simpler structures, thus avoiding duplication of code and proofs.},
  language = {en},
  urldate = {2018-08-16},
  url = {http://link.springer.com/10.1007/978-3-319-62075-6_4},
  booktitle = {Intelligent {{Computer Mathematics}}},
  publisher = {{Springer International Publishing}},
  author = {Slama, Franck and Brady, Edwin},
  editor = {Geuvers, Herman and England, Matthew and Hasan, Osman and Rabe, Florian and Teschke, Olaf},
  year = {2017},
  pages = {40-55},
  file = {/Users/doisinkidney/Zotero/storage/PDB7LZPW/Slama and Brady - 2017 - Automatically Proving Equivalence by Type-Safe Ref.pdf},
  doi = {10.1007/978-3-319-62075-6_4}
}

@article{mu_algebra_2009,
  title = {Algebra of Programming in {{Agda}}: {{Dependent}} Types for Relational Program Derivation},
  volume = {19},
  issn = {1469-7653, 0956-7968},
  shorttitle = {Algebra of Programming in {{Agda}}},
  doi = {10.1017/S0956796809007345},
  abstract = {Relational program derivation is the technique of stepwise refining a relational specification to a program by algebraic rules. The program thus obtained is correct by construction. Meanwhile, dependent type theory is rich enough to express various correctness properties to be verified by the type checker. We have developed a library, AoPA (Algebra of Programming in Agda), to encode relational derivations in the dependently typed programming language Agda. A program is coupled with an algebraic derivation whose correctness is guaranteed by the type system. Two non-trivial examples are presented: an optimisation problem and a derivation of quicksort in which well-founded recursion is used to model terminating hylomorphisms in a language with inductive types.},
  language = {en},
  number = {5},
  urldate = {2018-08-17},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/algebra-of-programming-in-agda-dependent-types-for-relational-program-derivation/ACA0C08F29621A892FB0C0B745254D15},
  journal = {Journal of Functional Programming},
  author = {Mu, Shin-Cheng and Ko, Hsiang-Shang and Jansson, Patrik},
  month = sep,
  year = {2009},
  pages = {545-579},
  file = {/Users/doisinkidney/Zotero/storage/8IUG4JU2/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/D7UWNTJ4/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/D8FNYT4X/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/5D6VGKJQ/ACA0C08F29621A892FB0C0B745254D15.html}
}

@inproceedings{audebaud_algebra_2008,
  address = {Berlin, Heidelberg},
  series = {Lecture Notes in Computer Science},
  title = {Algebra of {{Programming Using Dependent Types}}},
  volume = {5133},
  isbn = {978-3-540-70593-2 978-3-540-70594-9},
  doi = {10.1007/978-3-540-70594-9_15},
  abstract = {Dependent type theory is rich enough to express that a program satisfies an input/output relational specification, but it could be hard to construct the proof term. On the other hand, squiggolists know very well how to show that one relation is included in another by algebraic reasoning. We demonstrate how to encode functional and relational derivations in a dependently typed programming language. A program is coupled with an algebraic derivation from a specification, whose correctness is guaranteed by the type system.},
  language = {en},
  urldate = {2018-08-18},
  url = {http://link.springer.com/10.1007/978-3-540-70594-9_15},
  booktitle = {Mathematics of {{Program Construction}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Mu, Shin-Cheng and Ko, Hsiang-Shang and Jansson, Patrik},
  editor = {Audebaud, Philippe and {Paulin-Mohring}, Christine},
  year = {2008},
  pages = {268-283},
  file = {/Users/doisinkidney/Zotero/storage/ASKFWFTU/Mu et al. - Algebra of Programming Using Dependent Types.pdf;/Users/doisinkidney/Zotero/storage/5VKT7DWK/10.html}
}

@misc{gibbons_horners_2011,
  title = {Horner's {{Rule}}},
  abstract = {This post is about my all-time favourite calculation, of a linear-time algorithm for the maximum segment sum problem, based on Horner's Rule. The problem was popularized in Jon Bentley'\ldots},
  language = {en},
  urldate = {2018-08-19},
  url = {https://patternsinfp.wordpress.com/2011/05/05/horners-rule/},
  journal = {Patterns in Functional Programming},
  author = {Gibbons, Jeremy},
  month = may,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/WRD6S87U/horners-rule.html}
}

@misc{gibbons_distributivity_2011,
  title = {Distributivity in {{Horner}}'s {{Rule}}},
  abstract = {This is a continuation of my previous post on Horner's Rule, and in particular, of the discussion there about distributivity in the datatype-generic version of the Maximum Segment Sum problem\ldots},
  language = {en},
  urldate = {2018-08-19},
  url = {https://patternsinfp.wordpress.com/2011/05/17/distributivity-in-horners-rule/},
  journal = {Patterns in Functional Programming},
  author = {Gibbons, Jeremy},
  month = may,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/QSZZFG3P/distributivity-in-horners-rule.html}
}

@article{mcbride_view_2004,
  title = {The {{View}} from the {{Left}}},
  volume = {14},
  issn = {0956-7968},
  doi = {10.1017/S0956796803004829},
  abstract = {Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways. First, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991). Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful. Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler's (1987) notion of `view'. The programmer wishing to introduce a new view of a type \$$\backslash$mathit\{T\}\$, and exploit it directly in pattern matching, may do so via a standard programming idiom. The type theorist, looking through the Curry\textendash{}Howard lens, may see this as proving a theorem, one which establishes the validity of a new induction principle for \$$\backslash$mathit\{T\}\$. We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is ipso facto a proof that typechecking is decidable.},
  number = {1},
  urldate = {2018-08-21},
  url = {http://strictlypositive.org/vfl.pdf},
  journal = {J. Funct. Program.},
  author = {McBride, Conor and McKinna, James},
  month = jan,
  year = {2004},
  pages = {69--111},
  file = {/Users/doisinkidney/Zotero/storage/JPF2T4CC/McBride and McKinna - 2004 - The View from the Left.pdf}
}

@techreport{russino_polynomial_2017,
  title = {Polynomial {{Terms}} and {{Sparse Horner Normal Form}}},
  language = {en},
  url = {http://www.russinoff.com/papers/shnf.pdf},
  author = {Russinoff, David M},
  month = jul,
  year = {2017},
  pages = {8},
  file = {/Users/doisinkidney/Zotero/storage/XGCQCLFR/RussinoÔ¨Ä - Polynomial Terms and Sparse Horner Normal Form.pdf}
}

@misc{mcbride_polynomial_2018,
  type = {Tweet},
  title = {A {{Polynomial Testing Principle}}},
  abstract = {A polynomial testing principle gives a machine-checked proof that, under suitably controlled circumstances, in a small but familiar domain, testing can reveal the absence of bugs.},
  language = {en},
  urldate = {2018-08-23},
  url = {https://twitter.com/pigworker/status/1013535783234473984},
  journal = {Conor McBride's Twitter Feed},
  author = {McBride, Conor},
  month = jul,
  year = {2018},
  file = {/Users/doisinkidney/Zotero/storage/DB4NV3DI/1013535783234473984.html}
}


