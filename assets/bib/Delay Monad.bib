
@techreport{jones_linear-time_1993-1,
  title = {Linear-Time {{Breadth}}-First {{Tree Algorithms}}: {{An Exercise}} in the {{Arithmetic}} of {{Folds}} and {{Zips}}},
  shorttitle = {Linear-Time Breadth-First Tree Algorithms},
  abstract = {This paper is about an application of the mathematics of the zip, reduce (fold) and accumulate (scan) operations on lists. It gives an account of the derivation of a linear-time breadth-first tree traversal algorithm, and of a subtle and efficient breadth-first tree labelling algorithm.},
  number = {71},
  url = {http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/linear.ps.gz},
  institution = {{Dept of Computer Science, University of Auckland}},
  author = {Jones, Geraint and Gibbons, Jeremy},
  month = may,
  year = {1993},
  file = {/Users/doisinkidney/Zotero/storage/DWNSFLCU/Jones and Gibbons - 1993 - Linear-time Breadth-first Tree Algorithms An Exer.pdf;/Users/doisinkidney/Zotero/storage/FBMN8FSQ/summary.html}
}

@article{spivey_faster_2017,
  title = {Faster Coroutine Pipelines},
  volume = {1},
  issn = {24751421},
  doi = {10.1145/3110249},
  language = {en},
  number = {ICFP},
  urldate = {2018-06-10},
  url = {http://dl.acm.org/citation.cfm?doid=3136534.3110249},
  journal = {Proceedings of the ACM on Programming Languages},
  author = {Spivey, Michael},
  month = aug,
  year = {2017},
  pages = {1-23},
  file = {/Users/doisinkidney/Zotero/storage/86UE6L7N/Spivey - 2017 - Faster coroutine pipelines.pdf}
}

@misc{mcbride_time_2009,
  title = {Time Flies like an Applicative Functor},
  language = {en-US},
  urldate = {2018-06-18},
  url = {https://mazzo.li/epilogue/index.html\%3Fp=186.html},
  journal = {Epilogue for Epigram},
  author = {McBride, Conor},
  month = jun,
  year = {2009},
  file = {/Users/doisinkidney/Zotero/storage/GSU4XAFN/index.htmlp=186.html}
}

@article{bizjak_step-indexed_2015,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1501.02623},
  primaryClass = {cs},
  title = {Step-{{Indexed Logical Relations}} for {{Probability}} (Long Version)},
  volume = {9034},
  doi = {10.1007/978-3-662-46678-0_18},
  abstract = {It is well-known that constructing models of higher-order probabilistic programming languages is challenging. We show how to construct step-indexed logical relations for a probabilistic extension of a higher-order programming language with impredicative polymorphism and recursive types. We show that the resulting logical relation is sound and complete with respect to the contextual preorder and, moreover, that it is convenient for reasoning about concrete program equivalences. Finally, we extend the language with dynamically allocated first-order references and show how to extend the logical relation to this language. We show that the resulting relation remains useful for reasoning about examples involving both state and probabilistic choice.},
  urldate = {2018-06-18},
  url = {http://arxiv.org/abs/1501.02623},
  journal = {arXiv:1501.02623 [cs]},
  author = {Bizjak, Ale{\v s} and Birkedal, Lars},
  year = {2015},
  keywords = {Computer Science - Logic in Computer Science},
  pages = {279-294},
  file = {/Users/doisinkidney/Zotero/storage/8GIKCFEI/Bizjak and Birkedal - 2015 - Step-Indexed Logical Relations for Probability (lo.pdf;/Users/doisinkidney/Zotero/storage/QPDV794N/1501.html}
}

@article{atkey_interleaving_2015,
  title = {Interleaving Data and Effects},
  volume = {25},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796815000209},
  abstract = {The study of programming with and reasoning about inductive datatypes such as lists and trees has benefited from the simple categorical principle of initial algebras. In initial algebra semantics, each inductive datatype is represented by an initial f -algebra for an appropriate functor f . The initial algebra principle then supports the straightforward derivation of definitional principles and proof principles for these datatypes. This technique has been expanded to a whole methodology of structured functional programming, often called origami programming.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://bentnib.org/interleaving.html},
  journal = {Journal of Functional Programming},
  author = {Atkey, Robert and Johann, Patricia},
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/GAGZ4AAX/Atkey and Johann - 2015 - Interleaving data and effects.pdf}
}

@article{blazevic_coroutine_2011,
  title = {Coroutine {{Pipelines}}},
  volume = {19},
  abstract = {The basic idea of trampoline-style execution is well known and has already been explored multiple times, every time leading in a different direction. The recent popularity of iteratees leads me to believe that the time has come for yet another expedition. If you're not inclined to explore this territory on your own, the monad- coroutine and SCC packages [1, 2] provide a trodden path.},
  language = {en},
  number = {19},
  url = {https://themonadreader.files.wordpress.com/2011/10/issue19.pdf},
  journal = {The Monad.Reader},
  author = {Bla{\v z}evi{\'c}, Mario},
  month = aug,
  year = {2011},
  pages = {29-50},
  file = {/Users/doisinkidney/Zotero/storage/RI7EZJ4J/Blažević - 2018 - Coroutine Pipelines.pdf}
}

@inproceedings{harrison_essence_2006,
  address = {Berlin, Heidelberg},
  series = {AMAST'06},
  title = {The {{Essence}} of {{Multitasking}}},
  isbn = {978-3-540-35633-2},
  doi = {10.1007/11784180_14},
  abstract = {This article demonstrates how a powerful and expressive abstraction from concurrency theory\textemdash{}monads of resumptions\textemdash{}plays a dual r{\^o}le as a programming tool for concurrent applications. The article demonstrates how a wide variety of typical OS behaviors may be specified in terms of resumption monads known heretofore exclusively in the literature of programming language semantics. We illustrate the expressiveness of the resumption monad with the construction of an exemplary multitasking kernel in the pure functional language Haskell.},
  urldate = {2018-06-19},
  url = {http://dx.doi.org/10.1007/11784180_14},
  booktitle = {Proceedings of the 11th {{International Conference}} on {{Algebraic Methodology}} and {{Software Technology}}},
  publisher = {{Springer-Verlag}},
  author = {Harrison, William L.},
  year = {2006},
  pages = {158--172}
}

@incollection{hutchison_essence_2006,
  address = {Berlin, Heidelberg},
  title = {The {{Essence}} of {{Multitasking}}},
  volume = {4019},
  isbn = {978-3-540-35633-2 978-3-540-35636-3},
  abstract = {This article demonstrates how a powerful and expressive abstraction from concurrency theory\textemdash{}monads of resumptions\textemdash{}plays a dual r\textasciicircum{}ole as a programming tool for concurrent applications. The article demonstrates how a wide variety of typical OS behaviors may be specified in terms of resumption monads known heretofore exclusively in the literature of programming language semantics. We illustrate the expressiveness of the resumption monad with the construction of an exemplary multitasking kernel in the pure functional language Haskell.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://link.springer.com/10.1007/11784180_14},
  booktitle = {Algebraic {{Methodology}} and {{Software Technology}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Harrison, William L.},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Johnson, Michael and Vene, Varmo},
  year = {2006},
  pages = {158-172},
  file = {/Users/doisinkidney/Zotero/storage/F5R7QPXQ/Harrison - 2006 - The Essence of Multitasking.pdf},
  doi = {10.1007/11784180_14}
}

@inproceedings{capretta_partiality_2005,
  title = {Partiality Is an Effect},
  volume = {2},
  url = {https://www.cs.ox.ac.uk/ralf.hinze/WG2.8/22/slides/tarmo.pdf},
  booktitle = {Slides for a Talk given by {{Uustalu}} at the 22nd Meeting of {{IFIP Working Group}}},
  author = {Capretta, Venanzio and Altenkirch, Thorsten and Uustalu, Tarmo},
  year = {2005},
  file = {/Users/doisinkidney/Zotero/storage/6GHJ35BU/Capretta et al. - 2005 - Partiality is an effect.pdf}
}

@inproceedings{altenkirch_partiality_2017,
  series = {Lecture Notes in Computer Science},
  title = {Partiality, {{Revisited}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_31},
  abstract = {Capretta's delay monad can be used to model partial computations, but it has the ``wrong'' notion of built-in equality, strong bisimilarity. An alternative is to quotient the delay monad by the ``right'' notion of equality, weak bisimilarity. However, recent work by Chapman et al. suggests that it is impossible to define a monad structure on the resulting construction in common forms of type theory without assuming (instances of) the axiom of countable choice.Using an idea from homotopy type theory\textemdash{}a higher inductive-inductive type\textemdash{}we construct a partiality monad without relying on countable choice. We prove that, in the presence of countable choice, our partiality monad is equivalent to the delay monad quotiented by weak bisimilarity. Furthermore we outline several applications.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_31},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Altenkirch, Thorsten and Danielsson, Nils Anders and Kraus, Nicolai},
  month = apr,
  year = {2017},
  pages = {534-549},
  file = {/Users/doisinkidney/Zotero/storage/5NKZK8MQ/978-3-662-54458-7_31.html}
}

@incollection{esparza_partiality_2017-2,
  address = {Berlin, Heidelberg},
  title = {Partiality, {{Revisited}}},
  volume = {10203},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  abstract = {Capretta's delay monad can be used to model partial computations, but it has the ``wrong'' notion of built-in equality, strong bisimilarity. An alternative is to quotient the delay monad by the ``right'' notion of equality, weak bisimilarity. However, recent work by Chapman et al. suggests that it is impossible to define a monad structure on the resulting construction in common forms of type theory without assuming (instances of) the axiom of countable choice.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://link.springer.com/10.1007/978-3-662-54458-7_31},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Altenkirch, Thorsten and Danielsson, Nils Anders and Kraus, Nicolai},
  editor = {Esparza, Javier and Murawski, Andrzej S.},
  year = {2017},
  pages = {534-549},
  file = {/Users/doisinkidney/Zotero/storage/CTLM5XDQ/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/L8F98IQM/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/XGDP694U/Altenkirch et al. - 2017 - Partiality, Revisited.pdf},
  doi = {10.1007/978-3-662-54458-7_31}
}

@article{porter_monad.reader_2011,
  title = {The {{Monad}}.{{Reader Issue}} 18},
  volume = {18},
  language = {en},
  number = {18},
  urldate = {2018-06-19},
  url = {https://themonadreader.files.wordpress.com/2011/07/issue18.pdf},
  journal = {The Monad.Reader},
  author = {Porter, Julian and Petricek, Tomas and Auclair, Douglas M.},
  month = jul,
  year = {2011},
  pages = {51},
  file = {/Users/doisinkidney/Zotero/storage/VYXGI2J4/issue18.pdf}
}

@inproceedings{kiselyov_iteratees_2012,
  address = {Berlin, Heidelberg},
  series = {Lecture Notes in Computer Science},
  title = {Iteratees},
  isbn = {978-3-642-29821-9 978-3-642-29822-6},
  doi = {10.1007/978-3-642-29822-6_15},
  abstract = {Iteratee IO is a style of incremental input processing with precise resource control. The style encourages building input processors from a user-extensible set of primitives by chaining, layering, pairing and other modes of compositions. The programmer is still able, where needed, to precisely control look-ahead, the allocation of buffers, file descriptors and other resources. The style is especially suitable for processing of communication streams, large amount of data, and data undergone several levels of encoding such as pickling, compression, chunking, framing. It has been used for programming high-performance (HTTP) servers and web frameworks, in computational linguistics and financial trading.We exposit programming with iteratees, contrasting them with Lazy IO and the Handle-based, |stdio|-like IO. We relate them to online parser combinators. We introduce a simple implementation as free monads, which lets us formally reason with iteratees. As an example, we validate several equational laws and use them to optimize iteratee programs. The simple implementation helps understand existing implementations of iteratees and derive new ones.},
  language = {en},
  urldate = {2018-06-20},
  url = {http://okmij.org/ftp/Haskell/Iteratee/describe.pdf},
  booktitle = {Proceedings of the 11th {{International Conference}} on {{Functional}} and {{Logic Programming}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Kiselyov, Oleg},
  month = may,
  year = {2012},
  pages = {166-181},
  file = {/Users/doisinkidney/Zotero/storage/GICHJUA3/describe.pdf;/Users/doisinkidney/Zotero/storage/ATVQF2VL/978-3-642-29822-6_15.html}
}

@unpublished{freeman_stack_2015,
  title = {Stack {{Safety}} for {{Free}}},
  abstract = {Free monads are a useful tool for abstraction, separating specification from interpretation. However, a na{\"\i}ve free monad implementation can lead to stack overflow depending on the evaluation model of the host language. This paper develops a stack-safe free monad transformer in PureScript, a strict Haskell-like language compiling to Javascript, and demonstrates certain applications - a safe implementation of coroutines, a safe list monad transformer, and a generic mechanism for building stack-safe control operators.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://functorial.com/stack-safety-for-free/index.pdf},
  author = {Freeman, Phil},
  month = aug,
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/YLS48PF3/Freeman - Stack Safety for Free.pdf}
}

@inproceedings{capretta_partiality_2004,
  address = {Dagstuhl, Germany},
  series = {Dagstuhl Seminar Proceedings},
  title = {Partiality Is an Effect},
  volume = {04381},
  language = {en},
  url = {https://www.ioc.ee/~tarmo/tday-veskisilla/uustalu-slides.pdf},
  booktitle = {Dependently {{Typed Programming}}},
  publisher = {{Internationales Begegnungs- und Forschungszentrum f{\"u}r Informatik (IBFI), Schloss Dagstuhl, Germany}},
  author = {Capretta, Venanzio and Altenkirch, Thorsten and Uustalu, Tarmo},
  month = sep,
  year = {2004},
  pages = {20},
  file = {/Users/doisinkidney/Zotero/storage/WHH6R3QU/Uustalu - Partiality is an effect.pdf}
}

@misc{atkey_how_2011,
  address = {Heriot-Watt University},
  title = {How to Be a {{Productive Programmer}} - by Putting Things off until Tomorrow},
  shorttitle = {How to Be a {{Productive Programmer}}},
  language = {en},
  url = {https://bentnib.org/posts/2011-11-14-productive-programmer.html},
  author = {Atkey, Robert},
  month = nov,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/Z69BHASU/University - How to be a Productive Programmer - by putting thi.pdf}
}

@misc{gonzalez_pipes_2018,
  title = {Pipes: {{Compositional}} Pipelines},
  shorttitle = {Pipes},
  abstract = {pipes is a clean and powerful stream processing library that lets you build and connect reusable streaming components},
  url = {http://hackage.haskell.org/package/pipes},
  author = {Gonzalez, Gabriel},
  month = mar,
  year = {2018}
}

@inproceedings{atkey_productive_2013,
  title = {Productive Coprogramming with Guarded Recursion},
  isbn = {978-1-4503-2326-0},
  doi = {10.1145/2500365.2500597},
  language = {en},
  urldate = {2018-06-21},
  url = {https://bentnib.org/productive.html},
  publisher = {{ACM Press}},
  author = {Atkey, Robert and McBride, Conor},
  year = {2013},
  pages = {197},
  file = {/Users/doisinkidney/Zotero/storage/SXKIJ6DE/Atkey and McBride - 2013 - Productive coprogramming with guarded recursion.pdf}
}


