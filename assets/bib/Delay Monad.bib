
@article{spivey_faster_2017,
  title = {Faster Coroutine Pipelines},
  volume = {1},
  issn = {24751421},
  doi = {10.1145/3110249},
  language = {en},
  number = {ICFP},
  urldate = {2018-06-10},
  url = {http://dl.acm.org/citation.cfm?doid=3136534.3110249},
  journal = {Proceedings of the ACM on Programming Languages},
  author = {Spivey, Michael},
  month = aug,
  year = {2017},
  pages = {1-23},
  file = {/Users/doisinkidney/Zotero/storage/86UE6L7N/Spivey - 2017 - Faster coroutine pipelines.pdf}
}

@inproceedings{nakano_modality_2000,
  title = {A Modality for Recursion},
  isbn = {978-0-7695-0725-5},
  doi = {10.1109/LICS.2000.855774},
  abstract = {We propose a modal logic that enables us to handle self-referential formulae, including ones with negative selfreferences, which on one hand, would introduce a logical contradiction, namely Russell's paradox, in the conventional setting, while on the other hand, are necessary to capture a certain class of programs such as fixed point combinators and objects with so-called binary methods in object-oriented programming. Our logic provides a basis for axiomatic semantics of such a wider range of programs and a new framework for natural construction of recursive programs in the proofs-as-programs paradigm.},
  language = {en},
  urldate = {2018-06-18},
  url = {http://ieeexplore.ieee.org/document/855774/},
  publisher = {{IEEE Comput. Soc}},
  author = {Nakano, H.},
  year = {2000},
  pages = {255-266},
  file = {/Users/doisinkidney/Zotero/storage/L66IKQ5N/Nakano - 2000 - A modality for recursion.pdf}
}

@article{guatto_generalized_2018,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1805.11021},
  primaryClass = {cs},
  title = {A {{Generalized Modality}} for {{Recursion}}},
  doi = {10.1145/3209108.3209148},
  abstract = {Nakano's later modality allows types to express that the output of a function does not immediately depend on its input, and thus that computing its fixpoint is safe. This idea, guarded recursion, has proved useful in various contexts, from functional programming with infinite data structures to formulations of step-indexing internal to type theory. Categorical models have revealed that the later modality corresponds in essence to a simple reindexing of the discrete time scale. Unfortunately, existing guarded type theories suffer from significant limitations for programming purposes. These limitations stem from the fact that the later modality is not expressive enough to capture precise input-output dependencies of functions. As a consequence, guarded type theories reject many productive definitions. Combining insights from guarded type theories and synchronous programming languages, we propose a new modality for guarded recursion. This modality can apply any well-behaved reindexing of the time scale to a type. We call such reindexings time warps. Several modalities from the literature, including later, correspond to fixed time warps, and thus arise as special cases of ours.},
  urldate = {2018-06-18},
  url = {http://arxiv.org/abs/1805.11021},
  journal = {arXiv:1805.11021 [cs]},
  author = {Guatto, Adrien},
  month = may,
  year = {2018},
  keywords = {Computer Science - Programming Languages,Computer Science - Logic in Computer Science},
  file = {/Users/doisinkidney/Zotero/storage/2YXPHUWU/Guatto - 2018 - A Generalized Modality for Recursion.pdf;/Users/doisinkidney/Zotero/storage/YERCCS8H/1805.html}
}

@misc{noauthor_time_nodate-1,
  title = {Time Flies like an Applicative Functor \guillemotleft{} {{Epilogue}}},
  language = {en-US},
  urldate = {2018-06-18},
  url = {https://mazzo.li/epilogue/index.html\%3Fp=186.html},
  file = {/Users/doisinkidney/Zotero/storage/GSU4XAFN/index.htmlp=186.html}
}

@article{dreyer_logical_2011,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1103.0510},
  title = {Logical {{Step}}-{{Indexed Logical Relations}}},
  volume = {7},
  issn = {18605974},
  doi = {10.2168/LMCS-7(2:16)2011},
  abstract = {Appel and McAllester's "step-indexed" logical relations have proven to be a simple and effective technique for reasoning about programs in languages with semantically interesting types, such as general recursive types and general reference types. However, proofs using step-indexed models typically involve tedious, error-prone, and proof-obscuring step-index arithmetic, so it is important to develop clean, high-level, equational proof principles that avoid mention of step indices. In this paper, we show how to reason about binary step-indexed logical relations in an abstract and elegant way. Specifically, we define a logic LSLR, which is inspired by Plotkin and Abadi's logic for parametricity, but also supports recursively defined relations by means of the modal "later" operator from Appel, Melli$\backslash$‘es, Richards, and Vouillon's "very modal model" paper. We encode in LSLR a logical relation for reasoning relationally about programs in call-by-value System F extended with general recursive types. Using this logical relation, we derive a set of useful rules with which we can prove contextual equivalence and approximation results without counting steps.},
  number = {2},
  urldate = {2018-06-18},
  url = {http://arxiv.org/abs/1103.0510},
  journal = {Logical Methods in Computer Science},
  author = {Dreyer, Derek and Ahmed, Amal and Birkedal, Lars},
  month = jun,
  year = {2011},
  keywords = {Computer Science - Programming Languages,Computer Science - Logic in Computer Science,D.3.3; F.3.1; F.3.3},
  file = {/Users/doisinkidney/Zotero/storage/37WV2DRY/Dreyer et al. - 2011 - Logical Step-Indexed Logical Relations.pdf;/Users/doisinkidney/Zotero/storage/DP6WEUWD/1103.html}
}

@article{bizjak_step-indexed_2015,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1501.02623},
  primaryClass = {cs},
  title = {Step-{{Indexed Logical Relations}} for {{Probability}} (Long Version)},
  volume = {9034},
  doi = {10.1007/978-3-662-46678-0_18},
  abstract = {It is well-known that constructing models of higher-order probabilistic programming languages is challenging. We show how to construct step-indexed logical relations for a probabilistic extension of a higher-order programming language with impredicative polymorphism and recursive types. We show that the resulting logical relation is sound and complete with respect to the contextual preorder and, moreover, that it is convenient for reasoning about concrete program equivalences. Finally, we extend the language with dynamically allocated first-order references and show how to extend the logical relation to this language. We show that the resulting relation remains useful for reasoning about examples involving both state and probabilistic choice.},
  urldate = {2018-06-18},
  url = {http://arxiv.org/abs/1501.02623},
  journal = {arXiv:1501.02623 [cs]},
  author = {Bizjak, Ale{\v s} and Birkedal, Lars},
  year = {2015},
  keywords = {Computer Science - Logic in Computer Science},
  pages = {279-294},
  file = {/Users/doisinkidney/Zotero/storage/8GIKCFEI/Bizjak and Birkedal - 2015 - Step-Indexed Logical Relations for Probability (lo.pdf;/Users/doisinkidney/Zotero/storage/QPDV794N/1501.html}
}

@article{atkey_interleaving_2015,
  title = {Interleaving Data and Effects},
  volume = {25},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796815000209},
  abstract = {The study of programming with and reasoning about inductive datatypes such as lists and trees has benefited from the simple categorical principle of initial algebras. In initial algebra semantics, each inductive datatype is represented by an initial f -algebra for an appropriate functor f . The initial algebra principle then supports the straightforward derivation of definitional principles and proof principles for these datatypes. This technique has been expanded to a whole methodology of structured functional programming, often called origami programming.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://bentnib.org/interleaving.html},
  journal = {Journal of Functional Programming},
  author = {Atkey, Robert and Johann, Patricia},
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/GAGZ4AAX/Atkey and Johann - 2015 - Interleaving data and effects.pdf}
}

@article{blazevic_coroutine_2011,
  title = {Coroutine {{Pipelines}}},
  volume = {19},
  abstract = {The basic idea of trampoline-style execution is well known and has already been explored multiple times, every time leading in a different direction. The recent popularity of iteratees leads me to believe that the time has come for yet another expedition. If you're not inclined to explore this territory on your own, the monad- coroutine and SCC packages [1, 2] provide a trodden path.},
  language = {en},
  number = {19},
  url = {https://themonadreader.files.wordpress.com/2011/10/issue19.pdf},
  journal = {The Monad.Reader},
  author = {Bla{\v z}evi{\'c}, Mario},
  month = aug,
  year = {2011},
  pages = {29-50},
  file = {/Users/doisinkidney/Zotero/storage/RI7EZJ4J/Blažević - 2018 - Coroutine Pipelines.pdf}
}

@inproceedings{harrison_essence_2006,
  address = {Berlin, Heidelberg},
  series = {AMAST'06},
  title = {The {{Essence}} of {{Multitasking}}},
  isbn = {978-3-540-35633-2},
  doi = {10.1007/11784180_14},
  abstract = {This article demonstrates how a powerful and expressive abstraction from concurrency theory\textemdash{}monads of resumptions\textemdash{}plays a dual r{\^o}le as a programming tool for concurrent applications. The article demonstrates how a wide variety of typical OS behaviors may be specified in terms of resumption monads known heretofore exclusively in the literature of programming language semantics. We illustrate the expressiveness of the resumption monad with the construction of an exemplary multitasking kernel in the pure functional language Haskell.},
  urldate = {2018-06-19},
  url = {http://dx.doi.org/10.1007/11784180_14},
  booktitle = {Proceedings of the 11th {{International Conference}} on {{Algebraic Methodology}} and {{Software Technology}}},
  publisher = {{Springer-Verlag}},
  author = {Harrison, William L.},
  year = {2006},
  pages = {158--172}
}

@incollection{hutchison_essence_2006,
  address = {Berlin, Heidelberg},
  title = {The {{Essence}} of {{Multitasking}}},
  volume = {4019},
  isbn = {978-3-540-35633-2 978-3-540-35636-3},
  abstract = {This article demonstrates how a powerful and expressive abstraction from concurrency theory\textemdash{}monads of resumptions\textemdash{}plays a dual r\textasciicircum{}ole as a programming tool for concurrent applications. The article demonstrates how a wide variety of typical OS behaviors may be specified in terms of resumption monads known heretofore exclusively in the literature of programming language semantics. We illustrate the expressiveness of the resumption monad with the construction of an exemplary multitasking kernel in the pure functional language Haskell.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://link.springer.com/10.1007/11784180_14},
  booktitle = {Algebraic {{Methodology}} and {{Software Technology}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Harrison, William L.},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Johnson, Michael and Vene, Varmo},
  year = {2006},
  pages = {158-172},
  file = {/Users/doisinkidney/Zotero/storage/F5R7QPXQ/Harrison - 2006 - The Essence of Multitasking.pdf},
  doi = {10.1007/11784180_14}
}

@inproceedings{capretta_partiality_2005,
  title = {Partiality Is an Effect},
  volume = {2},
  url = {https://www.cs.ox.ac.uk/ralf.hinze/WG2.8/22/slides/tarmo.pdf},
  booktitle = {Slides for a Talk given by {{Uustalu}} at the 22nd Meeting of {{IFIP Working Group}}},
  author = {Capretta, Venanzio and Altenkirch, Thorsten and Uustalu, Tarmo},
  year = {2005},
  file = {/Users/doisinkidney/Zotero/storage/6GHJ35BU/Capretta et al. - 2005 - Partiality is an effect.pdf}
}

@inproceedings{mamouras_equational_2017,
  series = {Lecture Notes in Computer Science},
  title = {Equational {{Theories}} of {{Abnormal Termination Based}} on {{Kleene Algebra}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_6},
  abstract = {We study at an abstract level imperative while programs with an explicit fail operation that causes abnormal termination or irreparable failure, and a try-catch operation for error handling. There are two meaningful ways to define the semantics of such programs, depending on whether the final state of the computation can be observed upon failure or not. These two semantics give rise to different equational theories. We investigate these two theories in the abstract framework of Kleene algebra, and we propose two simple and intuitive equational axiomatizations. We prove very general conservativity results, from which we also obtain decidability and deductive completeness of each of our calculi with respect to the intended semantics.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_6},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Mamouras, Konstantinos},
  month = apr,
  year = {2017},
  pages = {88-105},
  file = {/Users/doisinkidney/Zotero/storage/W4NCG2UU/978-3-662-54458-7_6.html}
}

@inproceedings{daviaud_degree_2017,
  series = {Lecture Notes in Computer Science},
  title = {Degree of {{Sequentiality}} of {{Weighted Automata}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_13},
  abstract = {Weighted automata (WA) are an important formalism to describe quantitative properties. Obtaining equivalent deterministic machines is a longstanding research problem. In this paper we consider WA with a set semantics, meaning that the semantics is given by the set of weights of accepting runs. We focus on multi-sequential WA that are defined as finite unions of sequential WA. The problem we address is to minimize the size of this union. We call this minimum the degree of sequentiality of (the relation realized by) the WA.For a given positive integer k, we provide multiple characterizations of relations realized by a union of k sequential WA over an infinitary finitely generated group: a Lipschitz-like machine independent property, a pattern on the automaton (a new twinning property) and a subclass of cost register automata. When possible, we effectively translate a WA into an equivalent union of k sequential WA. We also provide a decision procedure for our twinning property for commutative computable groups thus allowing to compute the degree of sequentiality. Last, we show that these results also hold for word transducers and that the associated decision problem is $\backslash$($\backslash$textsc \{Pspace\}$\backslash$)-complete.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_13},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Daviaud, Laure and Jecker, Isma{\"e}l and Reynier, Pierre-Alain and Villevalois, Didier},
  month = apr,
  year = {2017},
  pages = {215-230},
  file = {/Users/doisinkidney/Zotero/storage/WZGQL7KU/978-3-662-54458-7_13.html}
}

@inproceedings{chadha_emptiness_2017,
  series = {Lecture Notes in Computer Science},
  title = {Emptiness {{Under Isolation}} and the {{Value Problem}} for {{Hierarchical Probabilistic Automata}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_14},
  abstract = {k-Hierarchical probabilistic automata (k-HPA) are probabilistic automata whose states are stratified into $\backslash$(k+1$\backslash$) levels such that from any state, on any input symbol, at most one successor belongs to the same level, while the remaining belong to higher levels. Our main result shows that the emptiness and universality problems are decidable for k-HPAs with isolated cut-points; recall that a cut-point x is isolated if the acceptance probability of every word is bounded away from x. Our algorithm for establishing this result relies on computing an approximation of the value of an HPA; the value of a probabilistic automaton is the supremum of the acceptance probabilities of all words. Computing the exact value of a probabilistic automaton is an equally important problem and we show that the problem is co-R.E.-complete for k-HPAs, for $\backslash$(k $\backslash$ge 2$\backslash$) (as opposed to $\backslash$($\backslash$mathbf \{$\backslash$Pi \^\{0\}\_\{\{2\}\}\}$\backslash$)-complete for general probabilistic automata). On the other hand, we also show that for 1-HPAs the value can be computed in exponential time.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_14},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Chadha, Rohit and Sistla, A. Prasad and Viswanathan, Mahesh},
  month = apr,
  year = {2017},
  pages = {231-247},
  file = {/Users/doisinkidney/Zotero/storage/DD48HFGU/978-3-662-54458-7_14.html}
}

@inproceedings{crubille_free_2017,
  series = {Lecture Notes in Computer Science},
  title = {The {{Free Exponential Modality}} of {{Probabilistic Coherence Spaces}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_2},
  abstract = {Probabilistic coherence spaces yield a model of linear logic and lambda-calculus with a linear algebra flavor. Formulas/types are associated with convex sets of $\backslash$(\{$\backslash$mathbb R\^+\}\^\{\}$\backslash$)-valued vectors, linear logic proofs with linear functions and $\backslash$($\backslash$lambda $\backslash$)-terms with entire functions, both mapping the convex set of their domain into the one of their codomain.Previous results show that this model is particularly precise in describing the observational equivalences between probabilistic functional programs. We prove here that the exponential modality is the free commutative comonad, giving a further mark of canonicity to the model.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_2},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Crubill{\'e}, Rapha{\"e}lle and Ehrhard, Thomas and Pagani, Michele and Tasson, Christine},
  month = apr,
  year = {2017},
  pages = {20-35},
  file = {/Users/doisinkidney/Zotero/storage/MQ3QGVKJ/978-3-662-54458-7_2.html}
}

@inproceedings{abriola_logics_2017,
  series = {Lecture Notes in Computer Science},
  title = {Logics of {{Repeating Values}} on {{Data Trees}} and {{Branching Counter Systems}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_12},
  abstract = {We study connections between the satisfiability problem for logics on data trees and Branching Vector Addition Systems (BVAS). We consider a natural temporal logic of ``repeating values'' (LRV) featuring an operator which tests whether a data value in the current node is repeated in some descendant node.On the one hand, we show that the satisfiability of a restricted version of LRV on ranked data trees can be reduced to the coverability problem for Branching Vector Addition Systems. This immediately gives elementary upper bounds for its satisfiability problem, showing that restricted LRV behaves much better than downward-XPath, which has a non-primitive-recursive satisfiability problem.On the other hand, satisfiability for LRV is shown to be reducible to the coverability for a novel branching model we introduce here, called Merging VASS (MVASS). MVASS is an extension of Branching Vector Addition Systems with States (BVASS) allowing richer merging operations of the vectors. We show that the control-state reachability for MVASS, as well as its bottom-up coverability, are in 3ExpTime.This work can be seen as a natural continuation of the work initiated by Demri, D'Souza and Gascon for the case of data words, this time considering branching structures and counter systems, although, as we show, in the case of data trees more powerful models are needed to encode satisfiability.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_12},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Abriola, Sergio and Figueira, Diego and Figueira, Santiago},
  month = apr,
  year = {2017},
  pages = {196-212},
  file = {/Users/doisinkidney/Zotero/storage/APYD8ETF/978-3-662-54458-7_12.html}
}

@inproceedings{boreale_algebra_2017,
  series = {Lecture Notes in Computer Science},
  title = {Algebra, {{Coalgebra}}, and {{Minimization}} in {{Polynomial Differential Equations}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_5},
  abstract = {We consider reasoning and minimization in systems of polynomial ordinary differential equations (odes). The ring of multivariate polynomials is employed as a syntax for denoting system behaviours. We endow polynomials with a transition system structure based on the concept of Lie derivative, thus inducing a notion of Open image in new window -bisimulation. Two states (variables) are proven Open image in new window -bisimilar if and only if they correspond to the same solution in the odes system. We then characterize Open image in new window -bisimilarity algebraically, in terms of certain ideals in the polynomial ring that are invariant under Lie-derivation. This characterization allows us to develop a complete algorithm, based on building an ascending chain of ideals, for computing the largest Open image in new window -bisimulation containing all valid identities that are instances of a user-specified template. A specific largest Open image in new window -bisimulation can be used to build a reduced system of odes, equivalent to the original one, but minimal among all those obtainable by linear aggregation of the original equations.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_5},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Boreale, Michele},
  month = apr,
  year = {2017},
  pages = {71-87},
  file = {/Users/doisinkidney/Zotero/storage/RDZGCJFN/978-3-662-54458-7_5.html}
}

@inproceedings{pous_companions_2017,
  series = {Lecture Notes in Computer Science},
  title = {Companions, {{Codensity}} and {{Causality}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_7},
  abstract = {In the context of abstract coinduction in complete lattices, the notion of compatible function makes it possible to introduce enhancements of the coinduction proof principle. The largest compatible function, called the companion, subsumes most enhancements and has been proved to enjoy many good properties. Here we move to universal coalgebra, where the corresponding notion is that of a final distributive law. We show that when it exists the final distributive law is a monad, and that it coincides with the codensity monad of the final sequence of the given functor. On sets, we moreover characterise this codensity monad using a new abstract notion of causality. In particular, we recover the fact that on streams, the functions definable by a distributive law or GSOS specification are precisely the causal functions. Going back to enhancements of the coinductive proof principle, we finally obtain that any causal function gives rise to a valid up-to-context technique.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_7},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Pous, Damien and Rot, Jurriaan},
  month = apr,
  year = {2017},
  pages = {106-123},
  file = {/Users/doisinkidney/Zotero/storage/TVJLVB6M/978-3-662-54458-7_7.html}
}

@inproceedings{busatto-gaston_optimal_2017,
  series = {Lecture Notes in Computer Science},
  title = {Optimal {{Reachability}} in {{Divergent Weighted Timed Games}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_10},
  abstract = {Weighted timed games are played by two players on a timed automaton equipped with weights: one player wants to minimise the accumulated weight while reaching a target, while the other has an opposite objective. Used in a reactive synthesis perspective, this quantitative extension of timed games allows one to measure the quality of controllers. Weighted timed games are notoriously difficult and quickly undecidable, even when restricted to non-negative weights. Decidability results exist for subclasses of one-clock games, and for a subclass with non-negative weights defined by a semantical restriction on the weights of cycles. In this work, we introduce the class of divergent weighted timed games as a generalisation of this semantical restriction to arbitrary weights. We show how to compute their optimal value, yielding the first decidable class of weighted timed games with negative weights and an arbitrary number of clocks. In addition, we prove that divergence can be decided in polynomial space. Last, we prove that for untimed games, this restriction yields a class of games for which the value can be computed in polynomial time.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_10},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {{Busatto-Gaston}, Damien and Monmege, Benjamin and Reynier, Pierre-Alain},
  month = apr,
  year = {2017},
  pages = {162-178},
  file = {/Users/doisinkidney/Zotero/storage/TZRCUPLU/978-3-662-54458-7_10.html}
}

@inproceedings{gilbert_automated_2017,
  series = {Lecture Notes in Computer Science},
  title = {Automated {{Constructivization}} of {{Proofs}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_28},
  abstract = {No computable function can output a constructive proof from a classical one whenever its associated theorem also holds constructively. We show in this paper that it is however possible, in practice, to turn a large amount of classical proofs into constructive ones. We describe for this purpose a linear-time constructivization algorithm which is provably complete on large fragments of predicate logic.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_28},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Gilbert, Fr{\'e}d{\'e}ric},
  month = apr,
  year = {2017},
  pages = {480-495},
  file = {/Users/doisinkidney/Zotero/storage/2JLV9C7H/978-3-662-54458-7_28.html}
}

@inproceedings{simpson_cyclic_2017,
  series = {Lecture Notes in Computer Science},
  title = {Cyclic {{Arithmetic Is Equivalent}} to {{Peano Arithmetic}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_17},
  abstract = {Cyclic proof provides a style of proof for logics with inductive (and coinductive) definitions, in which proofs are cyclic graphs representing a form of argument by infinite descent. It is easily shown that cyclic proof subsumes proof by (co)induction. So cyclic proof systems are at least as powerful as the corresponding proof systems with explicit (co)induction rules. Whether or not the converse inclusion holds is a non-trivial question. In this paper, we resolve this question in one interesting case. We show that a cyclic formulation of first-order arithmetic is equivalent in power to Peano Arithmetic. The proof involves formalising the meta-theory of cyclic proof in a subsystem of second-order arithmetic.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_17},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Simpson, Alex},
  month = apr,
  year = {2017},
  pages = {283-300},
  file = {/Users/doisinkidney/Zotero/storage/PAHT939E/978-3-662-54458-7_17.html}
}

@inproceedings{goncharov_unifying_2017,
  series = {Lecture Notes in Computer Science},
  title = {Unifying {{Guarded}} and {{Unguarded Iteration}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_30},
  abstract = {Models of iterated computation, such as (completely) iterative monads, often depend on a notion of guardedness, which guarantees unique solvability of recursive equations and requires roughly that recursive calls happen only under certain guarding operations. On the other hand, many models of iteration do admit unguarded iteration. Solutions are then no longer unique, and in general not even determined as least or greatest fixpoints, being instead governed by quasi-equational axioms. Monads that support unguarded iteration in this sense are called (complete) Elgot monads. Here, we propose to equip monads with an abstract notion of guardedness and then require solvability of abstractly guarded recursive equations; examples of such abstractly guarded pre-iterative monads include both iterative monads and Elgot monads, the latter by deeming any recursive definition to be abstractly guarded. Our main result is then that Elgot monads are precisely the iteration-congruent retracts of abstractly guarded iterative monads, the latter being defined as admitting unique solutions of abstractly guarded recursive equations; in other words, models of unguarded iteration come about by quotienting models of guarded iteration.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_30},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Goncharov, Sergey and Schr{\"o}der, Lutz and Rauch, Christoph and Pir{\'o}g, Maciej},
  month = apr,
  year = {2017},
  pages = {517-533},
  file = {/Users/doisinkidney/Zotero/storage/GS89NNRC/978-3-662-54458-7_30.html}
}

@inproceedings{clerc_pointless_2017,
  series = {Lecture Notes in Computer Science},
  title = {Pointless {{Learning}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_21},
  abstract = {Bayesian inversion is at the heart of probabilistic programming and more generally machine learning. Understanding inversion is made difficult by the pointful (kernel-centric) point of view usually taken in the literature. We develop a pointless (kernel-free) approach to inversion. While doing so, we revisit some foundational objects of probability theory, unravel their category-theoretical underpinnings and show how pointless Bayesian inversion sits naturally at the centre of this construction.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_21},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Clerc, Florence and Danos, Vincent and Dahlqvist, Fredrik and Garnier, Ilias},
  month = apr,
  year = {2017},
  pages = {355-369},
  file = {/Users/doisinkidney/Zotero/storage/YQXNCRVH/978-3-662-54458-7_21.html}
}

@inproceedings{bouyer_dynamic_2017,
  series = {Lecture Notes in Computer Science},
  title = {Dynamic {{Complexity}} of the {{Dyck Reachability}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_16},
  abstract = {Dynamic complexity is concerned with updating the output of a problem when the input is slightly changed. We study the dynamic complexity of Dyck reachability problems in directed and undirected graphs, where updates may add or delete edges. We show a strong dichotomy between such problems, based on the size of the Dyck alphabet. Some of them are $\backslash$($\backslash$mathsf \{P\}$\backslash$)-complete (under a strong notion of reduction) while the others lie either in $\backslash$($\backslash$mathsf \{DynFO\}$\backslash$) or in $\backslash$($\backslash$mathsf \{NL\}$\backslash$).},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_16},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Bouyer, Patricia and Jug{\'e}, Vincent},
  month = apr,
  year = {2017},
  pages = {265-280},
  file = {/Users/doisinkidney/Zotero/storage/R6KKGS3I/978-3-662-54458-7_16.html}
}

@inproceedings{berardi_classical_2017,
  series = {Lecture Notes in Computer Science},
  title = {Classical {{System}} of {{Martin}}-{{L{\"o}f}}'s {{Inductive Definitions Is Not Equivalent}} to {{Cyclic Proof System}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_18},
  abstract = {A cyclic proof system, called $\backslash$( $\backslash$mathtt\{CLKID\}\^$\backslash$omega $\backslash$), gives us another way of representing inductive definitions and efficient proof search. The 2011 paper by Brotherston and Simpson showed that the provability of $\backslash$( $\backslash$mathtt\{CLKID\}\^$\backslash$omega $\backslash$) includes the provability of Martin-L{\"o}f's system of inductive definitions, called $\backslash$( $\backslash$mathtt\{LKID\} $\backslash$), and conjectured the equivalence. Since then, the equivalence has been left an open question. This paper shows that $\backslash$( $\backslash$mathtt\{CLKID\}\^$\backslash$omega $\backslash$) and $\backslash$( $\backslash$mathtt\{LKID\} $\backslash$) are indeed not equivalent. This paper considers a statement called 2-Hydra in these two systems with the first-order language formed by 0, the successor, the natural number predicate, and a binary predicate symbol used to express 2-Hydra. This paper shows that the 2-Hydra statement is provable in $\backslash$( $\backslash$mathtt\{CLKID\}\^$\backslash$omega $\backslash$), but the statement is not provable in $\backslash$( $\backslash$mathtt\{LKID\} $\backslash$), by constructing some Henkin model where the statement is false.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_18},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Berardi, Stefano and Tatsuta, Makoto},
  month = apr,
  year = {2017},
  pages = {301-317},
  file = {/Users/doisinkidney/Zotero/storage/DTHZJHVJ/978-3-662-54458-7_18.html}
}

@inproceedings{danos_computing_2017,
  series = {Lecture Notes in Computer Science},
  title = {Computing {{Continuous}}-{{Time Markov Chains}} as {{Transformers}} of {{Unbounded Observables}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_20},
  abstract = {The paper studies continuous-time Markov chains (CTMCs) as transformers of real-valued functions on their state space, considered as generalised predicates and called observables. Markov chains are assumed to take values in a countable state space $\backslash$($\backslash$mathbf \{S\}$\backslash$); observables $\backslash$(f: $\backslash$mathbf \{S\} $\backslash$rightarrow \{$\backslash$mathbb \{R\}\}$\backslash$) may be unbounded. The interpretation of CTMCs as transformers of observables is via their transition function $\backslash$( P\_\{t\} $\backslash$): each observable $\backslash$(f$\backslash$) is mapped to the observable $\backslash$( P\_\{t\} f$\backslash$) that, in turn, maps each state $\backslash$(x$\backslash$) to the mean value of $\backslash$(f$\backslash$) at time $\backslash$(t$\backslash$) conditioned on being in state $\backslash$(x$\backslash$) at time $\backslash$(0$\backslash$).The first result is computability of the time evolution of observables, i.e., maps of the form $\backslash$((t,f)$\backslash$,\{$\backslash$mapsto \}$\backslash$, P\_\{t\} f$\backslash$), under conditions that imply existence of a Banach sequence space of observables on which the transition function $\backslash$( P\_\{t\} $\backslash$) of a fixed CTMC induces a family of bounded linear operators that vary continuously in time (w.r.t. the usual topology on bounded operators). The second result is PTIME-computability of the projections $\backslash$(t$\backslash$,\{$\backslash$mapsto \}$\backslash$,( P\_\{t\} f)(x)$\backslash$), for each state $\backslash$(x$\backslash$), provided that the rate matrix of the CTMC $\backslash$(X\_t$\backslash$) is locally algebraic on a subspace containing the observable $\backslash$(f$\backslash$).The results are flexible enough to accommodate unbounded observables; explicit examples feature the token counts in stochastic Petri nets and sub-string occurrences of stochastic string rewriting systems. The results provide a functional analytic alternative to Monte Carlo simulation as test bed for mean-field approximations, moment closure, and similar techniques that are fast, but lack absolute error guarantees.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_20},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Danos, Vincent and Heindel, Tobias and Garnier, Ilias and Simonsen, Jakob Grue},
  month = apr,
  year = {2017},
  pages = {338-354},
  file = {/Users/doisinkidney/Zotero/storage/UNQX5HGF/978-3-662-54458-7_20.html}
}

@inproceedings{lange_undecidability_2017,
  series = {Lecture Notes in Computer Science},
  title = {On the {{Undecidability}} of {{Asynchronous Session Subtyping}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_26},
  abstract = {Asynchronous session subtyping has been studied extensively in [9, 10, 28, 29, 30, 31] and applied in [23, 32, 33, 35]. An open question was whether this subtyping relation is decidable. This paper settles the question in the negative. To prove this result, we first introduce a new sub-class of two-party communicating finite-state machines (CFSMs), called asynchronous duplex (ADs), which we show to be Turing complete. Secondly, we give a compatibility relation over CFSMs, which is sound and complete wrt. safety for ADs, and is equivalent to the asynchronous subtyping. Then we show that the halting problem reduces to checking whether two CFSMs are in the relation. In addition, we show the compatibility relation to be decidable for three sub-classes of ADs.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_26},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Lange, Julien and Yoshida, Nobuko},
  month = apr,
  year = {2017},
  pages = {441-457},
  file = {/Users/doisinkidney/Zotero/storage/FAPTT5RB/978-3-662-54458-7_26.html}
}

@inproceedings{blanchette_lambda-free_2017,
  series = {Lecture Notes in Computer Science},
  title = {A {{Lambda}}-{{Free Higher}}-{{Order Recursive Path Order}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_27},
  abstract = {We generalize the recursive path order (RPO) to higher-order terms without $\backslash$($\backslash$lambda $\backslash$)-abstraction. This new order fully coincides with the standard RPO on first-order terms also in the presence of currying, distinguishing it from previous work. It has many useful properties, including well-foundedness, transitivity, stability under substitution, and the subterm property. It appears promising as the basis of a higher-order superposition calculus.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_27},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Blanchette, Jasmin Christian and Waldmann, Uwe and Wand, Daniel},
  month = apr,
  year = {2017},
  pages = {461-479},
  file = {/Users/doisinkidney/Zotero/storage/MRKJNJ5L/978-3-662-54458-7_27.html}
}

@inproceedings{bian_relationship_2017,
  series = {Lecture Notes in Computer Science},
  title = {On the {{Relationship Between Bisimulation}} and {{Trace Equivalence}} in an {{Approximate Probabilistic Context}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_19},
  abstract = {This work introduces a notion of approximate probabilistic trace equivalence for labelled Markov chains, and relates this new concept to the known notion of approximate probabilistic bisimulation. In particular this work shows that the latter notion induces a tight upper bound on the approximation between finite-horizon traces, as expressed by a total variation distance. As such, this work extends corresponding results for exact notions and analogous results for non-probabilistic models. This bound can be employed to relate the closeness in satisfaction probabilities over bounded linear-time properties, and allows for probabilistic model checking of concrete models via abstractions. The contribution focuses on both finite-state and uncountable-state labelled Markov chains, and claims two main applications: firstly, it allows an upper bound on the trace distance to be decided for finite state systems; secondly, it can be used to synthesise discrete approximations to continuous-state models with arbitrary precision.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_19},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Bian, Gaoang and Abate, Alessandro},
  month = apr,
  year = {2017},
  pages = {321-337},
  file = {/Users/doisinkidney/Zotero/storage/IRDCEY2H/978-3-662-54458-7_19.html}
}

@inproceedings{cruz-filipe_paths_2017,
  series = {Lecture Notes in Computer Science},
  title = {The {{Paths}} to {{Choreography Extraction}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_25},
  abstract = {Choreographies are global descriptions of interactions among concurrent components, most notably used in the settings of verification and synthesis of correct-by-construction software. They require a top-down approach: programmers first write choreographies, and then use them to verify or synthesize their programs. However, most software does not come with choreographies yet, which prevents their application. To attack this problem, previous work investigated choreography extraction, which automatically constructs a choreography that describes the behavior of a given set of programs or protocol specifications.We propose a new extraction methodology that improves on the state of the art: we can deal with programs that are equipped with state and internal computation; time complexity is dramatically better; and we capture programs that work by exploiting asynchronous communication.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_25},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {{Cruz-Filipe}, Lu{\'\i}s and Larsen, Kim S. and Montesi, Fabrizio},
  month = apr,
  year = {2017},
  pages = {424-440},
  file = {/Users/doisinkidney/Zotero/storage/34N8UZKQ/978-3-662-54458-7_25.html}
}

@inproceedings{baldan_local_2017,
  series = {Lecture Notes in Computer Science},
  title = {Local {{Model Checking}} in a {{Logic}} for {{True Concurrency}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_24},
  abstract = {We provide a model-checking technique for a logic for true concurrency, whose formulae predicate about events in computations and their causal dependencies. The logic, that represents the logical counterpart of history-preserving bisimilarity, is naturally interpreted over event structures. It includes minimal and maximal fixpoint operators and thus it can express properties of infinite computations. Global algorithms are not convenient in this setting, since the event structure associated with a system is typically infinite (even if the system is finite state), a fact that makes also the decidability of model-checking non-trivial. Focusing on the alternation free fragment of the logic, along the lines of some classical work for the modal mu-calculus, we propose a local model-checking algorithm. The algorithm is given in the form of a tableau system, for which, over a class of event structures satisfying a suitable regularity condition, we prove termination, soundness and completeness.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_24},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Baldan, Paolo and Padoan, Tommaso},
  month = apr,
  year = {2017},
  pages = {407-423},
  file = {/Users/doisinkidney/Zotero/storage/2CK7SV26/978-3-662-54458-7_24.html}
}

@inproceedings{breuvart_higher-order_2017,
  series = {Lecture Notes in Computer Science},
  title = {On {{Higher}}-{{Order Probabilistic Subrecursion}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_22},
  abstract = {We study the expressive power of subrecursive probabilistic higher-order calculi. More specifically, we show that endowing a very expressive deterministic calculus like G{\"o}del's $\backslash$($\backslash$mathbb \{T\}$\backslash$) with various forms of probabilistic choice operators may result in calculi which are not equivalent as for the class of distributions they give rise to, although they all guarantee almost-sure termination. Along the way, we introduce a probabilistic variation of the classic reducibility technique, and we prove that the simplest form of probabilistic choice leaves the expressive power of $\backslash$($\backslash$mathbb \{T\}$\backslash$) essentially unaltered. The paper ends with some observations about functional expressivity: expectedly, all the considered calculi represent precisely the functions which $\backslash$($\backslash$mathbb \{T\}$\backslash$) itself represents.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_22},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Breuvart, Flavien and Lago, Ugo Dal and Herrou, Agathe},
  month = apr,
  year = {2017},
  pages = {370-386},
  file = {/Users/doisinkidney/Zotero/storage/266HYCLC/978-3-662-54458-7_22.html}
}

@inproceedings{severi_light_2017-1,
  series = {Lecture Notes in Computer Science},
  title = {A {{Light Modality}} for {{Recursion}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_29},
  abstract = {We investigate a modality for controlling the behaviour of recursive functional programs on infinite structures which is completely silent in the syntax. The latter means that programs do not contain ``marks'' showing the application of the introduction and elimination rules for the modality. This shifts the burden of controlling recursion from the programmer to the compiler.To do this, we introduce a typed lambda calculus {\`a} la Curry with a silent modality and guarded recursive types. The typing discipline guarantees normalisation and can be transformed into an algorithm which infers the type of a program.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_29},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Severi, Paula},
  month = apr,
  year = {2017},
  keywords = {Computer Science - Programming Languages,Computer Science - Logic in Computer Science},
  pages = {499-516},
  file = {/Users/doisinkidney/Zotero/storage/BNLTX6LG/Severi - 2017 - A Light Modality for Recursion.pdf;/Users/doisinkidney/Zotero/storage/LXIKF3P8/1801.html;/Users/doisinkidney/Zotero/storage/V4RLXQ9M/978-3-662-54458-7_29.html}
}

@inproceedings{sakayori_truly_2017,
  series = {Lecture Notes in Computer Science},
  title = {A {{Truly Concurrent Game Model}} of the {{Asynchronous}} \$\$$\backslash$pi \$\$-{{Calculus}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_23},
  abstract = {In game semantics, a computation is represented by a play, which is traditionally a sequence of messages exchanged by a program and an environment. Because of the sequentiality of plays, most game models for concurrent programs are a kind of interleaving semantics. Several frameworks for truly concurrent game models have been proposed, but no model has yet been applied to give a semantics of a complex concurrent calculus such as the $\backslash$($\backslash$pi $\backslash$)-calculus (with replication).This paper proposes a truly concurrent version of the HO/N game model in which a play is not a sequence but a directed acyclic graph (DAG) with two kinds edges, justification pointers and causal edges. By using this model, we give the first truly concurrent game semantics for the asynchronous $\backslash$($\backslash$pi $\backslash$)-calculus. In order to illustrate a possible application, we propose an intersection type system for the asynchronous $\backslash$($\backslash$pi $\backslash$)-calculus by means of our game model, and discuss when a process can be completely characterised by the intersection type system.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_23},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Sakayori, Ken and Tsukada, Takeshi},
  month = apr,
  year = {2017},
  pages = {389-406},
  file = {/Users/doisinkidney/Zotero/storage/592G4F9N/978-3-662-54458-7_23.html}
}

@inproceedings{altenkirch_partiality_2017,
  series = {Lecture Notes in Computer Science},
  title = {Partiality, {{Revisited}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_31},
  abstract = {Capretta's delay monad can be used to model partial computations, but it has the ``wrong'' notion of built-in equality, strong bisimilarity. An alternative is to quotient the delay monad by the ``right'' notion of equality, weak bisimilarity. However, recent work by Chapman et al. suggests that it is impossible to define a monad structure on the resulting construction in common forms of type theory without assuming (instances of) the axiom of countable choice.Using an idea from homotopy type theory\textemdash{}a higher inductive-inductive type\textemdash{}we construct a partiality monad without relying on countable choice. We prove that, in the presence of countable choice, our partiality monad is equivalent to the delay monad quotiented by weak bisimilarity. Furthermore we outline several applications.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_31},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Altenkirch, Thorsten and Danielsson, Nils Anders and Kraus, Nicolai},
  month = apr,
  year = {2017},
  pages = {534-549},
  file = {/Users/doisinkidney/Zotero/storage/5NKZK8MQ/978-3-662-54458-7_31.html}
}

@incollection{esparza_partiality_2017-2,
  address = {Berlin, Heidelberg},
  title = {Partiality, {{Revisited}}},
  volume = {10203},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  abstract = {Capretta's delay monad can be used to model partial computations, but it has the ``wrong'' notion of built-in equality, strong bisimilarity. An alternative is to quotient the delay monad by the ``right'' notion of equality, weak bisimilarity. However, recent work by Chapman et al. suggests that it is impossible to define a monad structure on the resulting construction in common forms of type theory without assuming (instances of) the axiom of countable choice.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://link.springer.com/10.1007/978-3-662-54458-7_31},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Altenkirch, Thorsten and Danielsson, Nils Anders and Kraus, Nicolai},
  editor = {Esparza, Javier and Murawski, Andrzej S.},
  year = {2017},
  pages = {534-549},
  file = {/Users/doisinkidney/Zotero/storage/CTLM5XDQ/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/L8F98IQM/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/XGDP694U/Altenkirch et al. - 2017 - Partiality, Revisited.pdf},
  doi = {10.1007/978-3-662-54458-7_31}
}

@article{porter_monad.reader_2011,
  title = {The {{Monad}}.{{Reader Issue}} 18},
  volume = {18},
  language = {en},
  number = {18},
  urldate = {2018-06-19},
  url = {https://themonadreader.files.wordpress.com/2011/07/issue18.pdf},
  journal = {The Monad.Reader},
  author = {Porter, Julian and Petricek, Tomas and Auclair, Douglas M.},
  month = jul,
  year = {2011},
  pages = {51},
  file = {/Users/doisinkidney/Zotero/storage/VYXGI2J4/issue18.pdf}
}

@inproceedings{kiselyov_iteratees_2012-1,
  address = {Berlin, Heidelberg},
  series = {Lecture Notes in Computer Science},
  title = {Iteratees},
  isbn = {978-3-642-29821-9 978-3-642-29822-6},
  doi = {10.1007/978-3-642-29822-6_15},
  abstract = {Iteratee IO is a style of incremental input processing with precise resource control. The style encourages building input processors from a user-extensible set of primitives by chaining, layering, pairing and other modes of compositions. The programmer is still able, where needed, to precisely control look-ahead, the allocation of buffers, file descriptors and other resources. The style is especially suitable for processing of communication streams, large amount of data, and data undergone several levels of encoding such as pickling, compression, chunking, framing. It has been used for programming high-performance (HTTP) servers and web frameworks, in computational linguistics and financial trading.We exposit programming with iteratees, contrasting them with Lazy IO and the Handle-based, |stdio|-like IO. We relate them to online parser combinators. We introduce a simple implementation as free monads, which lets us formally reason with iteratees. As an example, we validate several equational laws and use them to optimize iteratee programs. The simple implementation helps understand existing implementations of iteratees and derive new ones.},
  language = {en},
  urldate = {2018-06-20},
  url = {http://okmij.org/ftp/Haskell/Iteratee/describe.pdf},
  booktitle = {Proceedings of the 11th {{International Conference}} on {{Functional}} and {{Logic Programming}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Kiselyov, Oleg},
  month = may,
  year = {2012},
  pages = {166-181},
  file = {/Users/doisinkidney/Zotero/storage/GICHJUA3/describe.pdf;/Users/doisinkidney/Zotero/storage/ATVQF2VL/978-3-642-29822-6_15.html}
}

@unpublished{freeman_stack_2015,
  title = {Stack {{Safety}} for {{Free}}},
  abstract = {Free monads are a useful tool for abstraction, separating specification from interpretation. However, a na{\"\i}ve free monad implementation can lead to stack overflow depending on the evaluation model of the host language. This paper develops a stack-safe free monad transformer in PureScript, a strict Haskell-like language compiling to Javascript, and demonstrates certain applications - a safe implementation of coroutines, a safe list monad transformer, and a generic mechanism for building stack-safe control operators.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://functorial.com/stack-safety-for-free/index.pdf},
  author = {Freeman, Phil},
  month = aug,
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/YLS48PF3/Freeman - Stack Safety for Free.pdf}
}

@inproceedings{capretta_partiality_2004,
  address = {Dagstuhl, Germany},
  series = {Dagstuhl Seminar Proceedings},
  title = {Partiality Is an Effect},
  volume = {04381},
  language = {en},
  url = {https://www.ioc.ee/~tarmo/tday-veskisilla/uustalu-slides.pdf},
  booktitle = {Dependently {{Typed Programming}}},
  publisher = {{Internationales Begegnungs- und Forschungszentrum f{\"u}r Informatik (IBFI), Schloss Dagstuhl, Germany}},
  author = {Capretta, Venanzio and Altenkirch, Thorsten and Uustalu, Tarmo},
  month = sep,
  year = {2004},
  pages = {20},
  file = {/Users/doisinkidney/Zotero/storage/WHH6R3QU/Uustalu - Partiality is an effect.pdf}
}

@book{DBLP:conf/dagstuhl/2004P4381,
  series = {Dagstuhl Seminar Proceedings},
  title = {Dependently {{Typed Programming}}, 12.09. - 17.09.2004},
  volume = {04381},
  url = {http://drops.dagstuhl.de/portals/04381/},
  publisher = {{Internationales Begegnungs- und Forschungszentrum f{\"u}r Informatik (IBFI), Schloss Dagstuhl, Germany}},
  editor = {Altenkirch, Thorsten and Hofmann, Martin and Hughes, John},
  year = {2004},
  biburl = {https://dblp.org/rec/bib/conf/dagstuhl/2004P4381},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


