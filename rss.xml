<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Donnacha Oisín Kidney's Blog</title>
        <link>http://doisinkidney.com</link>
        <description><![CDATA[Mainly writing about programming]]></description>
        <atom:link href="http://doisinkidney.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 30 Sep 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Probability Trees</title>
    <link>http://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 30, 2016
</div>
<div class="info">
    
        Part 3 of a <a href="/series/probability.html">3-part series on probability</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span>
<span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span>

<span class="kw">module</span> <span class="dt">ProbTree</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Data.Ratio</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span></code></pre></div>
<p>Previously, I tried to figure out how to make the probability monad more “listy”. I read a little more about the topic <span class="citation">(especially Erwig and Kollmansberger 2006; and Kidd 2007)</span>.</p>
<p>I then thought about what a probability monad would look like if it was based on other data structures. I feel like the standard version really wants to be:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ProperProb</span> a <span class="fu">=</span> <span class="dt">ProperProb</span>
  {<span class="ot"> yes ::</span> <span class="dt">Map</span> a (<span class="dt">Product</span> <span class="dt">Rational</span>) }</code></pre></div>
<p>But of course a monad instance isn’t allowed.</p>
<p>Similar to a map, though, is a binary tree:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span>
                  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)</code></pre></div>
<p>And it feels better for probability - <em>flatter</em>, somehow. Transmuting it into a probability-thing:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certain</span> a
            <span class="fu">|</span> <span class="dt">Choice</span> (<span class="dt">Odds</span> a) <span class="dt">Rational</span> (<span class="dt">Odds</span> a)
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</code></pre></div>
<p>That looks good to me. A choice between two different branches feels more natural than a choice between a head and a tail.</p>
<p>The fold is similar to before, with an unfold for good measure:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b
foldOdds f b <span class="fu">=</span> r <span class="kw">where</span>
  r (<span class="dt">Certain</span> x) <span class="fu">=</span> b x
  r (<span class="dt">Choice</span> xs p ys) <span class="fu">=</span> f (r xs) p (r ys)
  
<span class="ot">unfoldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Either</span> a (b,<span class="dt">Rational</span>,b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
unfoldOdds f <span class="fu">=</span> r <span class="kw">where</span>
  r b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span>
    <span class="dt">Left</span> a <span class="ot">-&gt;</span> <span class="dt">Certain</span> a
    <span class="dt">Right</span> (x,p,y) <span class="ot">-&gt;</span> <span class="dt">Choice</span> (r x) p (r y)
  
<span class="ot">fi ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
fi <span class="dt">True</span>  t _ <span class="fu">=</span> t
fi <span class="dt">False</span> _ f <span class="fu">=</span> f</code></pre></div>
<p>I changed the pattern synonym a little:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">
<span class="ot">unRatio ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> (a,a)
unRatio <span class="fu">=</span> numerator   <span class="fu">&amp;&amp;&amp;</span> denominator 
      <span class="fu">&gt;&gt;&gt;</span> fromInteger <span class="fu">***</span> fromInteger

pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (unRatio <span class="ot">-&gt;</span> (n,d))</code></pre></div>
<p>Then, the <code class="sourceCode haskell">probOf</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOf e <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> fi (e <span class="fu">==</span> x) <span class="dv">1</span> <span class="dv">0</span>
  f x (n<span class="fu">:%</span>d) y <span class="fu">=</span> (x <span class="fu">*</span> n <span class="fu">+</span> y <span class="fu">*</span> d) <span class="fu">/</span> (n <span class="fu">+</span> d)</code></pre></div>
<p>This version doesn’t have the option for short-circuiting on the first value it finds.</p>
<p>For generating from lists, you can try to evenly divide the list among each branch.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">fromListOdds ::</span> (([b], <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromListOdds fr e <span class="fu">=</span> r <span class="kw">where</span>
  r [] <span class="fu">=</span> <span class="dt">Nothing</span>
  r xs <span class="fu">=</span> <span class="dt">Just</span> (unfoldOdds f (xs, length xs))
  f ([x],_) <span class="fu">=</span> <span class="dt">Left</span> (e x)
  f (xs ,n) <span class="fu">=</span> <span class="dt">Right</span> ((ys,l), fr (ys,l) <span class="fu">%</span> fr (zs,r), (zs,r)) <span class="kw">where</span>
    l <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span>
    r <span class="fu">=</span> n <span class="fu">-</span> l
    (ys,zs) <span class="fu">=</span> splitAt l xs

<span class="ot">equalOdds ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
equalOdds <span class="fu">=</span> fromListOdds (fromIntegral <span class="fu">.</span> snd) id

<span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromDistrib <span class="fu">=</span> fromListOdds (sum <span class="fu">.</span> map snd <span class="fu">.</span> fst) fst</code></pre></div>
<p>What’s really nice about this version is the fact that the old <code class="sourceCode haskell">append</code> is just the <code class="sourceCode haskell"><span class="dt">Choice</span></code> constructor, leaving the instances to be really nice:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
flatten <span class="fu">=</span> foldOdds <span class="dt">Choice</span> id

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Certain</span>
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)
  
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</code></pre></div>
<p>Finally, as a bonus, to remove duplicates:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">lcd ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
lcd <span class="fu">=</span> foldl&#39; (\a e <span class="ot">-&gt;</span> lcm a (denominator e)) <span class="dv">1</span>

<span class="ot">toDistrib ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> [(a,<span class="dt">Integer</span>)]
toDistrib <span class="fu">=</span> factorOut <span class="fu">.</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> [(x,<span class="dv">1</span>)]
  f l p r <span class="fu">=</span> (map<span class="fu">.</span>fmap) (n<span class="fu">%</span>t<span class="fu">*</span>) l <span class="fu">++</span> (map<span class="fu">.</span>fmap) (d<span class="fu">%</span>t<span class="fu">*</span>) r <span class="kw">where</span>
    n <span class="fu">=</span> numerator p
    d <span class="fu">=</span> denominator p
    t <span class="fu">=</span> n <span class="fu">+</span> d
  factorOut xs <span class="fu">=</span> (map<span class="fu">.</span>fmap) (numerator <span class="fu">.</span> (lcd&#39;<span class="fu">*</span>)) xs <span class="kw">where</span>
    lcd&#39; <span class="fu">=</span> fromIntegral <span class="fu">.</span> lcd <span class="fu">.</span> map snd <span class="fu">$</span> xs

<span class="ot">counts ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> n) <span class="ot">=&gt;</span> [(a,n)] <span class="ot">-&gt;</span> [(a,n)]
counts <span class="fu">=</span> 
  Map.assocs <span class="fu">.</span> 
  Map.fromListWith (<span class="fu">+</span>)
      
<span class="ot">compress ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
compress xs <span class="fu">=</span> <span class="kw">let</span> <span class="dt">Just</span> ys <span class="fu">=</span> (fromDistrib <span class="fu">.</span> counts <span class="fu">.</span> toDistrib) xs <span class="kw">in</span> ys</code></pre></div>
<p>After reading yet more on this, I found that the main issue with the monad is its performance. Two articles in particular: <span class="citation">Larsen (2011)</span>, and <span class="citation">Scibior, Ghahramani, and Gordon (2015)</span>, refer to a GADT implementation of the monad which maximises laziness.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. <a href="http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf">http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.” <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory efficient implementation of probability monads.” <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf" class="uri">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-scibior_practical_2015">
<p>Scibior, A., Z. Ghahramani, and A. D. Gordon. 2015. “Practical probabilistic programming with monads.” In <em>2015 ACM SIGPLAN symposium on haskell</em>, 50:165–176. ACM. <a href="http://mlg.eng.cam.ac.uk/pub/pdf/SciGhaGor15.pdf" class="uri">http://mlg.eng.cam.ac.uk/pub/pdf/SciGhaGor15.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 30 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Different Probability Monad</title>
    <link>http://doisinkidney.com/posts/2016-09-27-odds-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 27, 2016
</div>
<div class="info">
    
        Part 2 of a <a href="/series/probability.html">3-part series on probability</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>One of the more unusual monads is the “probability monad”:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span>
<span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span>
<span class="ot">{-# language BangPatterns #-}</span>

<span class="kw">module</span> <span class="dt">Prob</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Data.Ratio</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Probability</span> a <span class="fu">=</span> <span class="dt">Probability</span>
  {<span class="ot"> runProb ::</span> [(a,<span class="dt">Rational</span>)] }
  
<span class="kw">data</span> <span class="dt">Coin</span> <span class="fu">=</span> <span class="dt">Heads</span> <span class="fu">|</span> <span class="dt">Tails</span>

<span class="ot">toss ::</span> <span class="dt">Probability</span> <span class="dt">Coin</span>
toss <span class="fu">=</span> <span class="dt">Probability</span> [(<span class="dt">Heads</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>), (<span class="dt">Tails</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>)]</code></pre></div>
<p>Although it’s a little inefficient, it’s an elegant representation. I’ve written about it before <a href="2015-08-03-monty-hall.html">here</a>.</p>
<p>It has some notable deficiencies, though. For instance: the user has to constantly check that all the probabilities add up to one. Its list can be empty, which doesn’t make sense. Also, individual outcomes can appear more than once in the same list.</p>
<p>A first go a fixing the problem might look something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Distrib</span> a <span class="fu">=</span> <span class="dt">Distrib</span>
  {<span class="ot"> runDist ::</span> [(a,<span class="dt">Rational</span>)] }

<span class="ot">tossProb ::</span> <span class="dt">Distrib</span> <span class="dt">Coin</span>
tossProb <span class="fu">=</span> <span class="dt">Distrib</span> [(<span class="dt">Heads</span>, <span class="dv">1</span>), (<span class="dt">Tails</span>, <span class="dv">1</span>)]</code></pre></div>
<p>The type is the same as before: it’s the semantics which have changed. The second field of the tuples no longer have to add up to one. The list can still be empty, though, and now finding the probability of, say, the head, looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probHead ::</span> <span class="dt">Distrib</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probHead (<span class="dt">Distrib</span> xs<span class="fu">@</span>((_,p)<span class="fu">:</span>_)) <span class="fu">=</span> p <span class="fu">/</span> sum [ q <span class="fu">|</span> (_,q) <span class="ot">&lt;-</span> xs ]</code></pre></div>
<p>Infinite lists aren’t possible, either.</p>
<p>One other way to look at the problem is to mimic the structure of cons-lists. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certainly</span> a
            <span class="fu">|</span> <span class="dt">Odds</span> a <span class="dt">Rational</span> (<span class="dt">Odds</span> a)
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Here, the <code class="sourceCode haskell"><span class="dt">Odds</span></code> constructor (analogous to <code class="sourceCode haskell">(<span class="fu">:</span>)</code>) contains the betting-style odds of the head element vs. <em>the rest of the list</em>. The coin from before is represented by:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">tossOdds ::</span> <span class="dt">Odds</span> <span class="dt">Coin</span>
tossOdds <span class="fu">=</span> <span class="dt">Odds</span> <span class="dt">Heads</span> (<span class="dv">1</span> <span class="fu">%</span> <span class="dv">1</span>) (<span class="dt">Certainly</span> <span class="dt">Tails</span>)</code></pre></div>
<p>This representation has tons of nice properties. First, let’s use some pattern-synonym magic for rationals:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">pattern<span class="ot"> (:%) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span>
pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (numerator <span class="fu">&amp;&amp;&amp;</span> denominator <span class="ot">-&gt;</span> (n,d)) <span class="kw">where</span>
  n <span class="fu">:%</span> d <span class="fu">=</span> n <span class="fu">%</span> d</code></pre></div>
<p>Then, finding the probability of the head element is this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probHeadOdds ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probHeadOdds (<span class="dt">Certainly</span> _) <span class="fu">=</span> <span class="dv">1</span>
probHeadOdds (<span class="dt">Odds</span> _ (n <span class="fu">:%</span> d) _) <span class="fu">=</span> n <span class="fu">:%</span> (n <span class="fu">+</span> d)</code></pre></div>
<p>The representation can handle infinite lists no problem:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">probHeadOdds (<span class="dt">Odds</span> <span class="ch">&#39;a&#39;</span> (<span class="dv">1</span> <span class="fu">:%</span> <span class="dv">1</span>) undefined)
<span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span></code></pre></div>
<p>Taking the tail preserves semantics, also. To do some more involved manipulation, a fold helper is handy:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldOdds ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b
foldOdds f b <span class="fu">=</span> r <span class="kw">where</span>
  r (<span class="dt">Certainly</span> x) <span class="fu">=</span> b x
  r (<span class="dt">Odds</span> x p xs) <span class="fu">=</span> f x p (r xs)</code></pre></div>
<p>You can use this function to find the probability of a given item:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOfEvent ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOfEvent e <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> <span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
  f x n r <span class="fu">=</span> (<span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>This assumes that each item only occurs once. A function which combines multiple events might look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOf p <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
  f x n r <span class="fu">=</span> (<span class="kw">if</span> p x <span class="kw">then</span> r <span class="fu">+</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>Some utility functions to create <code class="sourceCode haskell"><span class="dt">Odds</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">equalOdds ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
equalOdds xs <span class="fu">=</span> <span class="kw">case</span> length xs <span class="kw">of</span>
  <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
  n <span class="ot">-&gt;</span> <span class="dt">Just</span> (foldr f undefined xs (n <span class="fu">-</span> <span class="dv">1</span>)) <span class="kw">where</span>
    f y a <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Certainly</span> y
    f y a n <span class="fu">=</span> <span class="dt">Odds</span> y (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (a (n <span class="fu">-</span> <span class="dv">1</span>))

<span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromDistrib [] <span class="fu">=</span> <span class="dt">Nothing</span>
fromDistrib xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> f (tot<span class="fu">*</span>lst) xs <span class="kw">where</span>
  (tot,lst) <span class="fu">=</span> foldl&#39; (\(<span class="fu">!</span>t,_) e <span class="ot">-&gt;</span> (t<span class="fu">+</span>e,e)) (<span class="dv">0</span>,undefined) (map snd xs)
  f _ [(x,_)] <span class="fu">=</span> <span class="dt">Certainly</span> x
  f n ((x,p)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Odds</span> x (mp <span class="fu">%</span> np) (f np xs) <span class="kw">where</span>
    mp <span class="fu">=</span> p <span class="fu">*</span> lst
    np <span class="fu">=</span> n <span class="fu">-</span> mp
                  
<span class="ot">probOfEach ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOfEach x xs <span class="fu">=</span> probOf (x<span class="fu">==</span>) xs

<span class="ot">propOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Rational</span>
propOf _ [] <span class="fu">=</span> <span class="dt">Nothing</span>
propOf x xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">.</span> uncurry (<span class="fu">%</span>) <span class="fu">$</span>
  foldl&#39; (\(<span class="fu">!</span>n,<span class="fu">!</span>m) e <span class="ot">-&gt;</span> (<span class="kw">if</span> x <span class="fu">==</span> e <span class="kw">then</span> n<span class="fu">+</span><span class="dv">1</span> <span class="kw">else</span> n, m<span class="fu">+</span><span class="dv">1</span>)) (<span class="dv">0</span>,<span class="dv">0</span>) xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">propOf x xs <span class="fu">==</span> fmap (probOfEach x) (equalOdds xs)</code></pre></div>
<p>And finally, the instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">append ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
append <span class="fu">=</span> foldOdds f <span class="dt">Odds</span> <span class="kw">where</span>
  f e r a p ys <span class="fu">=</span> <span class="dt">Odds</span> e ip (a op ys) <span class="kw">where</span>
    ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)
    op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
flatten <span class="fu">=</span> foldOdds append id

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Certainly</span>
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)
  
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</code></pre></div>
]]></description>
    <pubDate>Tue, 27 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-27-odds-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Revisiting a Trie in Haskell</title>
    <link>http://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 26, 2016
</div>
<div class="info">
    
        Part 2 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="conforming-to-foldable">Conforming to Foldable</h1>
<p>When I ended the last post, I had a nice <code class="sourceCode haskell"><span class="dt">Trie</span></code> datatype, with plenty of functions, but I couldn’t get it to conform to the standard Haskell classes. The problem was to do with the type variables in the Trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language GADTs, FlexibleInstances, TypeFamilies #-}</span>
<span class="ot">{-# language DeriveFoldable, DeriveFunctor, DeriveTraversable #-}</span>
<span class="ot">{-# language FunctionalDependencies, FlexibleInstances #-}</span>

<span class="kw">module</span> <span class="dt">Tries</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">IsList</span>(..))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OldTrie</span> a <span class="fu">=</span> <span class="dt">OldTrie</span>
  {<span class="ot"> otEndHere  ::</span> <span class="dt">Bool</span>
  ,<span class="ot"> otChildren ::</span> <span class="dt">Map</span> a (<span class="dt">OldTrie</span> a) }</code></pre></div>
<p>Although the type variable is <code class="sourceCode haskell">a</code>, the trie really contains <em>lists</em> of <code class="sourceCode haskell">a</code>s. At least, that’s what’s reflected in functions like <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">member</code>, etc.:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">member ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f otEndHere <span class="kw">where</span>
  f e a <span class="fu">=</span> maybe <span class="dt">False</span> a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> otChildren
  
<span class="ot">otInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a
otInsert <span class="fu">=</span> foldr f b <span class="kw">where</span>
  b (<span class="dt">OldTrie</span> _ c) <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">True</span> c
  f e a (<span class="dt">OldTrie</span> n c) <span class="fu">=</span> <span class="dt">OldTrie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)
  
<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">OldTrie</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">False</span> mempty
  <span class="dt">OldTrie</span> v c <span class="ot">`mappend`</span> <span class="dt">OldTrie</span> t d <span class="fu">=</span> 
    <span class="dt">OldTrie</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</code></pre></div>
<p>Realistically, the type which the trie contains is more like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Trie</span> (f a)</code></pre></div>
<p>That signature strongly hints at GADTs, as was indicated by <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">this stackoverflow answer</a>. The particular GADT which is applicable here is this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TrieSet</span> a <span class="kw">where</span> <span class="dt">TrieSet</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">tsEndHere ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
tsEndHere (<span class="dt">TrieSet</span> e _) <span class="fu">=</span> e

<span class="ot">tsChildren ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a])
tsChildren (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> c

<span class="ot">tsInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]
tsInsert <span class="fu">=</span> foldr f b <span class="kw">where</span>
<span class="ot">  b ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]
<span class="ot">  f ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (<span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]

  b (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">True</span> c
  f e a (<span class="dt">TrieSet</span> n c) <span class="fu">=</span> <span class="dt">TrieSet</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)
  
<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">False</span> Map.empty
  <span class="dt">TrieSet</span> v c <span class="ot">`mappend`</span> <span class="dt">TrieSet</span> t d <span class="fu">=</span> 
    <span class="dt">TrieSet</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</code></pre></div>
<p>Why lists and not a general <code class="sourceCode haskell"><span class="dt">Foldable</span></code>? Well, for the particular use I had in mind (conforming to the <code class="sourceCode haskell"><span class="dt">Foldable</span></code> typeclass), I need <code class="sourceCode haskell">(<span class="fu">:</span>)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">TrieSet</span> <span class="kw">where</span>
  foldr f b (<span class="dt">TrieSet</span> e c) <span class="fu">=</span> <span class="kw">if</span> e <span class="kw">then</span> f [] r <span class="kw">else</span> r <span class="kw">where</span>
    r <span class="fu">=</span> Map.foldrWithKey (flip <span class="fu">.</span> g <span class="fu">.</span> (<span class="fu">:</span>)) b c
    g k <span class="fu">=</span> foldr (f <span class="fu">.</span> k)</code></pre></div>
<p>With some more helper functions, the interface becomes pretty nice:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  showsPrec d t <span class="fu">=</span> 
    showParen 
      (d <span class="fu">&gt;</span> <span class="dv">10</span>)
      (showString <span class="st">&quot;fromList &quot;</span> <span class="fu">.</span> shows (foldr (<span class="fu">:</span>) [] t))

<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">TrieSet</span> [a]) <span class="fu">=</span> [a]
  fromList <span class="fu">=</span> foldr tsInsert mempty
  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</code></pre></div>
<p>The trie has the side-effect of lexicographically sorting what it’s given:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XGADTs</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">fromList [<span class="st">&quot;ced&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ced&quot;</span>, <span class="st">&quot;cb&quot;</span>, <span class="st">&quot;ab&quot;</span>]<span class="ot"> ::</span> <span class="dt">TrieSet</span> <span class="dt">String</span>
fromList [<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;abc&quot;</span>,<span class="st">&quot;cb&quot;</span>,<span class="st">&quot;ced&quot;</span>]</code></pre></div>
<h1 id="further-generalizing">Further Generalizing</h1>
<p>Most implementations of tries that I’ve seen are map-like data structures, rather than set-like. In other words, instead of holding a <code class="sourceCode haskell"><span class="dt">Bool</span></code> at the value position, it holds a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> something.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">
<span class="kw">data</span> <span class="dt">Trie</span> a b <span class="fu">=</span> <span class="dt">Trie</span>
  {<span class="ot"> endHere  ::</span> b
  ,<span class="ot"> children ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a b) 
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</code></pre></div>
<p>This is a much more straightforward datatype. <code class="sourceCode haskell"><span class="dt">Foldable</span></code> can even be automatically derived.</p>
<p>However, I haven’t made the <code class="sourceCode haskell">endHere</code> field a <code class="sourceCode haskell"><span class="dt">Maybe</span> a</code>. I want to be able to write something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieSet</span> [a] <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Bool</span>
<span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Maybe</span> b)</code></pre></div>
<p>And have it automatically choose the implementation of the functions I need<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>To do that, though, I’ll need to write the base functions, agnostic of the type of <code>b</code>. I <em>can</em> rely on something like <code class="sourceCode haskell"><span class="dt">Monoid</span></code>, though:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Trie</span> mempty Map.empty
  mappend (<span class="dt">Trie</span> v k) (<span class="dt">Trie</span> t l) <span class="fu">=</span> 
    <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) k l)</code></pre></div>
<p>In fact, quite a lot of functions naturally lend themselves to this fold + monoid style:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> b
lookup <span class="fu">=</span> foldr f endHere <span class="kw">where</span>
  f e a <span class="fu">=</span> foldMap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> children

<span class="ot">insert&#39; ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b
insert&#39; xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> 
    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c) </code></pre></div>
<p>A monoid is needed for the values, though, and neither <code class="sourceCode haskell"><span class="dt">Bool</span></code> nor <code class="sourceCode haskell"><span class="ot">∀</span> a<span class="fu">.</span> <span class="dt">Maybe</span> a</code> conform to <code class="sourceCode haskell"><span class="dt">Monoid</span></code>. Looking back to the implementation of the trie-set, the <code class="sourceCode haskell">(<span class="fu">||</span>)</code> function has been replaced by <code class="sourceCode haskell">mappend</code>. There <em>is</em> a newtype wrapper in <code class="sourceCode haskell"><span class="dt">Data.Monoid</span></code> which has exactly this behaviour, though: <code class="sourceCode haskell"><span class="dt">Any</span></code>.</p>
<p>Using that, the type signatures specialize to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieSet</span> a <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Any</span>
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">Any</span>
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Any</span> <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</code></pre></div>
<p>Similarly, for <code class="sourceCode haskell"><span class="dt">Maybe</span></code>, there’s both <code class="sourceCode haskell"><span class="dt">First</span></code> and <code class="sourceCode haskell"><span class="dt">Last</span></code>. They have the behaviour:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span class="dt">First</span> (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">First</span> (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">First</span> (<span class="dt">Just</span> x)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span class="dt">Last</span>  (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y)</code></pre></div>
<p>I think it makes more sense for a value inserted into a map to overwrite whatever was there before. Since the newer value is on the left in the <code class="sourceCode haskell">mappend</code>, then, <code class="sourceCode haskell"><span class="dt">First</span></code> makes most sense.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">First</span> b)
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">First</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</code></pre></div>
<p>There are some other ways that you can interpret the monoid. For instance, subbing in <code class="sourceCode haskell"><span class="dt">Sum</span> <span class="dt">Int</span></code> gives you a bag-like trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieBag</span> a <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Sum</span> <span class="dt">Int</span>)
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span>
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a</code></pre></div>
<p>This is a set which can store multiple copies of each member. Turned the other way around, a map which stores many values for each key looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieBin</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a [b]
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> [b]
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</code></pre></div>
<p>This method so far isn’t really satisfying, though. Really, the <code class="sourceCode haskell">insert</code> signatures should look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</code></pre></div>
<p>Modifying insert slightly, you can get exactly that:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Applicative</span> c, <span class="dt">Monoid</span> (c b)) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b) <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b)
insert xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (pure v <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</code></pre></div>
<p><code class="sourceCode haskell">pure</code> from <code class="sourceCode haskell"><span class="dt">Applicative</span></code> is needed for the “embedding”.</p>
<p>Similarly, the “inserting” for the set-like types isn’t really right. The value argument is out of place. This should be the signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a
<span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a</code></pre></div>
<p>In particular, while we have an “empty” thing (0, False) for monoids, we need a “one” thing (1, True) for this function. A semiring<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> gives this exact method:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> a <span class="kw">where</span>
<span class="ot">  one ::</span> a
<span class="ot">  mul ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
  
<span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Sum</span> a) <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dv">1</span>
  mul <span class="fu">=</span> (<span class="fu">*</span>)

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Any</span> <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dt">Any</span> <span class="dt">True</span>
  <span class="dt">Any</span> x <span class="ot">`mul`</span> <span class="dt">Any</span> y <span class="fu">=</span> <span class="dt">Any</span> (x <span class="fu">&amp;&amp;</span> y)</code></pre></div>
<p>This class is kind of like a combination of both monoid wrappers for both <code class="sourceCode haskell"><span class="dt">Int</span></code> and <code class="sourceCode haskell"><span class="dt">Bool</span></code>. You could take advantage of that:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">
<span class="kw">class</span> (<span class="dt">Monoid</span> add, <span class="dt">Monoid</span> mult)
  <span class="ot">=&gt;</span> <span class="dt">SemiringIso</span> a add mult <span class="fu">|</span> a <span class="ot">-&gt;</span> add, a <span class="ot">-&gt;</span> mult <span class="kw">where</span>
<span class="ot">    toAdd    ::</span> a <span class="ot">-&gt;</span> add
<span class="ot">    fromAdd  ::</span> add <span class="ot">-&gt;</span> a
<span class="ot">    toMult   ::</span> a <span class="ot">-&gt;</span> mult
<span class="ot">    fromMult ::</span> mult <span class="ot">-&gt;</span> a
  
(<span class="fu">&lt;+&gt;</span>),<span class="ot"> (&lt;.&gt;) ::</span> <span class="dt">SemiringIso</span> a add mult <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> fromAdd  (toAdd  x <span class="fu">&lt;&gt;</span> toAdd  y)
x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> fromMult (toMult x <span class="fu">&lt;&gt;</span> toMult y)

<span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Int</span> (<span class="dt">Sum</span> <span class="dt">Int</span>) (<span class="dt">Product</span> <span class="dt">Int</span>) <span class="kw">where</span>
  toAdd    <span class="fu">=</span> <span class="dt">Sum</span>
  fromAdd  <span class="fu">=</span> getSum
  toMult   <span class="fu">=</span> <span class="dt">Product</span>
  fromMult <span class="fu">=</span> getProduct
  
<span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Bool</span> <span class="dt">Any</span> <span class="dt">All</span> <span class="kw">where</span>
  toAdd    <span class="fu">=</span> <span class="dt">Any</span>
  fromAdd  <span class="fu">=</span> getAny
  toMult   <span class="fu">=</span> <span class="dt">All</span>
  fromMult <span class="fu">=</span> getAll</code></pre></div>
<p>But it seems like overkill.</p>
<p>Anyway, assuming that we have the functions from <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, here’s the <code>add</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) 
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b
add xs <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (one <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> 
    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</code></pre></div>
<p>Now, expressions can be built up without specifying the specific monoid implementation, and the whole behaviour can be changed with a type signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">Trie</span> a b) <span class="fu">=</span> [a]
  fromList <span class="fu">=</span> foldr add mempty
<span class="ot">ans ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">ans <span class="fu">=</span> lookup <span class="st">&quot;abc&quot;</span> (fromList [<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ghi&quot;</span>])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span class="ot">ans ::</span> <span class="dt">Sum</span> <span class="dt">Int</span>
<span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">2</span>}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span class="ot">ans ::</span> <span class="dt">Any</span>
<span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}</code></pre></div>
<p>Slightly fuller implementations of all of these are available <a href="https://github.com/oisdk/hstrie">here</a>.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Kind of like <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">program inference in lieu of type inference</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>This isn’t really a very good definition of semiring. While Haskell doesn’t have this class in base, <a href="https://github.com/purescript/purescript-prelude/blob/master/src/Data/Semiring.purs">Purescript has it in their prelude.</a><a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></description>
    <pubDate>Mon, 26 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Lenses are Static Selectors</title>
    <link>http://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 16, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>So I don’t really know what <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html">KVC</a> is, or much about <code class="sourceCode scala">performSelector</code> functions. <a href="http://inessential.com/2016/05/20/updating_local_objects_with_server_objec">This</a> blogpost, from Brent Simmons, let me know a little bit about why I would want to use them.</p>
<p>It centred around removing code repetition of this type:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {
  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span>
}

<span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {
  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span> <span class="co">// There was an (intentional)</span>
}                                    <span class="co">// bug here in the original post</span></code></pre></div>
<p>To clean up the code, Brent used selector methods. At first, I was a little uncomfortable with the solution. As far as I could tell, the basis of a lot of this machinery used functions with types like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">get</span>(fromSelector: String) -&gt; AnyObject?
func <span class="fu">set</span>(forSelector: String) -&gt; ()</code></pre></div>
<p>Which <em>seems</em> to be extremely dynamic. Stringly-typed and all that. Except that there are two different things going on here. One is the dynamic stuff; the ability to get rid of types when you need to. The other, though, has <em>nothing</em> to do with types. The other idea is being able to pass around something which can access the property (or method) of an object. Let’s look at the code that was being repeated:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {
  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span>
}

<span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {
  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span>
}</code></pre></div>
<p>The logical, obvious thing to do here is try refactor out the common elements. In fact, the only things that <em>differ</em> between the two actions above are the <code class="sourceCode scala">foo</code> and <code class="sourceCode scala">bar</code>. It would be great to be able to write a function like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">checkThenUpdate</span>(selector) {
  <span class="kw">if</span> localObject.<span class="fu">selector</span> != serverObject.<span class="fu">selector</span> {
    localObject.<span class="fu">selector</span> = serverObject.<span class="fu">selector</span>
  }
}</code></pre></div>
<p>And then maybe a single line like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">[foo, bar, baz].<span class="fu">forEach</span>(checkThenUpdate)</code></pre></div>
<p>That’s pretty obviously better. It’s just good programming: when faced with repetition, find the repeated part, and abstract it out. Is it more <em>dynamic</em> than the repetition, though? I don’t think so. All you have to figure out is an appropriate type for the selector, and you can keep all of your static checking. To me, it seems a lot like a <a href="https://hackage.haskell.org/package/lens">lens</a>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Lens&lt;Whole, Part&gt; {
  let get: Whole -&gt; Part
  let set: (Whole, Part) -&gt; Whole
}</code></pre></div>
<p>(This is a lens similar to the ones used in the <a href="http://hackage.haskell.org/package/data-lens">data-lens</a> library, in contrast to van Laarhoven lenses, or LensFamilies. LensFamilies are used in the <a href="https://hackage.haskell.org/package/lens">lens</a> package, and they allow you to change the type of the <code class="sourceCode scala">Part</code>. They’re also just normal functions, rather than a separate type, so you can manipulate them in a pretty standard way. Swift’s type system isn’t able to model those lenses, though, unfortunately.) It has two things: a getter and a setter. The getter is pretty obvious: it takes the object, and returns the property. The setter is a little more confusing. It’s taking an object, and the new property you want to stick in to the object, and returns the object with that property updated. For instance, if we were to make a <code class="sourceCode scala">Person</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct LocalPerson {
  <span class="kw">var</span> age: Int
  <span class="kw">var</span> name: String
}</code></pre></div>
<p>We could then have a lens for the <code class="sourceCode scala">name</code> field like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let localName: Lens&lt;LocalPerson,String&gt; = <span class="fu">Lens</span>(
  get: { p in p.<span class="fu">name</span> },
  set: { (oldPerson,newName) in
    <span class="kw">var</span> newPerson = oldPerson
    newPerson.<span class="fu">name</span> = newName
    <span class="kw">return</span> newPerson
  }
)</code></pre></div>
<p>And you’d use it like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let caoimhe = <span class="fu">LocalPerson</span>(age: <span class="dv">46</span>, name: <span class="st">&quot;caoimhe&quot;</span>)
localName.<span class="fu">get</span>(caoimhe) <span class="co">// 46</span>
localName.<span class="fu">set</span>(caoimhe, <span class="st">&quot;breifne&quot;</span>) <span class="co">// LocalPerson(age: 46, name: &quot;breifne&quot;)</span></code></pre></div>
<p>Straight away, we’re able to do (something) like the <code class="sourceCode scala">checkThenUpdate</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func checkThenUpdate
  &lt;A: Equatable&gt;
  (localLens: Lens&lt;LocalPerson,A&gt;, serverLens: Lens&lt;ServerPerson,A&gt;) {
  let serverProp = serverLens.<span class="fu">get</span>(serverObject)
  <span class="kw">if</span> localLens.<span class="fu">get</span>(localObject) != serverProp {
    localObject = localLens.<span class="fu">set</span>(localObject,serverProp)
  }
}</code></pre></div>
<p>And it could be called pretty tersely:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">checkThenUpdate</span>(localName, serverLens: serverName)</code></pre></div>
<p>The biggest problem with this approach, obviously, is the boilerplate. In Haskell, that’s solved with Template Haskell, so the lens code is generated for you. (I’d love to see something like that in Swift) There’s a protocol-oriented spin on lenses, also. One of the variants on lenses in Haskell are called “classy-lenses”. That’s where, instead of just generating a lens with the same name as the field it looks into, you generate a typeclass (protocol) for anything with that lens. In Swift, it might work something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Place {
  <span class="kw">var</span> name: String
}

<span class="co">// Instead of just having a lens for the name field, have a whole protocol</span>
<span class="co">// for things with a name field:</span>

protocol HasName {
  associatedtype Name
  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; { get }
  <span class="kw">var</span> name: Name { get set }
}

<span class="co">// Because the mutable property is included in the protocol, you can rely on</span>
<span class="co">// it in extensions:</span>

extension HasName {
  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; {
    <span class="kw">return</span> <span class="fu">Lens</span>(
      get: {$<span class="fl">0.</span>name},
      set: { (w,p) in 
        <span class="kw">var</span> n = w
        n.<span class="fu">name</span> = p
        <span class="kw">return</span> n
      }
    )
  }
  <span class="kw">var</span> name: Name {
    get { <span class="kw">return</span> Self.<span class="fu">name</span>.<span class="fu">get</span>(self) }
    set { self = Self.<span class="fu">name</span>.<span class="fu">set</span>(self,newValue) }
  }
}

<span class="co">// This way, you can provide either the lens or the property, and you get the</span>
<span class="co">// other for free.</span>

extension Place: HasName {}

<span class="co">// Then, you can rely on that protocol, and all of the types:</span>

func checkEqualOnNames
  &lt;A,B where A: HasName, B: HasName, A.<span class="fu">Name</span>: Equatable, A.<span class="fu">Name</span> == B.<span class="fu">Name</span>&gt;
  (x: A, _ y: B) -&gt; Bool {
    <span class="kw">return</span> x.<span class="fu">name</span> == y.<span class="fu">name</span>
}</code></pre></div>
<p>This protocol lets you do a kind of static <code class="sourceCode scala">respondsToSelector</code>, with all of the types intact. Other people have spoken about the other things you can do with lenses in Swift (<a href="https://www.youtube.com/watch?v=ofjehH9f-CU">Brandon Williams - Lenses in Swift</a>), like composing them together, chaining operations, etc. (One other thing they can emulate is <a href="https://gist.github.com/erica/6794d48d917e2084d6ed">method cascading</a>) Unfortunately, in current Swift, the boilerplate makes all of this a little unpleasant. Still, they’re an interesting idea, and they show how a good type system needn’t always get in the way.</p>
]]></description>
    <pubDate>Thu, 16 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Folding Two Things at Once</title>
    <link>http://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>There’s a whole family of Haskell brainteasers surrounding one function: <code class="sourceCode haskell">foldr</code>. The general idea is to convert some function on lists which uses recursion into one that uses <code class="sourceCode haskell">foldr</code>. <code class="sourceCode haskell">map</code>, for instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map f <span class="fu">=</span> foldr (\e a <span class="ot">-&gt;</span> f e <span class="fu">:</span> a) []</code></pre></div>
<p>Some can get a little trickier. <code class="sourceCode haskell">dropWhile</code>, for instance. (See <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">here</a> and <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">here</a> for interesting articles on that one in particular.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dropWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhile p <span class="fu">=</span> fst <span class="fu">.</span> foldr f ([],[]) <span class="kw">where</span>
  f e <span class="fu">~</span>(xs,ys) <span class="fu">=</span> (<span class="kw">if</span> p e <span class="kw">then</span> xs <span class="kw">else</span> zs, zs) <span class="kw">where</span> zs <span class="fu">=</span> e <span class="fu">:</span> ys</code></pre></div>
<h2 id="zip">Zip</h2>
<p>One function which was a little harder to convert than it first seemed was <code class="sourceCode haskell">zip</code>.</p>
<p>Here’s the first (non) solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> foldr f (const []) <span class="kw">where</span>
  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys
  f _ _  [] <span class="fu">=</span> []</code></pre></div>
<p>The problem with the above isn’t that it doesn’t work: it does. The problem is that it’s not <em>really</em> using <code class="sourceCode haskell">foldr</code>. It’s only using it on the first list: there’s still a manual uncons being performed on the second. Ideally, I would want the function to look something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs ys <span class="fu">=</span> foldr f (\_ _ <span class="ot">-&gt;</span> []) xs (foldr g (const []) ys)</code></pre></div>
<p>The best solution I found online only dealt with <code class="sourceCode haskell"><span class="dt">Fold</span></code>s, not <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s. You can read it <a href="http://okmij.org/ftp/Haskell/zip-folds.lhs">here</a>.</p>
<h2 id="recursive-types">Recursive Types</h2>
<p>Reworking the solution online for <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s, the initial intuition is to have the <code class="sourceCode haskell">foldr</code> on the <code class="sourceCode haskell">ys</code> produce a function which takes an element of the <code class="sourceCode haskell">xs</code>, and returns a function which takes an element of the <code class="sourceCode haskell">xs</code>, and so on, finally returning the created list. The <em>problem</em> with that approach is the types involved:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs <span class="fu">=</span> foldr f (const []) xs <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
  g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 r2)
  f e r x <span class="fu">=</span> x e r</code></pre></div>
<p>You get the error:</p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Occurs</span> check<span class="fu">:</span> cannot construct the infinite <span class="kw">type</span><span class="fu">:</span> t0 <span class="fu">~</span> a <span class="ot">-&gt;</span> (t0 <span class="ot">-&gt;</span> [(a, b)]) <span class="ot">-&gt;</span> [(a, b)]</code>.</p>
</blockquote>
<p>Haskell’s typechecker doesn’t allow for infinitely recursive types.</p>
<p>You’ll be familiar with this problem if you’ve ever tried to encode the Y-combinator, or if you’ve fiddled around with the recursion-schemes package. You might also be familiar with the solution: a <code class="sourceCode haskell"><span class="kw">newtype</span></code>, encapsulating the recursion. In this case, the <code class="sourceCode haskell"><span class="kw">newtype</span></code> looks very similar to the signature for <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecFold</span> a b <span class="fu">=</span> 
  <span class="dt">RecFold</span> {<span class="ot"> runRecFold ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecFold</span> a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b }</code></pre></div>
<p>Now you can insert and remove the <code class="sourceCode haskell"><span class="dt">RecFold</span></code> wrapper, helping the typechecker to understand the recursive types as it goes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs <span class="fu">=</span>
  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>As an aside, the performance characteristics of the <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper are totally opaque to me. There may be significant improvements by using <code class="sourceCode haskell">coerce</code> from <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Coerce.html">Data.Coerce</a>, but I haven’t looked into it.</p>
<h2 id="generalised-zips">Generalised Zips</h2>
<p>The immediate temptation from the function above is to generalise it. First to <code class="sourceCode haskell">zipWith</code>, obviously:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]
zipWith c xs <span class="fu">=</span>
  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>What’s maybe a little more interesting, though, would be a <code class="sourceCode haskell">foldr</code> on two lists. Something which folds through both at once, using a supplied combining function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldr2 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g)
       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c)
       <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> c
foldr2 c i xs <span class="fu">=</span>
  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> i) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>Of course, once you can do two, you can do three:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldr3 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g, <span class="dt">Foldable</span> h)
       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> d)
       <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> h c <span class="ot">-&gt;</span> d
foldr3 c i xs ys <span class="fu">=</span>
  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr2 g (\_ _ <span class="ot">-&gt;</span> i) ys <span class="kw">where</span>
    g e2 e3 r2 e1 r1 <span class="fu">=</span> c e1 e2 e3 (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>And so on.</p>
<p>There’s the added benefit that the above functions work on much more than just lists.</p>
<h2 id="catamorphisms">Catamorphisms</h2>
<p>Getting a little formal about the above functions, a <code class="sourceCode haskell">fold</code> can be described as a catamorphism. This is a name for a pattern of breaking down some recursive structure. There’s a bunch of them in the <a href="https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html">recursion-schemes</a> package. The question is, then: can you express the above as a kind of catamorphism? Initially, using the same techniques as before, you can:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecF</span> f a <span class="fu">=</span> <span class="dt">RecF</span> {<span class="ot"> unRecF ::</span> <span class="dt">Base</span> f (<span class="dt">RecF</span> f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a }

<span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)
     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">RecF</span> g c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">RecF</span> g c <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c)
     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c
zipo alg xs ys <span class="fu">=</span> cata (flip unRecF) ys (cata (<span class="dt">RecF</span> <span class="fu">.</span> alg) xs)</code></pre></div>
<p>Then, coming full circle, you get a quite nice encoding of <code class="sourceCode haskell">zip</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> zipo alg <span class="kw">where</span>
  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []
  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []
  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x, y) <span class="fu">:</span> ys xs</code></pre></div>
<p>However, the <code class="sourceCode haskell"><span class="dt">RecF</span></code> is a little ugly. In fact, it’s possible to write the above without any recursive types, using the RankNTypes extension. (It’s possible that you could do the same with <code class="sourceCode haskell">foldr2</code> as well, but I haven’t figured it out yet)</p>
<p>You can actually use a <code class="sourceCode haskell"><span class="kw">newtype</span></code> that’s provided by the recursion-schemes library as-is. It’s <code class="sourceCode haskell"><span class="dt">Mu</span></code>. This is required for an encoding of the Y-combinator. It’s usually presented in this form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Mu</span> a <span class="fu">=</span> <span class="dt">Roll</span> {<span class="ot"> unroll ::</span> <span class="dt">Mu</span> a <span class="ot">-&gt;</span> a }</code></pre></div>
<p>However, in the recursion-schemes package, its definition looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> (forall a<span class="fu">.</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a)</code></pre></div>
<p>No recursion! The <code class="sourceCode haskell">zipo</code> combinator above can be written using <code class="sourceCode haskell"><span class="dt">Mu</span></code> like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)
     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">Mu</span> (<span class="dt">Base</span> g) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">Mu</span> (<span class="dt">Base</span> g)) <span class="ot">-&gt;</span> c)
     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c
zipo alg xs <span class="fu">=</span> cata (\x <span class="ot">-&gt;</span> alg x <span class="fu">.</span> project) xs <span class="fu">.</span> refix</code></pre></div>
<p>And the new version of <code class="sourceCode haskell">zip</code> has a slightly more natural order of arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> zipo alg <span class="kw">where</span>
  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []
  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []
  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</code></pre></div>
<h2 id="zipping-into">Zipping Into</h2>
<p>There’s one more issue, though, that’s slightly tangential. A lot of the time, the attraction of rewriting functions using folds and catamorphisms is that the function becomes more general: it no longer is restricted to lists. For <code class="sourceCode haskell">zip</code>, however, there’s still a pesky list left in the signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> [(a,b)]</code></pre></div>
<p>It would be a little nicer to be able to zip through something <em>preserving</em> the structure of one of the things being zipped through. For no reason in particular, let’s assume we’ll preserve the structure of the first argument. The function will have to account for the second argument running out before the first, though. A <code class="sourceCode haskell"><span class="dt">Maybe</span></code> can account for that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) 
        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) 
        <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f c</code></pre></div>
<p>If the second argument runs out, <code class="sourceCode haskell"><span class="dt">Nothing</span></code> will be passed to the combining function.</p>
<p>It’s clear that this isn’t a <em>fold</em> over the first argument, it’s a <em>traversal</em>. A first go at the function uses the state monad, but restricts the second argument to a list:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c
zipInto c xs ys <span class="fu">=</span> evalState (traverse f xs) ys <span class="kw">where</span>
  f x <span class="fu">=</span> <span class="kw">do</span>
    h <span class="ot">&lt;-</span> gets uncons
    <span class="kw">case</span> h <span class="kw">of</span> 
      <span class="dt">Just</span> (y,t) <span class="ot">-&gt;</span> <span class="kw">do</span> 
        put t
        pure (c x (<span class="dt">Just</span> y))
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> pure (c x <span class="dt">Nothing</span>)</code></pre></div>
<p>That code can be cleaned up a little:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c 
zipInto c <span class="fu">=</span> evalState <span class="fu">.</span> traverse (state <span class="fu">.</span> f <span class="fu">.</span> c) <span class="kw">where</span>
  f x [] <span class="fu">=</span> (x <span class="dt">Nothing</span>, [])
  f x (y<span class="fu">:</span>ys) <span class="fu">=</span> (x (<span class="dt">Just</span> y), ys)</code></pre></div>
<p>But really, the uncons needs to go. Another <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper is needed, and here’s the end result:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecAccu</span> a b <span class="fu">=</span>
  <span class="dt">RecAccu</span> {<span class="ot"> runRecAccu ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecAccu</span> a b, b) }
  
<span class="ot">zipInto ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Foldable</span> f)
        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> t c
zipInto f xs <span class="fu">=</span>
  snd <span class="fu">.</span> flip (mapAccumL runRecAccu) xs <span class="fu">.</span> <span class="dt">RecAccu</span> <span class="fu">.</span> foldr h i <span class="kw">where</span>
    i e <span class="fu">=</span> (<span class="dt">RecAccu</span> i, f e <span class="dt">Nothing</span>)
    h e2 a e1 <span class="fu">=</span> (<span class="dt">RecAccu</span> a, f e1 (<span class="dt">Just</span> e2))</code></pre></div>
]]></description>
    <pubDate>Sun, 17 Apr 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Haskell</title>
    <link>http://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on October  6, 2015
</div>
<div class="info">
    
        Part 1 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h2 id="basic-ops">Basic Ops</h2>
<p>A Trie is one of those data structures that I find myself writing very early on in almost every language I try to learn. It’s elegant and interesting, and easy enough to implement.</p>
<p>I usually write a version that is a set-like data structure, rather than a mapping type, for simplicity’s sake. It stores sequences, in a prefix-tree structure. It has a map (dictionary) where the keys are the first element of every sequence it stores, and the values are the Tries which store the rest of the sequence. It also has a boolean tag, representing whether or not the current Trie is a Trie on which a sequence ends. Here’s what the type looks like in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Trie</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (null)
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> (fold)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Trie</span> a <span class="fu">=</span> <span class="dt">Trie</span> {<span class="ot"> endHere ::</span> <span class="dt">Bool</span>
                   ,<span class="ot"> getTrie ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a)
                   } <span class="kw">deriving</span> (<span class="dt">Eq</span>)</code></pre></div>
<p>Now, inserting into the Trie is easy. You just <code class="sourceCode haskell">uncons</code> on a list, and insert the head into the map, with the value being the tail inserted into whatever existed at that key before:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">empty ::</span> <span class="dt">Trie</span> a
empty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty

<span class="ot">insertRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
insertRec [] (<span class="dt">Trie</span> _ m)     <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">True</span> m
insertRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> e m) <span class="fu">=</span> 
  <span class="dt">Trie</span> e (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> insertRec xs <span class="fu">.</span> fromMaybe empty) x m)</code></pre></div>
<p>Searching is simple, also. For the empty list, you just check if the Trie has its <code class="sourceCode haskell">endHere</code> tag set to <code class="sourceCode haskell"><span class="dt">True</span></code>, otherwise, you uncons, search the map, and query the Trie with the tail if it eas found, or just return <code class="sourceCode haskell"><span class="dt">False</span></code> if it was not:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">memberRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
memberRec [] (<span class="dt">Trie</span> e _)     <span class="fu">=</span> e
memberRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> _ m) <span class="fu">=</span> 
  fromMaybe <span class="dt">False</span> (memberRec xs <span class="fu">&lt;$&gt;</span> Map.lookup x m)</code></pre></div>
<p>Here’s my problem. <em>Both</em> of those functions have the same pattern:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f []     <span class="fu">=</span> <span class="fu">...</span>
f (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p>Any good Haskeller should be <em>begging</em> for a fold at this stage. But it proved a little trickier than I’d imagined. Take <code class="sourceCode haskell">member</code>, for instance. You want to fold over a list, with the base case being the tag on the Trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f base <span class="kw">where</span>
  base <span class="fu">=</span> <span class="fu">???</span>
  f e a <span class="fu">=</span> Map.lookup e <span class="fu">???</span></code></pre></div>
<p>Where do you get the base case from, though? You have to specify it from the beginning, but the variable you’re looking for is nested deeply into the Trie. How can you look into the Trie, without traversing the list, to find the tag, <em>at the beginning of the function?</em></p>
<p>That had been my issue for a while. Every time I cam back to writing a Trie, I would see the pattern, try and write <code class="sourceCode haskell">insert</code> and <code class="sourceCode haskell">member</code> with a fold, and remember again the trouble I had had with it in the past. Recently, though, I saw a different problem, that gave me an idea for a solution.</p>
<h2 id="the-highest-order">The Highest Order</h2>
<blockquote>
<p>Rewrite <code class="sourceCode haskell">dropWhile</code> using <code class="sourceCode haskell">foldr</code></p>
</blockquote>
<p>It’s a (semi) well-known puzzle, that’s maybe a little more difficult than it seems at first. Here, for instance, was my first attempt at it:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhileWrong ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhileWrong p <span class="fu">=</span> foldr f [] <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a
        <span class="fu">|</span> otherwise <span class="fu">=</span> e<span class="fu">:</span>a</code></pre></div>
<p>Yeah. That’s <code class="sourceCode haskell">filter</code>, not <code class="sourceCode haskell">dropWhile</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">dropWhileWrong (<span class="fu">&lt;</span><span class="dv">5</span>) [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">1</span>]
[<span class="dv">6</span>]</code></pre></div>
<p>Here was my final solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhileCount ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhileCount p l <span class="fu">=</span> drop (foldr f <span class="dv">0</span> l) l <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a <span class="fu">+</span> <span class="dv">1</span>
        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<p>After the problem I found <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">this</a> issue of The Monad Reader, which talks about the same problem. In my <code class="sourceCode haskell">drop</code> version, I had been counting the number of items to drop as I went, adding one for every element that passed the test. The corresponding version in the article had been building up <code class="sourceCode haskell">tail</code> functions, using <code class="sourceCode haskell"><span class="fu">.</span></code> to add them together:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhileTail ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhileTail p l <span class="fu">=</span> (foldr f id l) l <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a
        <span class="fu">|</span> otherwise <span class="fu">=</span> id</code></pre></div>
<p>A quick visit to <a href="http://pointfree.io">pointfree.io</a> can generate some monadic pointsfree magic:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhilePf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhilePf p <span class="fu">=</span> join (foldr f id) <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a
        <span class="fu">|</span> otherwise <span class="fu">=</span> id</code></pre></div>
<p>Now, the final version in the article did <em>not</em> use this technique, as it was very inefficient. It used some cleverness beyond the scope of this post. The second-from-last version I quite liked, though:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhileFp ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhileFp p l <span class="fu">=</span> foldr f l l <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail a
        <span class="fu">|</span> otherwise <span class="fu">=</span> l</code></pre></div>
<p>However, the idea of building up a function in a fold gave me an idea for adapting it to some of the Trie functions.</p>
<h2 id="folding-inwards">Folding Inwards</h2>
<p>Let’s start with <code class="sourceCode haskell">member</code>. It needs to fold over a list, and generate a function which acts on a Trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f base</code></pre></div>
<p>The <code class="sourceCode haskell">base</code> is the function being built up: the final part of the function chain. Each part of the function is generated based on each element of the list, and then chained with the base using <code class="sourceCode haskell"><span class="fu">.</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member <span class="fu">=</span> foldr f base <span class="kw">where</span>
  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </code></pre></div>
<p>The base here is what’s called when the list is empty. Here’s what it looked like in the explicit recursion version:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member [] (<span class="dt">Trie</span> e _) <span class="fu">=</span> e</code></pre></div>
<p>We could simplify this by using record syntax, and <code class="sourceCode haskell">getTrie</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member [] t <span class="fu">=</span> getTrie t</code></pre></div>
<p>And this has an obvious pointsfree version:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member [] <span class="fu">=</span> getTrie</code></pre></div>
<p>That fits for the base case. It’s just a function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member <span class="fu">=</span> foldr f endHere <span class="kw">where</span>
  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </code></pre></div>
<p>Then, how to combine it. That’s easy enough, actually. It accesses the map, searches it for the key, and calls the accumulating function on it. If it’s not found in the map, just return <code class="sourceCode haskell"><span class="dt">False</span></code>. Here it is:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f endHere <span class="kw">where</span>
  f e a <span class="fu">=</span> fromMaybe <span class="dt">False</span> <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie</code></pre></div>
<p>One of the other standard functions for a Trie is returning the “completions” for a given sequence. It’s a very similar function to <code class="sourceCode haskell">member</code>, actually: instead of calling <code class="sourceCode haskell">endHere</code> on the final Trie found, though, just return the Trie itself. And the thing to return if any given element of the sequence isn’t found is just an empty Trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">complete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
complete <span class="fu">=</span> foldr f id <span class="kw">where</span>
  f e a <span class="fu">=</span> fromMaybe empty <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie </code></pre></div>
<p>In fact, you could abstract out the commonality here:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">follow ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> c <span class="ot">-&gt;</span> (<span class="dt">Trie</span> a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> c
follow ifMiss onEnd <span class="fu">=</span> foldr f onEnd <span class="kw">where</span>
  f e a <span class="fu">=</span> fromMaybe ifMiss <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie 
  
<span class="ot">memberAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
memberAbs <span class="fu">=</span> follow <span class="dt">False</span> endHere

<span class="ot">completeAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
completeAbs <span class="fu">=</span> follow empty id</code></pre></div>
<h2 id="folding-in-and-out">Folding in and out</h2>
<p><code class="sourceCode haskell">insert</code> is another deal entirely. In <code class="sourceCode haskell">member</code>, the fold was tunneling into a Trie, applying the accumulator function to successively deeper Tries, and returning a result based on the final Trie. <code class="sourceCode haskell">insert</code> needs to do the same tunneling - but the Trie returned needs to be the <em>outer</em> Trie.</p>
<p>It turns out it’s not that difficult. Instead of “building up a function” that is then applied to a Trie, here a function is “sent” into the inner Tries. The cool thing here is that the function being sent hasn’t been generated yet.</p>
<p>Here’s some more illustration of what I mean. Start off with the normal <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m)</code></pre></div>
<p>With the final function to be applied being one that just flips the <code class="sourceCode haskell">endHere</code> tag to <code class="sourceCode haskell"><span class="dt">True</span></code>. Then <code class="sourceCode haskell">f</code>: this is going to act <em>over</em> the map of the Trie that it’s called on. It’s useful to define a function just for that:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">overMap ::</span> <span class="dt">Ord</span> b 
        <span class="ot">=&gt;</span> (<span class="dt">Map.Map</span> a (<span class="dt">Trie</span> a)
        <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> b (<span class="dt">Trie</span> b))
        <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
        <span class="ot">-&gt;</span> <span class="dt">Trie</span> b
overMap f (<span class="dt">Trie</span> e m) <span class="fu">=</span> <span class="dt">Trie</span> e (f m)</code></pre></div>
<p>Then, it will look up the next element of the sequence in the Trie, and apply the accumulating function to it. (if it’s not found it will provide an empty Trie instead) Simple!</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty
  <span class="dt">Trie</span> v k <span class="ot">`mappend`</span> <span class="dt">Trie</span> t l <span class="fu">=</span>
    <span class="dt">Trie</span> (v <span class="fu">||</span> t) (Map.unionWith mappend k l)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m) <span class="kw">where</span>
  f e a <span class="fu">=</span> 
    overMap (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e)</code></pre></div>
<p>I think this is really cool: with just a <code class="sourceCode haskell">foldr</code>, you’re burrowing into a Trie, changing it, and burrowing back out again.</p>
<h2 id="removal">Removal</h2>
<p>This is always the tricky one with a Trie. You <em>can</em> just follow a given sequence down to its tag, and flip it from on to off. But that doesn’t remove the sequence itself from the Trie. So maybe you just delete the sequence - but that doesn’t work either. How do you know that there are no other sequences stored below the one you were examining?</p>
<p>What you need to do is to send a function into the Trie, and have it report back as to whether or not it stores other sequences below it. So this version of <code class="sourceCode haskell">foldr</code> is going to burrow into the Trie, like <code class="sourceCode haskell">member</code>; maintain the outer Trie, like <code class="sourceCode haskell">insert</code>; but <em>also</em> send messages back up to the outer functions. Cool!</p>
<p>The way to do the “message sending” is with <code class="sourceCode haskell"><span class="dt">Maybe</span></code>. If the function you send into the Trie to delete the end of the sequence returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, then it signifies that you can delete that member. Luckily, the <code class="sourceCode haskell">alter</code> function on <code class="sourceCode haskell"><span class="dt">Data.Map</span></code> works well with this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">alter ::</span> <span class="dt">Ord</span> k 
      <span class="ot">=&gt;</span> (<span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)
      <span class="ot">-&gt;</span> k
      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a
      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a</code></pre></div>
<p>Its first argument is a function which is given the result of looking up its <em>second</em> argument. If the function returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, that key-value pair in the map is deleted (if it was there). If it returns <code class="sourceCode haskell"><span class="dt">Just</span></code> something, though, that key-value pair is added. In the delete function, we can chain the accumulating function with <code class="sourceCode haskell"><span class="fu">=&lt;&lt;</span></code>. This will skip the rest of the accumulation if any part of the sequence isn’t found. The actual function we’re chaining on is <code class="sourceCode haskell">nilIfEmpty</code>, which checks if a given Trie is empty, and returns <code class="sourceCode haskell"><span class="dt">Just</span></code> the Trie if it’s not, or <code class="sourceCode haskell"><span class="dt">Nothing</span></code> otherwise.</p>
<p>Here’s the finished version:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
delete <span class="fu">=</span> (fromMaybe empty <span class="fu">.</span>) <span class="fu">.</span> foldr f i <span class="kw">where</span>
  i (<span class="dt">Trie</span> _ m) <span class="fu">|</span> Map.null m  <span class="fu">=</span> <span class="dt">Nothing</span>
               <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Trie</span> <span class="dt">False</span> m)
  f e a <span class="fu">=</span> nilIfEmpty <span class="fu">.</span> overMap (Map.alter (a <span class="fu">=&lt;&lt;</span>) e) 
  
null<span class="ot"> ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
null (<span class="dt">Trie</span> e m) <span class="fu">=</span> (not e) <span class="fu">&amp;&amp;</span> (Map.null m)

<span class="ot">nilIfEmpty ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Trie</span> a)
nilIfEmpty t <span class="fu">|</span> null t    <span class="fu">=</span> <span class="dt">Nothing</span>
             <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> t</code></pre></div>
<h2 id="folding-the-foldable">Folding the Foldable</h2>
<p>So how about folding the Trie itself? Same trick: build up a function with a fold. This time, a fold over the map, not a list. And the function being built up is a cons operation. When you hit a <code class="sourceCode haskell"><span class="dt">True</span></code> tag, fire off an empty list to the built-up function, allowing it to evaluate:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldrTrie ::</span> ([a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> b
foldrTrie f i (<span class="dt">Trie</span> a m) <span class="fu">=</span> Map.foldrWithKey ff s m <span class="kw">where</span>
  s    <span class="fu">=</span> <span class="kw">if</span> a <span class="kw">then</span> f [] i <span class="kw">else</span> i
  ff k <span class="fu">=</span> flip (foldrTrie <span class="fu">$</span> f <span class="fu">.</span> (k <span class="fu">:</span>))</code></pre></div>
<p>Unfortunately, <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">it’s not easy</a> to make the Trie <em>conform</em> to <code class="sourceCode haskell"><span class="dt">Foldable</span></code>. It is possible, and it’s what I’m currently trying to figure out, but it’s non-trivial.</p>
]]></description>
    <pubDate>Tue, 06 Oct 2015 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Faking dependent types in Swift</title>
    <link>http://doisinkidney.com/posts/2015-09-06-dependent-types.html</link>
    <description><![CDATA[<div class="info">
    Posted on September  6, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p><a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types</a> are types “that depend on values”. Say you had a function <code class="sourceCode scala">f</code> that took an integer. If you can write that function whereby it returns a value of type <code class="sourceCode scala">A</code> when that integer is even, or a type <code class="sourceCode scala">B</code> if the integer is odd, then you’re working with dependent types. (I think. I’m not sure: if I’ve got it wrong <a href="https://twitter.com/oisdk">tweet me</a>.)</p>
<h2 id="dependent-pretendance">Dependent Pretendance</h2>
<p>As far as I can tell, this is not possible in Swift. All variables are statically typed, and those types must be found at compile-time. As long as you’re not messing around with casting:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct A {}
struct B {}

func <span class="fu">f</span>(i: Int) -&gt; AnyObject {
  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? <span class="fu">A</span>() as! AnyObject : <span class="fu">B</span>() as! AnyObject
}</code></pre></div>
<p>You won’t be able to manage it.</p>
<p>Now, sum types can give you something that <em>looks</em> like dependent types:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct A {}
struct B {}

enum SumType {
  <span class="kw">case</span> <span class="fu">Even</span>(A), <span class="fu">Odd</span>(B)
}

func <span class="fu">f</span>(i: Int) -&gt; SumType {
  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? .<span class="fu">Even</span>(<span class="fu">A</span>()) : .<span class="fu">Odd</span>(<span class="fu">B</span>())
}</code></pre></div>
<p>But that doesn’t fit the description: the thing returned is of type <code class="sourceCode scala">SumType</code>, <em>not</em> <code class="sourceCode scala">A</code> or <code class="sourceCode scala">B</code>.</p>
<p>That’s fine, though. As with all of these highfalutin mathematical concepts in programming, you can steal some of the cool and fun <em>patterns</em> from your Haskells and Lisps and Idrises and implement them in whatever language you want.</p>
<p>As it happens, implementing this stuff in Swift gets you even <em>further</em> away from the formal definition of dependent types. Instead of allowing types to be decided at runtime, you end up forcing even <em>more</em> resolution and computation to happen at compile-time. Take “numbers-as-types”, for instance:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol Nat { <span class="fu">init</span>() }
struct Zero : Nat {}
protocol NonZero: Nat { typealias Pred: Nat }
struct Succ&lt;N : Nat&gt; : NonZero { typealias Pred = N }</code></pre></div>
<p>Once you encode some numbers by hand:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">typealias One   = Succ&lt;Zero&gt;
typealias Two   = Succ&lt;One&gt;
typealias Three = Succ&lt;Two&gt;
typealias Four  = Succ&lt;Three&gt;
typealias Five  = Succ&lt;Four&gt;
typealias Six   = Succ&lt;Five&gt;
typealias Seven = Succ&lt;Six&gt;
typealias Eight = Succ&lt;Seven&gt;
typealias Nine  = Succ&lt;Eight&gt;</code></pre></div>
<p>You get thinking about exactly <em>how much</em> computation you can achieve at compile time:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">Sum&lt;One, Two&gt;.<span class="fu">Result</span>    <span class="co">// Three</span>
Comp&lt;Five, Nine&gt;.<span class="fu">Result</span> <span class="co">// LT</span>
Comp&lt;Four, Four&gt;.<span class="fu">Result</span> <span class="co">// EQ</span></code></pre></div>
<h2 id="sum-types-divide-types-multiply-types">Sum types, divide types, multiply types</h2>
<p>What I wanted, ideally, was some basic “Algebraic data types”. (Today. Today was the day I made the worst pun.) I wanted to be able to add the type <code class="sourceCode scala">One</code> to the type <code class="sourceCode scala">Two</code> and get the type <code class="sourceCode scala">Three</code>. Once you can manage those, multiplication, division and all kinds of silliness are possible. I set myself some rules: all calculations must be performed at compile-time, and all calculations must work with arbitrary values.</p>
<p>I’ve not been able to manage, unfortunately. If someone could figure out how to do it, I would <a href="https://twitter.com/oisdk">love to hear it</a>. I’ve been stealing ideas from <a href="http://strictlypositive.org/faking.ps.gz">Faking It: Simulating Dependent Types in Haskell</a> mainly.</p>
<p>Here’s the kind of code that made me think it was possible:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let ar = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">reverse</span>()
let se = <span class="fu">AnySequence</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]).<span class="fu">reverse</span>()</code></pre></div>
<p>The types returned by those two methods are different. This is all to do with that protocol-oriented-programming business: the compiler will try to select the most specialised version of a method to use. So in the example above, since an array can just be indexed backwards, the compiler uses a method that returns a lazy <code class="sourceCode scala">ReverseRandomAccessCollection</code>. However, for the <code class="sourceCode scala">AnySequence</code>, the <code class="sourceCode scala">reverse</code> method has to create a whole new array.</p>
<p>With that in mind, we can make a protocol:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol BinaryOp {
  typealias A: Nat
  typealias B: Nat
}</code></pre></div>
<p>Then, we can extend it, like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct EQ {}
extension BinaryOp where A == B {
  typealias Result = EQ
}</code></pre></div>
<p>So far, so good! The compiler will add that method to all types that conform to the <code class="sourceCode scala">where</code> clause. So if there is a concrete type that conforms to <code>BinaryOp</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Comp&lt;E0: Nat, E1: Nat&gt; : BinaryOp {
  typealias A = E0
  typealias B = E1
}</code></pre></div>
<p>Only instances where <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are equal will get the type alias:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">Comp&lt;One, One&gt;.<span class="fu">Result</span>
Comp&lt;One, Two&gt;.<span class="fu">Result</span> <span class="co">// Error</span></code></pre></div>
<p>But that’s not ideal. We want something that returns <code class="sourceCode scala">NEQ</code> when the types are not the same. Easy enough, right?</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct NEQ {}
extension BinaryOp {
  typealias Result = NEQ
}</code></pre></div>
<p>But there’s an error: <code class="sourceCode scala">invalid redeclaration of &#39;Result&#39;</code>. The compiler won’t allow polymorphism with typealiases. It <em>does</em> allow polymorphism with properties, though:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension BinaryOp {
  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }
}
extension BinaryOp where A == B {
  <span class="kw">var</span> r: NEQ { <span class="kw">return</span> <span class="fu">NEQ</span>() }
}</code></pre></div>
<p>This is already a less elegant solution than the typealiases, since we’re going to have to initialise things. All of the type information is available at compile-time, though, so I’ve not broken any of my rules.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">Comp&lt;One, One&gt;().<span class="fu">r</span> <span class="co">// EQ</span>
Comp&lt;One, Two&gt;().<span class="fu">r</span> <span class="co">// NEQ</span></code></pre></div>
<p>How about something more complex? Instead of <code class="sourceCode scala">EQ</code> and <code class="sourceCode scala">NEQ</code>, maybe <code class="sourceCode scala">LT</code>, <code class="sourceCode scala">GT</code>, and <code>EQ</code>?</p>
<p>It’s hard to see how it would work. Well, here’s the base case:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension BinaryOp where A == B {
  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }
}</code></pre></div>
<p>Then, any non-zero is bigger than zero:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct LT {}
extension BinaryOp where A == Zero, B : NonZero {
  <span class="kw">var</span> r: LT { <span class="kw">return</span> <span class="fu">LT</span>() }
}
struct GT {}
extension BinaryOp where A : NonZero, B == Zero {
  <span class="kw">var</span> r: GT { <span class="kw">return</span> <span class="fu">GT</span>() }
}</code></pre></div>
<p>If both <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are nonzero, they should have a <code class="sourceCode scala">Pred</code> typealias, which we can use, recursively:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension BinaryOp where A : NonZero, B : NonZero {
  <span class="kw">var</span> r: ?? {
    <span class="kw">return</span> Comp&lt;A.<span class="fu">Pred</span>, B.<span class="fu">Pred</span>&gt;().<span class="fu">r</span>
  }
}</code></pre></div>
<p>This doesn’t work. I’m fairly sure this is a definitive dead end. Here’s the error: <code class="sourceCode scala">ambiguous reference to member &#39;r&#39;</code>. The problem is that that error encapsulates exactly what I’m trying to achieve: I <em>want</em> the reference to be ambiguous, so it <em>depends</em> on the types of <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code>. Most other routes I went down hit similar roadblocks:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol BinaryOp {
  typealias A: Nat
  typealias B: Nat
  typealias Result
  <span class="kw">var</span> r: Result { get }
}</code></pre></div>
<p>The idea here was that you could have various implementations of <code class="sourceCode scala">r</code>, so that the <code class="sourceCode scala">Result</code> typealias would be inferred. The problem is the compiler wants to figure out what <code class="sourceCode scala">Result</code> is when you make a type that conforms to the protocol, so every type will get the default implementation.</p>
<p>Yet more versions I tried all hit the <code class="sourceCode scala">ambiguous</code> error, which makes me think this kind of thing is fundamentally impossible in Swift’s current form.</p>
<p>So I’ve got to break one of the rules: no more arbitrary numbers.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct AddOne&lt;N : Nat&gt; {
  typealias Result = Succ&lt;N&gt;
}
struct AddTwo&lt;N : Nat&gt; {
  typealias Result = Succ&lt;AddOne&lt;N&gt;.<span class="fu">Result</span>&gt;
}</code></pre></div>
<p>And so on. Or:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Binary where A == B {
  <span class="kw">var</span> sub: Zero { <span class="kw">return</span> <span class="fu">Zero</span>() }
  <span class="kw">var</span> com: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }
}
extension Binary where A == Succ&lt;B&gt; {
  <span class="kw">var</span> sub: One { <span class="kw">return</span> <span class="fu">One</span>() }
  <span class="kw">var</span> com: GT { <span class="kw">return</span> <span class="fu">GT</span>() }
}</code></pre></div>
<p>Which can give you subtraction.</p>
<h2 id="lets-pretend-to-be-useful">Let’s Pretend to be Useful</h2>
<p>All of that stuff is interesting, but very <em>very</em> far from being useful.</p>
<p>The <a href="https://bigonotetaking.wordpress.com/2015/09/04/in-which-i-misunderstand-dependent-types/">length-indexed list from the other day</a> probably is useful, though. As well as being kind of cool and safe, there are some (minor) optimisations it can do.</p>
<p>The other dependent type staple is the heterogenous list.</p>
<p>Now, this isn’t just any heterogenous list: we’re not writing Python here. This is a <em>statically typed</em> heterogenous list. Swift has a construct very similar to this already: a tuple!</p>
<p>But tuples aren’t very extensible:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Tuple where First : Comparable {...
extension Tuple where Count == Two {...</code></pre></div>
<p>And you can’t work with them in terms that most lists can:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">(<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>, <span class="fl">2.0</span>) + (<span class="st">&quot;b&quot;</span>, -<span class="dv">3</span>)</code></pre></div>
<p>So that’s where another tuple type can come in. A la <a href="https://twitter.com/rob_rix/status/633262294336729088">Rob Rix</a>, we could make a right-recursive tuple, terminated by <code class="sourceCode scala">()</code>. There’ll be one overarching protocol:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol _AnyTuple : CustomStringConvertible {
  <span class="kw">var</span> tDesc: String { get }
  <span class="kw">var</span> count: Int { get }
  typealias Arity : Nat
}</code></pre></div>
<p>And the empty tuple:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct EmptyTuple {}

extension EmptyTuple : _AnyTuple {
  <span class="kw">var</span> description: String { <span class="kw">return</span> <span class="st">&quot;()&quot;</span> }
  <span class="kw">var</span> tDesc: String { <span class="kw">return</span>  <span class="st">&quot;)&quot;</span> }
  <span class="kw">var</span> count: Int { <span class="kw">return</span> <span class="dv">0</span> }
  typealias Arity = Zero
}</code></pre></div>
<p>The descriptions are just there to give us a pretty printout. Here’s the tuple struct:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct NonEmptyTuple&lt;Element, Tail : _AnyTuple&gt; { <span class="kw">var</span> (head, tail): (Element, Tail) }

extension NonEmptyTuple : _AnyTuple {
  <span class="kw">var</span> count: Int { <span class="kw">return</span> tail.<span class="fu">count</span> + <span class="dv">1</span> }
  <span class="kw">var</span> description: String {
    <span class="kw">return</span> <span class="st">&quot;(&quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span>
  }
  <span class="kw">var</span> tDesc: String {
    <span class="kw">return</span> <span class="st">&quot;, &quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span>
  }
  typealias Arity = Succ&lt;Tail.<span class="fu">Arity</span>&gt;
}</code></pre></div>
<p>Now, to build a tuple. Since it’s right-recursive, it might look like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="dv">1</span> , <span class="st">&quot;a&quot;</span> , <span class="fl">4.0</span> , ()</code></pre></div>
<p>But there are two problems with that: first, the comma is not overloadable. That’s probably a good thing. Second, it doesn’t really look like a tuple.</p>
<p><a href="https://twitter.com/jckarter/status/639953308401057793">Joe Groff</a> solved the first problem (albeit by committing a mortal sin). Just use a unicode comma! The only one I could find that works has the delightful name of Hypodiastole.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">infix operator ⸒ { associativity right precedence <span class="dv">90</span> }</code></pre></div>
<p>Trying to find it in the character viewer each time was a pain, though. So I went with the boring vertical bar.</p>
<p>The second problem can be solved with some sneaky overloading. Here’s what these functions look like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">infix operator | { associativity right precedence <span class="dv">90</span> }

func |&lt;E, T:_AnyTuple&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, T&gt; {
  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: rhs)
}

func |&lt;E, T&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, NonEmptyTuple&lt;T, EmptyTuple&gt;&gt; {
  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: <span class="fu">NonEmptyTuple</span>(head: rhs, tail: <span class="fu">EmptyTuple</span>()))
}</code></pre></div>
<p>We can now, finally, build a Tuple:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">(<span class="dv">1</span> | <span class="fl">2.0</span> | <span class="st">&quot;a&quot;</span> ) <span class="co">// (1, 2.0, &quot;a&quot;)</span></code></pre></div>
<p>One little wrinkle with protocols, though. If you try this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension NonEmptyTuple where Arity == Two {...</code></pre></div>
<p>There’s an error: <code class="sourceCode scala">neither <span class="kw">type</span> in same-<span class="kw">type</span> refers to a generic parameter or associated <span class="kw">type</span></code>. Generally speaking, <code class="sourceCode scala">==</code> requirements in struct extensions don’t work. However, they do work on protocols. So a wrapper protocol is needed:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol Tuple : _AnyTuple {
  typealias Head
  typealias Tail : _AnyTuple
  typealias Arity : NonZero
  <span class="kw">var</span> head : Head { get }
  <span class="kw">var</span> tail : Tail { get }
}

extension NonEmptyTuple : Tuple {}</code></pre></div>
<p>Alright. Time to work with it.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Tuple where
  Head : IntegerArithmeticType,
  Tail : Tuple,
  Tail.<span class="fu">Head</span> : IntegerArithmeticType,
  Arity == Two {
  func <span class="fu">matSum</span>(<span class="kw">with</span>: Self) -&gt; NonEmptyTuple&lt;Head, NonEmptyTuple&lt;Tail.<span class="fu">Head</span>, EmptyTuple&gt;&gt; {
    let a = head + <span class="kw">with</span>.<span class="fu">head</span>
    let b = tail.<span class="fu">head</span> + <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span>
    <span class="kw">return</span> (a | b)
  }
}

(<span class="dv">1</span> | <span class="dv">4</span>).<span class="fu">matSum</span>(<span class="dv">3</span> | <span class="dv">2</span>) <span class="co">// (4, 6)</span></code></pre></div>
<p>The basic advantage of this heterogenous list in Swift is its extensibility: you can treat tuples of length 2 as a type, or tuples where the third element is comparable as a type, and so on.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Tuple where Tail : Tuple, Tail.<span class="fu">Head</span> : Comparable {
  func isSecondLessThan
    &lt;T : Tuple where T.<span class="fu">Tail</span> : Tuple, T.<span class="fu">Tail</span>.<span class="fu">Head</span> == Tail.<span class="fu">Head</span>&gt;
    (<span class="kw">with</span>: T) -&gt; Bool {
    <span class="kw">return</span> tail.<span class="fu">head</span> &lt; <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span>
  }
}

let a = (<span class="dv">1</span> | <span class="fl">3.0</span> | <span class="st">&quot;a&quot;</span> | <span class="dv">43</span>)
let b = (<span class="st">&quot;c&quot;</span> | <span class="fl">4.0</span> | <span class="dv">1</span>)

a.<span class="fu">isSecondLessThan</span>(b)</code></pre></div>
<p>Most of this stuff is madness. The custom infix unicode operator should have tipped you off to that: but it’s not to say that <em>nothing</em> here is useful. Compile-time warnings are great. I think the fixed-length array works. But this tuple stuff is too hacky: it only becomes useful if there are some low-level changes to the language.</p>
<p>What’s really useful, though, is <em>thinking</em> about types with dependency in mind. Getting familiar with what is and isn’t possible to write between the <code class="sourceCode scala">where</code> and the <code class="sourceCode scala">{</code> in an extension gives you a good idea of how powerful protocols and their specialisations are.</p>
<p>For some extra reading, check out <a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell">DependentHaskell</a>, <a href="https://wiki.haskell.org/Heterogenous_collections">Heterogenous Collections in Haskell</a>, and <a href="http://programmers.stackexchange.com/questions/132835/is-there-a-specific-purpose-for-heterogeneous-lists">Strongly Typed Heterogenous Collections</a>. I’m muddling my way through seeing what’s possible with length-indexed lists, heterogenous lists, and numeral types <a href="https://github.com/oisdk/PretendDependSwift">over here</a>, if you’re interested.</p>
]]></description>
    <pubDate>Sun, 06 Sep 2015 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2015-09-06-dependent-types.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Using Protocols to Build a (very) Generic Deque</title>
    <link>http://doisinkidney.com/posts/2015-08-24-generic-deque.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 24, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>(Download the playground to use the code and see the outputs)</p>
<p>This post is an update on a <a href="https://bigonotetaking.wordpress.com/2015/08/09/yet-another-root-of-all-evil/">previous implementation of a Deque</a>. A full implementation of this Deque is available <a href="https://github.com/oisdk/SwiftDataStructures/blob/master/SwiftDataStructures/Deque.swift">here</a>.</p>
<p>A Deque is a data structure comprised of two stacks, facing opposite directions. In this way, operations at either end of the Deque have the same complexity as operations on one end of the underlying stack. This implementation uses two arrays, with the front reversed: appending, prepending, and removal of the first and last elements are all (amortized) O(1).</p>
<p>The standard library has three <code class="sourceCode scala">Array</code> structs: <code class="sourceCode scala">Array</code>, <code class="sourceCode scala">ArraySlice</code>, and <code class="sourceCode scala">ContiguousArray</code>. They all have the same interface, with different underlying implementations. An <code class="sourceCode scala">Array</code> is a standard vector-like structure, which allows O(1) amortized appending, fast iteration, etc. A <code class="sourceCode scala">ContiguousArray</code> has stricter rules about contiguity, but it’s not bridged to Objective-C.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let array  = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]
let cArray: ContiguousArray = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</code></pre></div>
<p>An <code class="sourceCode scala">ArraySlice</code> is a reference into an <code class="sourceCode scala">Array</code> or <code class="sourceCode scala">ContiguousArray</code>, for more efficient slicing. All the information an <code class="sourceCode scala">ArraySlice</code> contains is the beginning and end points of the slice (as well as any changes made to the slice separate from the array)</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let slice = array[<span class="dv">0</span>..&lt;<span class="dv">6</span>]</code></pre></div>
<p>To replicate these semantics in a Deque requires three separate structs: one with an <code class="sourceCode scala">Array</code> as the stack, another with an <code class="sourceCode scala">ArraySlice</code> as the stack, and a third with a <code class="sourceCode scala">ContiguousArray</code>. The standard library seems to duplicate the structs, along with their methods and properties.</p>
<p>It would be much nicer to just define a protocol that represented the <em>difference</em> between the deque types: then you could just write the methods and properties once, on top of it. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol DequeType {
  typealias Container : RangeReplaceableCollectionType, MutableSliceable
  <span class="kw">var</span> front: Container { get set }
  <span class="kw">var</span> back : Container { get set }
  <span class="fu">init</span>()
}</code></pre></div>
<p>There’s one problem with this: both stacks need to be made public. It would be much nicer to hide the stacks (especially since an invariant needs to be checked and maintained on every mutation). If anyone has an idea of how to accomplish that, <a href="https://twitter.com/oisdk">tweet me</a>.</p>
<p>The first method to implement is a subscript. Indexing is difficult, because the front stack will be reversed, so the index used to get in to the Deque will need to be translated into an equivalent index in the array.</p>
<p>Any (valid) index will point into either the front or back queue, and the transformations applied to it in each case is different. If it’s in the front, the end result will look like <code class="sourceCode scala">front[front.<span class="fu">endIndex</span> - <span class="dv">1</span> - i]</code>, whereas if it’s in the back, it should be <code class="sourceCode scala">back[i - front.<span class="fu">endIndex</span>]</code>. There’s nothing specified about the Containers except that they’re <code class="sourceCode scala">RangeReplaceableCollectionType</code> and <code class="sourceCode scala">MutableSliceable</code>, so the index types will have to be as generic as possible. (you could specify <code class="sourceCode scala">where Index == Int</code>, but that’s more specific than needed, and not very extensible.)</p>
<p>Both of those transformations are subtractions, an operation that’s possible on <code>RandomAccessIndexType</code>s with the <code class="sourceCode scala">advancedBy</code> method. <code class="sourceCode scala">advancedBy</code> takes the associated <code class="sourceCode scala">Distance</code> type of the <code class="sourceCode scala">RandomAccessIndexType</code>. That’s enough information to figure out that the Deque’s index type must be the same as the Distance of the Index of the Container.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension DequeType {
  typealias Index = Container.<span class="fu">Index</span>.<span class="fu">Distance</span>
}</code></pre></div>
<p>The method that will translate an index into the relevant index in the stacks will return an enum:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public enum IndexLocation&lt;I&gt; {
  <span class="kw">case</span> <span class="fu">Front</span>(I), <span class="fu">Back</span>(I)
}</code></pre></div>
<p>Then, the translate method itself:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension DequeType where
  Container.<span class="fu">Index</span> : RandomAccessIndexType,
  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {
  
  <span class="kw">private</span> func <span class="fu">translate</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>)
    -&gt; IndexLocation&lt;Container.<span class="fu">Index</span>&gt; {
    <span class="kw">return</span> i &lt; front.<span class="fu">count</span> ?
      .<span class="fu">Front</span>(front.<span class="fu">endIndex</span>.<span class="fu">predecessor</span>().<span class="fu">advancedBy</span>(-i)) :
      .<span class="fu">Back</span>(back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i - front.<span class="fu">count</span>))
  }
}</code></pre></div>
<p>This performs two steps: 1. Check which stack it’s in. 2. Subtract in the appropriate order</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let d: Deque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>] <span class="co">// [1, 2, 3 | 4, 5, 6]</span>

d.<span class="fu">translate</span>(<span class="dv">0</span>) <span class="co">// Front: 2</span>
d.<span class="fu">translate</span>(<span class="dv">4</span>) <span class="co">// Back: 1</span></code></pre></div>
<p>This means that the logic for converting distance to index is separated from the logic for actual indexing. Great! Here’s the indexing:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension DequeType where
  Container.<span class="fu">Index</span> : RandomAccessIndexType,
  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {
  <span class="kw">var</span> startIndex: Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> <span class="dv">0</span> }
  <span class="kw">var</span> endIndex  : Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> front.<span class="fu">count</span> + back.<span class="fu">count</span> }
  <span class="fu">subscript</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>) -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span> {
    get {
      switch <span class="fu">translate</span>(i) {
      <span class="kw">case</span> let .<span class="fu">Front</span>(i): <span class="kw">return</span> front[i]
      <span class="kw">case</span> let .<span class="fu">Back</span>(i): <span class="kw">return</span> back[i]
      }
    } set {
      switch <span class="fu">translate</span>(i) {
      <span class="kw">case</span> let .<span class="fu">Front</span>(i): front[i] = newValue
      <span class="kw">case</span> let .<span class="fu">Back</span>(i): back[i] = newValue
      }
    }
  }
}</code></pre></div>
<p>This makes things much easier to test and debug.</p>
<p>Here’s where the power of protocols becomes obvious. If you go back to the original definition of <code class="sourceCode scala">DequeType</code>, you can add <code class="sourceCode scala">Indexable</code>. It may seem like now only indexable things can conform, but what happens in practice is that when <code class="sourceCode scala">Indexable</code> looks for its requirements, <em>it can use the implementations in DequeType</em>. That means that we’ve just made anything that can conform to <code class="sourceCode scala">DequeType</code> indexable. That’s awesome.</p>
<p>Next job is ranged indices. This is a good bit more complicated than the individual indices, so it definitely will benefit from being separated into a translate method:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension DequeType where
  Container.<span class="fu">Index</span> : RandomAccessIndexType,
  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : BidirectionalIndexType {
  
  <span class="kw">private</span> func translate
    (i: Range&lt;Container.<span class="fu">Index</span>.<span class="fu">Distance</span>&gt;)
    -&gt; IndexRangeLocation&lt;Container.<span class="fu">Index</span>&gt; {
      <span class="kw">if</span> i.<span class="fu">endIndex</span> &lt;= front.<span class="fu">count</span> {
        let s = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">endIndex</span>)
        <span class="kw">if</span> s == front.<span class="fu">startIndex</span> &amp;&amp; i.<span class="fu">isEmpty</span> { <span class="kw">return</span> .<span class="fu">Between</span> }
        let e = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)
        <span class="kw">return</span> .<span class="fu">Front</span>(s..&lt;e)
      }
      <span class="kw">if</span> i.<span class="fu">startIndex</span> &gt;= front.<span class="fu">count</span> {
        let s = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">startIndex</span> - front.<span class="fu">count</span>)
        let e = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)
        <span class="kw">return</span> .<span class="fu">Back</span>(s..&lt;e)
      }
      let f = front.<span class="fu">startIndex</span>..&lt;front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)
      let b = back.<span class="fu">startIndex</span>..&lt;back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)
      <span class="kw">return</span> .<span class="fu">Over</span>(f, b)
  }
}

let otherDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>] <span class="co">// [0, 1, 2 | 3, 4, 5]</span>

otherDeque.<span class="fu">translate</span>(<span class="dv">0</span>...<span class="dv">2</span>) <span class="co">// Front: 0..&lt;3</span>
otherDeque.<span class="fu">translate</span>(<span class="dv">4</span>...<span class="dv">5</span>) <span class="co">// Back: 1..&lt;3</span>
otherDeque.<span class="fu">translate</span>(<span class="dv">2</span>...<span class="dv">5</span>) <span class="co">// Over: 0..&lt;1, 0..&lt;3</span>
otherDeque.<span class="fu">translate</span>(<span class="dv">3</span>..&lt;<span class="dv">3</span>) <span class="co">// Between</span></code></pre></div>
<p>The invariant that must be maintained in the deque is this: if either stack has more than one element, the other cannot be empty. If the invariant is violated, the longer stack is reversed, and put in place of the shorter.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public enum Balance {
  <span class="kw">case</span> FrontEmpty, BackEmpty, Balanced
}

extension DequeType {
  
  public <span class="kw">var</span> balance: Balance {
    <span class="fu">let</span> (f, b) = (front.<span class="fu">count</span>, back.<span class="fu">count</span>)
    <span class="kw">if</span> f == <span class="dv">0</span> {
      <span class="kw">if</span> b &gt; <span class="dv">1</span> {
        <span class="kw">return</span> .<span class="fu">FrontEmpty</span>
      }
    } <span class="kw">else</span> <span class="kw">if</span> b == <span class="dv">0</span> {
      <span class="kw">if</span> f &gt; <span class="dv">1</span> {
        <span class="kw">return</span> .<span class="fu">BackEmpty</span>
      }
    }
    <span class="kw">return</span> .<span class="fu">Balanced</span>
  }
  
  public <span class="kw">var</span> isBalanced: Bool {
    <span class="kw">return</span> balance == .<span class="fu">Balanced</span>
  }
}</code></pre></div>
<p>A deque is a good data structure for certain uses, especially those that require popping and appending from either end. <code class="sourceCode scala"><span class="fu">popFirst</span>()</code> and <code class="sourceCode scala"><span class="fu">popLast</span>()</code> aren’t included in the standard <code class="sourceCode scala">RangeReplaceableCollectionType</code>, though, so we’ll have to add our own.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension RangeReplaceableCollectionType where Index : BidirectionalIndexType {
  <span class="kw">private</span> mutating func <span class="fu">popLast</span>() -&gt; Generator.<span class="fu">Element</span>? {
    <span class="kw">return</span> isEmpty ? nil : <span class="fu">removeLast</span>()
  }
}

<span class="kw">var</span> mutableDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]
mutableDeque.<span class="fu">popLast</span>() <span class="co">// 5</span>
mutableDeque           <span class="co">// [0, 1, 2 | 3, 4]</span>

extension DequeType where Container.<span class="fu">Index</span> : BidirectionalIndexType {
  public mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {
    <span class="kw">return</span> back.<span class="fu">popLast</span>()
  }
}</code></pre></div>
<p>The method needs to include <code class="sourceCode scala"><span class="fu">check</span>()</code>, which we can do with <code>defer</code></p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {
  defer { <span class="fu">check</span>() }
  <span class="kw">return</span> back.<span class="fu">popLast</span>()
}

mutableDeque.<span class="fu">popLast</span>() <span class="co">// 4</span>
mutableDeque           <span class="co">// [0, 1, 2 | 3]</span>
mutableDeque.<span class="fu">popLast</span>() <span class="co">// 3</span>
mutableDeque           <span class="co">// [0 | 1, 2]</span></code></pre></div>
<p>You also can’t just pop from the back queue in <code class="sourceCode scala"><span class="fu">popLast</span>()</code>, because it may be the case that the front stack has one element left</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {
  defer { <span class="fu">check</span>() }
  <span class="kw">return</span> back.<span class="fu">popLast</span>() ?? front.<span class="fu">popLast</span>()
}

mutableDeque.<span class="fu">popLast</span>() <span class="co">// 2</span>
mutableDeque.<span class="fu">popLast</span>() <span class="co">// 1</span>
mutableDeque           <span class="co">// [0|]</span>
mutableDeque.<span class="fu">popLast</span>() <span class="co">// 0</span>
mutableDeque           <span class="co">// [|]</span>
mutableDeque.<span class="fu">popLast</span>() <span class="co">// nil</span></code></pre></div>
<p>The rest of the Deque was easy, with little to no repetition. Using protocols in this way was really surprisingly powerful: now, you can define a <code class="sourceCode scala">DequeType</code>, with full access to all of the collection methods, all the way up to <code class="sourceCode scala">RangeReplaceableCollectionType</code>, in five lines:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct Deque&lt;Element&gt; : DequeType {
  public <span class="kw">var</span> front, back: [Element]
  public typealias SubSequence = DequeSlice&lt;Element&gt;
  public <span class="fu">init</span>() { (front, back) = ([], []) }
}

public struct DequeSlice&lt;Element&gt; : DequeType {
  public <span class="kw">var</span> front, back: ArraySlice&lt;Element&gt;
  public typealias SubSequence = DequeSlice
  public <span class="fu">init</span>() { (front, back) = ([], []) }
}</code></pre></div>
<p>There’s no performance hit, there’s no safety problems. I only have one version of code to test, one version to change, one version to read. It’s completely extensible: you could use any kind of stack for the front and back. Even another Deque, if you were so inclined:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct DequeDeque&lt;Element&gt; : DequeType {
  <span class="kw">var</span> front, back: Deque&lt;Element&gt;
  typealias SubSequence = DequeDequeSlice&lt;Element&gt;
  <span class="fu">init</span>() { front = <span class="fu">Deque</span>(); back = <span class="fu">Deque</span>() }
}

struct DequeDequeSlice&lt;Element&gt; : DequeType {
  <span class="kw">var</span> front, back: DequeSlice&lt;Element&gt;
  typealias SubSequence = DequeDequeSlice
  <span class="fu">init</span>() { front = <span class="fu">DequeSlice</span>(); back = <span class="fu">DequeSlice</span>() }
}

let dd: DequeDeque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>]
dd.<span class="fu">front</span> <span class="co">// [4 | 3, 2, 1]</span>
dd.<span class="fu">back</span>  <span class="co">// [5 | 6, 7, 8]</span></code></pre></div>
<p>Woo protocols!</p>
]]></description>
    <pubDate>Mon, 24 Aug 2015 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2015-08-24-generic-deque.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Swift</title>
    <link>http://doisinkidney.com/posts/2015-08-11-swift-trie.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 11, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>If you google “cool data structures” you’ll get <a href="http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures">this</a> as your first result. It’s a stackoverflow question: “What are the lesser known but useful data structures?”. And the top answer is a Trie. I read up on them, and found out a lot of cool things about their use (as well as finding out that I’m now the kind of person who googles “cool data structures”). So I rocked on up to my playground, and got writing.</p>
<p>A Trie is a prefix tree. It’s another recursive data structure: each Trie contains other children Tries, identifiable by their prefixes.</p>
<p>It’s a bit of a hipster data structure, not very widely used, but it’s got some useful applications. It’s got set-like operations, with insertion and searching each at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the length of the sequence being searched for. A Set is the only way to go for hashable, unordered elements. But, if you’ve got <em>sequences</em> of hashable elements, a Trie might be for you. (one thing to note is that Sets are hashable themselves, so if the sequences you want to store are unordered, a Set of Sets is more applicable)</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1092px-Trie_example.svg.png" alt="A trie for keys" />
<p class="caption">A trie for keys</p>
</div>
<p>In Swift, we can do this by having every Trie contain a dictionary of prefixes and Tries. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct Trie&lt;Element : Hashable&gt; {
  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]
}</code></pre></div>
<p>We don’t run into the problem of structs not being allowed to be recursive here, because we don’t directly store a Trie within a Trie - we store a <em>dictionary</em>, and therefore a reference to the child Tries. In this dictionary, the keys correspond to the prefixes. So how do we fill it up? Like lists, we can use the decomposition properties of generators:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {
    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
      children = [head:<span class="fu">Trie</span>(gen:gen)]
    } <span class="kw">else</span> {
      children = [:]
    }
  }
  public init
    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;
    (_ seq: S) {
      self.<span class="fu">init</span>(gen: seq.<span class="fu">generate</span>())
  }
}</code></pre></div>
<p>That’s not really enough. That can store one sequence, but we need an <code class="sourceCode scala">insert</code> function. Here ya go:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> mutating func insert
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) {
      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()
      }
  }
  public mutating func insert
    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;
    (seq: S) {
      <span class="fu">insert</span>(seq.<span class="fu">generate</span>())
  }
}</code></pre></div>
<p>There’s a line in there that some may find offensive:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</code></pre></div>
<p>And, to be honest, I’m not a huge fan of it myself. It’s making use of the fact that you can call mutating methods on optionals with chaining. When you do it in this example, the optional is returned by the dictionary lookup: we then want to mutate that value, if it’s there, with an insertion.</p>
<p>If it’s <em>not</em> there, though, we want to add it in, so we’ve got to have some way of understanding and dealing with that. We could try and extract the child Trie, like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
  <span class="kw">if</span> <span class="kw">var</span> child = children[head] {
    child.<span class="fu">insert</span>(gen)
  } <span class="kw">else</span> {
    children[head] = <span class="fu">Trie</span>(gen: gen)
  }
}</code></pre></div>
<p>But the child there is just a copy of the actual child in the Trie we want to mutate. We could then set it back to the dictionary entry - but at this stage it feels like a lot of extra, inefficient work.</p>
<p>So, you can make use of the fact the functions which don’t return anything actually <em>do</em> return something: a special value called <code class="sourceCode scala">Void</code>, or <code class="sourceCode scala">()</code>. Except that, in this case, it’s <code class="sourceCode scala">()?</code> (or <code class="sourceCode scala">Optional&amp;lt;Void&amp;gt;</code>). We’re not interested in the void itself, obviously, just whether or not it’s <code class="sourceCode scala">nil</code>. So, one way you could use it would be like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> let _ = children[head]?.<span class="fu">insert</span>(gen) { <span class="kw">return</span> }
children[head] = <span class="fu">Trie</span>(gen: gen)</code></pre></div>
<p>Or, to use <code class="sourceCode scala">guard</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">guard let _ = children[head]?.<span class="fu">insert</span>(gen) <span class="kw">else</span> { children[head] = <span class="fu">Trie</span>(gen: gen) }</code></pre></div>
<p>But I think the nil coalescing operator is a little clearer, without the distraction of <code class="sourceCode scala">let</code> or <code class="sourceCode scala">_</code>.</p>
<p>This data structure, as you can see, has a very different feel to the list. For a start, it’s much more mutable, with in-place mutating methods being a little easier than methods that return a new Trie. Also, laziness is pretty much out of the question: almost every imaginable useful method would involve evaluation of the entire Trie. (if anyone <em>does</em> have a useful way of thinking about Tries lazily, I’d love to hear it)</p>
<p>The contains function, the most important of them all, is here:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> func contains
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) -&gt; Bool {
      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? <span class="kw">true</span>
  }
  public func contains
    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;
    (seq: S) -&gt; Bool {
      <span class="kw">return</span> <span class="fu">contains</span>(seq.<span class="fu">generate</span>())
  }
}</code></pre></div>
<p>So this uses more generators. If the generator is empty (<code class="sourceCode scala">gen.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>), then the Trie contains that sequence, as we have not yet found a dictionary without that element. Within the <code class="sourceCode scala"><span class="fu">map</span>()</code> we search for the next element from the generator. If <em>that</em> returns <code class="sourceCode scala">nil</code>, then the Trie doesn’t contain that sequence. Finally, if none of that works, return whether or not the child Trie contains the rest of the generator. Let’s try it out:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">var</span> jo = <span class="fu">Trie</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])
jo.<span class="fu">insert</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])
jo.<span class="fu">insert</span>([<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>])

jo.<span class="fu">contains</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]) <span class="co">// true</span>
jo.<span class="fu">contains</span>([<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]) <span class="co">// false</span></code></pre></div>
<p>There’s a catch. The <code class="sourceCode scala">contains</code> method doesn’t work as we’d like it to:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">jo.<span class="fu">contains</span>([<span class="dv">1</span>, <span class="dv">2</span>]) <span class="co">// true</span></code></pre></div>
<p>Because we return <code class="sourceCode scala"><span class="kw">true</span></code> <em>whenever</em> the generator runs out, our Trie “contains” every prefix of the sequences that have been inserted. This is not what we want. One way to solve this may be to return <code class="sourceCode scala"><span class="kw">true</span></code> only if the last Trie found has no children. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> func contains
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) -&gt; Bool {
      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? children.<span class="fu">isEmpty</span>
  }
}</code></pre></div>
<p>But this doesn’t really work either. what if we did <code class="sourceCode scala">jo.<span class="fu">insert</span>([<span class="dv">1</span>, <span class="dv">2</span>])</code>? Now, if we check if the Trie contains <code class="sourceCode scala">[<span class="dv">1</span>, <span class="dv">2</span>]</code>, we’ll get back <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>It’s time for flags. We need to add an extra variable to our Trie: a Boolean, which describes whether or not that Trie represents the end of a sequence.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct Trie&lt;Element : Hashable&gt; {
  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]
  <span class="kw">private</span> <span class="kw">var</span> endHere : Bool
}</code></pre></div>
<p>We’ll also need to change our <code class="sourceCode scala">insert</code> and <code class="sourceCode scala">init</code> functions, so that when the generator returns <code class="sourceCode scala">nil</code>, <code class="sourceCode scala">endHere</code> gets initialised to <code class="sourceCode scala"><span class="kw">true</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {
    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
      (children, endHere) = ([head:<span class="fu">Trie</span>(gen:gen)], <span class="kw">false</span>)
    } <span class="kw">else</span> {
      (children, endHere) = ([:], <span class="kw">true</span>)
    }
  }
}

extension Trie {
  <span class="kw">private</span> mutating func insert
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) {
      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()
      } <span class="kw">else</span> {
        endHere = <span class="kw">true</span>
      }
  }
}</code></pre></div>
<p>And the contains function now returns <code class="sourceCode scala">endHere</code>, instead of true:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public extension Trie {
  <span class="kw">private</span> func contains
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) -&gt; Bool {
      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? endHere
  }
}</code></pre></div>
<p>While we’re improving the <code class="sourceCode scala">contains</code> function, we could use <code class="sourceCode scala">guard</code> to make it much more readable:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public extension Trie {
  <span class="kw">private</span> func contains&lt;
    G : GeneratorType where G.<span class="fu">Element</span> == Element
    &gt;(<span class="kw">var</span> gen: G) -&gt; Bool {
      guard let head = gen.<span class="fu">next</span>() <span class="kw">else</span> { <span class="kw">return</span> endHere }
      <span class="kw">return</span> children[head]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>
  }
}</code></pre></div>
<p><a href="https://twitter.com/chriseidhof/status/629215881843884032">Chris Eidhof gave me this idea.</a> (Apparently there’s a Trie implementation in <a href="http://www.objc.io/books/fpinswift/">Functional Programming in Swift</a>, his book. I’ve not read it, but it’s on my list. If <a href="http://www.objc.io/books/advanced-swift/">Advanced Swift</a>is anything to go by, it should be fantastic.)</p>
<p>The objective of this Trie is to replicate all of the Set methods: Union, Intersect, etc. Most of those are manageable to build from just <code class="sourceCode scala">insert</code>, <code class="sourceCode scala">init</code>, and <code class="sourceCode scala">contains</code>, but there’s one other function that comes in handy: <code class="sourceCode scala">remove</code>.</p>
<p>Remove is deceptively difficult. You could just walk to the end of your given sequence to remove, and switch <code class="sourceCode scala">endHere</code> from <code class="sourceCode scala"><span class="kw">true</span></code> to <code class="sourceCode scala"><span class="kw">false</span></code>, but that’s kind of cheating. I mean, you’ll be storing the same amount of information that way after a removal. No, what you need is something that deletes branches of a tree that aren’t being used any more.</p>
<p>Again, this is a little complicated. You can’t just find the head of the sequence you want to remove, and then delete all children: you may be deleting other entries along with that. You <em>also</em> can’t just delete when a given Trie only contains one child: that child may branch off subsequently, or it may contain prefixes for the sequence you want to remove.</p>
<p>Crucially, all of the information telling you whether or not you can delete a given entry in a given Trie will come from the <em>children</em> of that Trie. What I decided to go with was this: I’ll have some mutating method that does the work recursively. However, this method also <em>returns</em> a value, representing some important information for whatever called it. In this case, the <code class="sourceCode scala">remove</code> method would remove, as you’d imagine, but it will also return a Boolean, signifying whether the Trie it was called on can be removed. Since I used the normal structure of having a private method take a generator, and then a public wrapper method take a sequence, I could have the public method just discard the Boolean.</p>
<p>Let’s go through it. Here’s the signature:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">private</span> mutating func remove&lt;
  G : GeneratorType where G.<span class="fu">Element</span> == Element
  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</code></pre></div>
<p>No surprises there. Similar to the other methods. Then, get the head from the generator:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> let head = g.<span class="fu">next</span>() {</code></pre></div>
<p>Within that if block is the meat of the logic, so I might skip to what happens if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code> for the start:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">private</span> mutating func remove&lt;
  G : GeneratorType where G.<span class="fu">Element</span> == Element
  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {
    <span class="kw">if</span> let head = g.<span class="fu">next</span>() {...}
    endHere = <span class="kw">false</span>
    <span class="kw">return</span> children.<span class="fu">isEmpty</span>
}</code></pre></div>
<p>So the sequence being removed has ended. That means that whatever Trie you’re on should have its <code class="sourceCode scala">endHere</code> set to <code class="sourceCode scala"><span class="kw">false</span></code>. To the user of the Trie, that’s all that matters: from now on, if the contains method on that Trie is used with that sequence, it will return false.</p>
<p>However, to find out if you can delete the data itself, it returns <code class="sourceCode scala">children.<span class="fu">isEmpty</span></code>. If it has no children, it does not hold any other sequences or information, so it can be deleted.</p>
<p>Now for inside the if block:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }
children.<span class="fu">removeValueForKey</span>(head)
<span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></code></pre></div>
<p>So it calls <code class="sourceCode scala">remove</code> on the child Trie corresponding to <code class="sourceCode scala">head</code>. That guard statement will fail for two distinct reasons: if <code class="sourceCode scala">children</code> doesn’t contain <code class="sourceCode scala">head</code>, then the sequence being removed wasn’t in the Trie in the first place. The method will then return false, so that no removal or mutation is done.</p>
<p>If it <em>does</em> contain <code class="sourceCode scala">head</code>, but the Bool returned from the remove method is <code class="sourceCode scala"><span class="kw">false</span></code>, that means that its <em>child</em> is not removable, so it is also not removable, so it should return <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>Otherwise, it will remove that member (<code class="sourceCode scala">children.<span class="fu">removeValueForKey</span>(head)</code>). Then, the Trie can decide whether or not it itself is removable: <code class="sourceCode scala"><span class="kw">return</span> !endHere &amp;amp;&amp;amp; children.<span class="fu">isEmpty</span></code>. If the <code class="sourceCode scala">endHere</code> is set to true, then it is the end of some sequence: it is not removable. Otherwise, it’s removable if it has no children. Here’s the whole thing, with its public version:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> mutating func remove&lt;
    G : GeneratorType where G.<span class="fu">Element</span> == Element
    &gt;(<span class="kw">var</span> g: G) -&gt; Bool { <span class="co">// Return value signifies whether or not it can be removed</span>
      <span class="kw">if</span> let head = g.<span class="fu">next</span>() {
        guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }
        children.<span class="fu">removeValueForKey</span>(head)
        <span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span>
      }
      endHere = <span class="kw">false</span>
      <span class="kw">return</span> children.<span class="fu">isEmpty</span>
  }
  public mutating func remove&lt;
    S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element
    &gt;(seq: S) {
      <span class="fu">remove</span>(seq.<span class="fu">generate</span>())
  }
}</code></pre></div>
<p>That was a little heavy. And kind of ugly. Let’s lighten things up for a second, with one of the loveliest <code class="sourceCode scala">count</code> properties I’ve seen:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  public <span class="kw">var</span> count: Int {
    <span class="kw">return</span> children.<span class="fu">values</span>.<span class="fu">reduce</span>(endHere ? <span class="dv">1</span> : <span class="dv">0</span>) { $<span class="dv">0</span> + $<span class="fl">1.</span>count }
  }
}</code></pre></div>
<p>All it’s really doing is counting the instances of a <code class="sourceCode scala"><span class="kw">true</span></code> <code class="sourceCode scala">endHere</code>. If the current Trie is an end, then it knows that it adds one to the count (<code class="sourceCode scala">endHere ? <span class="dv">1</span> : <span class="dv">0</span></code>), and it adds that to the sum of the counts of its children.</p>
<p>Now then. <code class="sourceCode scala">SequenceType</code>. <a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/">Getting tree-like structures to conform to <code class="sourceCode scala">SequenceType</code> is a bit of a pain</a>, mainly because of their recursiveness. Getting a linear representation is easy enough:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  public <span class="kw">var</span> contents: [[Element]] {
    <span class="kw">return</span> children.<span class="fu">flatMap</span> {
      (head: Element, child: Trie&lt;Element&gt;) -&gt; [[Element]] in
      child.<span class="fu">contents</span>.<span class="fu">map</span> { [head] + $<span class="dv">0</span> } + (child.<span class="fu">endHere</span> ? [[head]] : [])
    }
  }
}</code></pre></div>
<p>And then you could just return the generate method from that for your Trie’s generate method.</p>
<p>The problem is that it’s not very proper: you’re translating your data structure into another data structure just to iterate through it. What you really want is something that generates each element on demand.</p>
<p>But it gets ugly quick. You’ve got to do a lot of stuff by hand which it isn’t nice to do by hand, and you’ve got to employ some dirty tricks (like using closures as a kind of homemade <code class="sourceCode scala">indirect</code>). At any rate, here it is:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct TrieGenerator&lt;Element : Hashable&gt; : GeneratorType {
  <span class="kw">private</span> <span class="kw">var</span> children: DictionaryGenerator&lt;Element, Trie&lt;Element&gt;&gt;
  <span class="kw">private</span> <span class="kw">var</span> curHead : Element?
  <span class="kw">private</span> <span class="kw">var</span> curEnd  : Bool = <span class="kw">false</span>
  <span class="kw">private</span> <span class="kw">var</span> innerGen: (() -&gt; [Element]?)?
  <span class="kw">private</span> mutating func <span class="fu">update</span>() {
    guard <span class="fu">let</span> (head, child) = children.<span class="fu">next</span>() <span class="kw">else</span> { innerGen = nil; <span class="kw">return</span> }
    curHead = head
    <span class="kw">var</span> g = child.<span class="fu">generate</span>()
    innerGen = {g.<span class="fu">next</span>()}
    curEnd = child.<span class="fu">endHere</span>
  }
  public mutating func <span class="fu">next</span>() -&gt; [Element]? {
    <span class="kw">for</span> ; innerGen != nil; <span class="fu">update</span>() {
      <span class="kw">if</span> let next = innerGen!() {
        <span class="kw">return</span> [curHead!] + next
      } <span class="kw">else</span> <span class="kw">if</span> curEnd {
        curEnd = <span class="kw">false</span>
        <span class="kw">return</span> [curHead!]
      }
    }
    <span class="kw">return</span> nil
  }
  <span class="kw">private</span> <span class="fu">init</span>(_ from: Trie&lt;Element&gt;) {
    children = from.<span class="fu">children</span>.<span class="fu">generate</span>()
    <span class="fu">update</span>()
  }
}</code></pre></div>
<p>It’s got a similar logic to the lazy flatMap I did from a while ago.</p>
<p>The code is all available <a href="https://github.com/oisdk/SwiftTrie">here</a>, as a playground, or <a href="https://github.com/oisdk/SwiftSequence">here</a>, in SwiftSequence, where it’s accompanied by some tests.</p>
]]></description>
    <pubDate>Tue, 11 Aug 2015 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2015-08-11-swift-trie.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Monty Hall</title>
    <link>http://doisinkidney.com/posts/2015-08-03-monty-hall.html</link>
    <description><![CDATA[<div class="info">
    Posted on August  3, 2015
</div>
<div class="info">
    
        Part 1 of a <a href="/series/probability.html">3-part series on probability</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>The Monty Hall problem is a great example of how counter-intuitive probability can sometimes be. It goes something like this: say you’re on a gameshow, with the chance to win a car. You’re shown three doors, and the car is behind one, goats behind the other two. You pick a door, say the leftmost, but then the host of the gameshow stops you before it’s opened. He opens one of the two doors you didn’t pick, revealing a goat. He then asks you if you’d like to change your decision. So? Do you?</p>
<p>Perhaps surprisingly, you <em>should</em> change your decision. Your chances of winning a car go from 1/3 to 2/3.</p>
<p>If you’ve not thought for a while about the problem, the answer above might sound instinctively wrong. A few <a href="http://www.thomashanning.com/swift-playground-the-monty-hall-problem/">blog posts</a> over the past few weeks have made an effort to put some concrete numbers to the statistics, running simulations of each possibility, and counting up the amount of wins and losses.</p>
<p>I was still a little unsatisfied, though. I mean, showing me the actual numbers is fine, but I’d like something a little more <em>proof</em>-y. You can get close with a diagram:</p>
<div class="figure">
<img src="/images/monty-hall-tree.png" />

</div>
<p>Which makes it pretty clear what’s going on: since the host <em>has</em> to show a goat when he opens a door, if you’ve picked a goat, then the only door left after the host opens one is the car. That means that if you switch and pick a goat, you <em>have</em> to win. So if you decide to switch, then what you want to do is pick a <em>goat</em> first, and the chances of that are 2/3.</p>
<p>It would be far cooler if you could get some representation of that diagram in code, though.</p>
<p>Turns out we can! In Swift and Haskell (I’m branching out) you can represent probability in a list-like structure, with each element of the list being a tuple of some value and that value’s probability. All the probabilities in the list itself should add up to one. Here’s what it looks like in Swift:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Prob&lt;Element&gt; {
  <span class="kw">private</span> let contents: [(Element, Double)]
}</code></pre></div>
<p>and Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> getProb ::</span> [(a,<span class="dt">Rational</span>)] } <span class="kw">deriving</span> <span class="dt">Show</span>  </code></pre></div>
<p>Being a list kind of thing, ideally you’d want to be able to transform the elements, with a map kind of thing:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Prob {
  func fmap&lt;T&gt;(f: Element -&gt; T) -&gt; Prob&lt;T&gt; {
    <span class="kw">return</span> Prob&lt;T&gt;(contents.<span class="fu">map</span> { (v,p) <span class="fu">in</span> (<span class="fu">f</span>(v), p) })
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span>  
  fmap f (<span class="dt">Prob</span> xs) <span class="fu">=</span> <span class="dt">Prob</span> [(f x,p)<span class="fu">|</span>(x,p) <span class="ot">&lt;-</span> xs]</code></pre></div>
<p>So far, though, the probability information is kind of superfluous. There’s not even a decent way to generate it. How about we get it from a list, where we assume all things in the list have equal chances of happening:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension CollectionType where Index.<span class="fu">Distance</span> == Int {
  <span class="kw">var</span> equalProbs: Prob&lt;Generator.<span class="fu">Element</span>&gt; {
    let p = <span class="fl">1.0</span> / Double(count)
    <span class="kw">return</span> Prob&lt;Generator.<span class="fu">Element</span>&gt;(map { v <span class="fu">in</span> (v,p) })
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">equalProbs ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a
equalProbs x <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">$</span> map (flip (,) (<span class="dv">1</span><span class="fu">%</span>n))  x
  <span class="kw">where</span> n <span class="fu">=</span> fromIntegral (length x)</code></pre></div>
<p>Which is <em>fine</em>, I suppose, but still not very interesting. What we want is the idea of “branching” - like in the diagram. “If event A happens, then event B has X chance of happening, and event C has Y chance of happening”.</p>
<p>The normal rules of probability apply: the <em>overall</em> probability of B happening is equal to the probability of A multiplied by X. You could have several layers of branching from B and C onwards, with this multiplication happening at each stage.</p>
<p>You could represent this in code with a function <code>f</code>, which takes an event (A) and returns a new bunch of probabilities (B and C). Then, to get the overall probability of each, you’d have to <em>flatten</em> it. What you want, then, is a function that travels over a list of events and their probabilities, applying <code>f</code> to each, and flattening the result, by <em>multiplying</em> the probabilities of the inner lists by the probability of the event which generated it.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Prob {
  func flatMap&lt;T&gt;(f: Element -&gt; Prob&lt;T&gt;) -&gt; Prob&lt;T&gt; {
    <span class="kw">return</span> Prob&lt;T&gt;(contents.<span class="fu">flatMap</span> { (v,p) in
      <span class="fu">f</span>(v).<span class="fu">contents</span>.<span class="fu">map</span> { (x,ip) <span class="fu">in</span> (x,p*ip) }
    })
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span>
  return <span class="fu">=</span> pure
  <span class="dt">Prob</span> xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> 
    <span class="dt">Prob</span> [(y,px<span class="fu">*</span>py)<span class="fu">|</span>(x,px) <span class="ot">&lt;-</span> xs, (y,py) <span class="ot">&lt;-</span> getProb(f x)]</code></pre></div>
<p>Hey look! The M-word. Never mind that. Anyway…</p>
<p>Now we have enough tools to stimulate some basic probabilities. Let’s say you’re playing a game, which begins with a coin flip. If you get heads on the coin flip, it confers some advantage, and you have a 70% chance of winning. Otherwise, you’ve a 50% chance.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">enum Coin: String   { <span class="kw">case</span> H, T }
enum Result: String { <span class="kw">case</span> Win, Lose }

func <span class="fu">play</span>(c: Coin) -&gt; Prob&lt;Result&gt; {
  switch c {
  <span class="kw">case</span> .<span class="fu">H</span>: <span class="kw">return</span> <span class="fu">Prob</span>([(.<span class="fu">Win</span>,<span class="fl">0.7</span>),(.<span class="fu">Lose</span>,<span class="fl">0.3</span>)])
  <span class="kw">case</span> .<span class="fu">T</span>: <span class="kw">return</span> [.<span class="fu">Win</span>,.<span class="fu">Lose</span>].<span class="fu">equalProbs</span>
  }
}

[Coin.<span class="fu">H</span>,.<span class="fu">T</span>]
  .<span class="fu">equalProbs</span>
  .<span class="fu">flatMap</span>(play)

<span class="co">// 0.35: Result.Win</span>
<span class="co">// 0.15: Result.Lose</span>
<span class="co">// 0.25: Result.Win</span>
<span class="co">// 0.25: Result.Lose</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Coin</span>   <span class="fu">=</span> <span class="dt">H</span> <span class="fu">|</span> <span class="dt">T</span> <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="kw">data</span> <span class="dt">Result</span> <span class="fu">=</span> <span class="dt">Win</span> <span class="fu">|</span> <span class="dt">Lose</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">let</span> play <span class="dt">H</span> <span class="fu">=</span> <span class="dt">Prob</span> [(<span class="dt">Win</span>,<span class="dv">7</span><span class="fu">%</span><span class="dv">10</span>),(<span class="dt">Lose</span>,<span class="dv">3</span><span class="fu">%</span><span class="dv">10</span>)]
    play <span class="dt">T</span> <span class="fu">=</span> equalProbs [<span class="dt">Win</span>,<span class="dt">Lose</span>]

equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="fu">&gt;&gt;=</span> play</code></pre></div>
<p>There’s an obvious problem: duplicates. We need some way to <em>combine</em> the results by adding their probabilities together. To be honest, this was the least interesting part, so I’ll just dump the code here:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public enum Ordering { <span class="kw">case</span> LT, EQ, GT }

extension SequenceType {
  <span class="kw">private</span> typealias A = Generator.<span class="fu">Element</span>
  public func <span class="fu">mergeBy</span>( comp: (A, A) -&gt; Ordering
                     , _ merge: (A, A) -&gt; A) -&gt; [A] {
    <span class="kw">var</span> result: [A] = []
    <span class="kw">for</span> h in <span class="fu">sort</span>({ e in <span class="fu">comp</span>(e) == .<span class="fu">LT</span> }) {
      <span class="kw">if</span> <span class="kw">case</span> .<span class="fu">EQ</span>? = result.<span class="fu">last</span>.<span class="fu">map</span>({e in <span class="fu">comp</span>(h,e)}) {
        result.<span class="fu">append</span>(<span class="fu">merge</span>(result.<span class="fu">removeLast</span>(),h))
      } <span class="kw">else</span> {
        result.<span class="fu">append</span>(h)
      }
    }
    <span class="kw">return</span> result
  }
}

extension Prob {
  public func mergeProbs
    (comp: (Element,Element) -&gt; Ordering) -&gt; Prob {
      <span class="kw">return</span> <span class="fu">Prob</span>(contents:
        contents.<span class="fu">mergeBy</span>( {(a,b) in <span class="fu">comp</span>(a<span class="fl">.0</span>,b<span class="fl">.0</span>)}
                        , {(a,b) <span class="fu">in</span> (a<span class="fl">.0</span>,a<span class="fl">.1</span>+b<span class="fl">.1</span>)})
    )
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eqing ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
eqing c <span class="fu">=</span> (\a b <span class="ot">-&gt;</span> <span class="kw">case</span> c a b <span class="kw">of</span> <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">True</span> 
                                 _  <span class="ot">-&gt;</span> <span class="dt">False</span>)

<span class="ot">mergeBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
mergeBy m c <span class="fu">=</span> (foldl1&#39; m <span class="fu">&lt;$&gt;</span>) <span class="fu">.</span> groupBy (eqing c) <span class="fu">.</span> sortBy c

<span class="ot">mergeProbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a
mergeProbs <span class="fu">=</span>
  <span class="dt">Prob</span> <span class="fu">.</span> mergeBy (fmap <span class="fu">.</span> (<span class="fu">+</span>) <span class="fu">.</span> snd) (comparing fst) <span class="fu">.</span> getProb</code></pre></div>
<p>Now we get some nicer probabilities, though:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">comp</span>(a: Result, b:Result) -&gt; Ordering {
  <span class="fu">switch</span> (a,b) {
  <span class="kw">case</span> (.<span class="fu">Win</span>,.<span class="fu">Win</span>),(.<span class="fu">Lose</span>,.<span class="fu">Lose</span>): <span class="kw">return</span> .<span class="fu">EQ</span>
  <span class="kw">case</span> (.<span class="fu">Lose</span>,.<span class="fu">Win</span>): <span class="kw">return</span> .<span class="fu">LT</span>
  <span class="kw">case</span> (.<span class="fu">Win</span>,.<span class="fu">Lose</span>): <span class="kw">return</span> .<span class="fu">GT</span>
  }
}

[Coin.<span class="fu">H</span>,.<span class="fu">T</span>]
  .<span class="fu">equalProbs</span>
  .<span class="fu">flatMap</span>(play)
  .<span class="fu">mergeProbs</span>(comp)

<span class="co">// 0.4: Result.Lose</span>
<span class="co">// 0.6: Result.Win</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Result</span> <span class="kw">where</span>
  compare <span class="dt">Win</span> <span class="dt">Lose</span> <span class="fu">=</span> <span class="dt">GT</span>
  compare <span class="dt">Lose</span> <span class="dt">Win</span> <span class="fu">=</span> <span class="dt">LT</span>
  compare _    _   <span class="fu">=</span> <span class="dt">EQ</span>
  
mergeProbs ( equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="fu">&gt;&gt;=</span> play )</code></pre></div>
<p>And you can see what effect a loaded coin would have on your chances:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">Prob</span>([(Coin.<span class="fu">H</span>,<span class="fl">0.7</span>),(.<span class="fu">T</span>,<span class="fl">0.3</span>)])
  .<span class="fu">flatMap</span>(play)
  .<span class="fu">mergeProbs</span>(comp)

<span class="co">// 0.36: Result.Lose</span>
<span class="co">// 0.64: Result.Win</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mergeProbs ( <span class="dt">Prob</span> [(<span class="dt">H</span>,<span class="dv">7</span><span class="fu">%</span><span class="dv">10</span>),(<span class="dt">T</span>,<span class="dv">3</span><span class="fu">%</span><span class="dv">10</span>)] <span class="fu">&gt;&gt;=</span> play )</code></pre></div>
<p>So how does this apply to Monty Hall? Well, we’ve actually done most of the work already. We’ll represent the doors as an Int, and the choice by an enum.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public enum Choice { <span class="kw">case</span> Switch, Stick }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Switch</span> <span class="fu">|</span> <span class="dt">Stick</span></code></pre></div>
<p>Then, a <code class="sourceCode scala">chances</code> function. The logic here is a bit dense. First of all, if you’re going to stick, it doesn’t matter how many doors the host opens: your chance of getting a car is <code>1/n</code>, where <code>n</code> is the number of doors. However, if you’re going to switch, two things need to happen: you need to <em>not</em> pick the car on your first choice, <em>and</em> you need to pick the car on your second choice. The chance of picking the car on your second choice (if the one you picked on your first choice <em>wasn’t</em> the car) is the one over the number of doors, minus the number of doors the host opens, minus one.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public func <span class="fu">chances</span>(n: Int, _ p: Int, _ c: Choice)(_ d: Int)
  -&gt; Prob&lt;Bool&gt; {
    switch c {
    <span class="kw">case</span> .<span class="fu">Stick</span> : <span class="kw">return</span> (<span class="dv">1</span>...<span class="fu">n</span>).<span class="fu">equalProbs</span>.<span class="fu">fmap</span>(==d)
    <span class="kw">case</span> .<span class="fu">Switch</span>:
      let notFirst = <span class="fu">chances</span>(n,p,.<span class="fu">Stick</span>)(d).<span class="fu">fmap</span>(!)
      let second =
        <span class="fu">Repeat</span>(count: (n-p)-<span class="dv">2</span>, repeatedValue: <span class="kw">false</span>) + [<span class="kw">true</span>]
      <span class="kw">return</span> notFirst.<span class="fu">flatMap</span> { f in 
        second.<span class="fu">equalProbs</span>.<span class="fu">fmap</span> { s in f &amp;&amp; s } 
      }
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">chances ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span>
chances n _ <span class="dt">Stick</span>  d <span class="fu">=</span> fmap (<span class="fu">==</span>d) (equalProbs [<span class="dv">1</span><span class="fu">..</span>n])
chances n p <span class="dt">Switch</span> d <span class="fu">=</span> 
  (<span class="fu">&amp;&amp;</span>) <span class="fu">.</span> not          <span class="fu">&lt;$&gt;</span>
  chances n p <span class="dt">Stick</span> d <span class="fu">&lt;*&gt;</span>
  (equalProbs <span class="fu">$</span> <span class="dt">True</span> <span class="fu">:</span> replicate (n<span class="fu">-</span>p<span class="fu">-</span><span class="dv">2</span>) <span class="dt">False</span>)</code></pre></div>
<p>Finally, the <code>chanceOfCar</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public func chanceOfCar
  (n: Int, _ p: Int, _ s: Choice)
  -&gt; Prob&lt;Bool&gt; {
    <span class="kw">return</span> (<span class="dv">1</span>...<span class="fu">n</span>)
      .<span class="fu">equalProbs</span>
      .<span class="fu">flatMap</span>(<span class="fu">chances</span>(n,p,s))
      .<span class="fu">mergeProbs</span>(comp)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">chanceOfCar ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span>
chanceOfCar n p s <span class="fu">=</span> mergeProbs <span class="fu">$</span>
                    equalProbs [<span class="dv">1</span><span class="fu">..</span>n] <span class="fu">&gt;&gt;=</span> 
                    chances n p s</code></pre></div>
<p>Which returns, as you’d expect, 1/3 chance of car if you stick, and 2/3 if you switch.</p>
<p>One of the final cool things you can do with this is change the number of doors, and the number of doors the host opens, and see what happens:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">chanceOfCar</span>(<span class="dv">6</span>, <span class="dv">2</span>, .<span class="fu">Switch</span>) 
<span class="co">// 0.833333333333334: false, 0.166666666666667: true</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">chanceOfCar <span class="dv">8</span> <span class="dv">3</span> <span class="dt">Switch</span> <span class="fu">//</span> <span class="dv">7</span> <span class="fu">%</span> <span class="dv">32</span></code></pre></div>
<p>The advantage gets less and less, but never goes away.</p>
<p>If you check out the <a href="https://en.wikipedia.org/wiki/Monty_Hall_problem#N_doors">Wikipedia</a> entry on the problem, the formula for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>-doors is given: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>N</mi><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo>−</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><annotation encoding="application/x-tex">\frac{N−1}{N(N−p−1)}</annotation></semantics></math>.</p>
<p>We can plug that straight in to our versions, to see if they’re correct:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> sample <span class="fu">=</span> [(n,p)<span class="fu">|</span> n <span class="ot">&lt;-</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">20</span>], p <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>(n<span class="fu">-</span><span class="dv">2</span>)]] 
<span class="kw">let</span> expect <span class="fu">=</span> fmap frmla sample
             <span class="kw">where</span><span class="ot"> frmla ::</span> (<span class="dt">Integer</span>,<span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Rational</span>
                   frmla (n,p) <span class="fu">=</span> (n <span class="fu">-</span> <span class="dv">1</span>)<span class="fu">%</span>(n<span class="fu">*</span>(n<span class="fu">-</span>p<span class="fu">-</span><span class="dv">1</span>))

<span class="kw">let</span> actual <span class="fu">=</span> fmap t sample <span class="kw">where</span>
  t (n,p) <span class="fu">=</span> truePrb <span class="fu">$</span> getProb <span class="fu">$</span> chanceOfCar n p <span class="dt">Switch</span>
  truePrb <span class="fu">=</span> fromJust <span class="fu">.</span> (fmap snd) <span class="fu">.</span> (find fst)

expect <span class="fu">==</span> actual</code></pre></div>
<p>And it works! (I didn’t try the Swift version, because of floating-point inaccuracies)</p>
<p>You can see the code used <a href="https://github.com/oisdk/Monty-Hall">here</a>.</p>
]]></description>
    <pubDate>Mon, 03 Aug 2015 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2015-08-03-monty-hall.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>

    </channel>
</rss>
