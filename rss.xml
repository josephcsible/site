<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Donnacha Oisín Kidney's Blog</title>
        <link>http://doisinkidney.com</link>
        <description><![CDATA[Mainly writing about programming]]></description>
        <atom:link href="http://doisinkidney.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 05 May 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>Type-Level Induction in Haskell</title>
    <link>http://doisinkidney.com/posts/2018-05-05-induction.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  5, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>The code from this post is available as a <a href="https://gist.github.com/oisdk/23c430b807c788dd43dc4d986c5fdfdd">gist</a>.</p>
<p>One of the most basic tools for use in type-level programming is the Peano definition of the natural numbers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> ℕ
    <span class="fu">=</span> <span class="dt">Z</span>
    <span class="fu">|</span> <span class="dt">S</span> ℕ</code></pre></div>
<p>Using the new <code class="sourceCode haskell"><span class="dt">TypeFamilyDependencies</span></code> extension, we can parameterize the notion of “size”. I’m going to use the proportion symbol here:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family (t <span class="ot">∷</span> k) ∝ (n <span class="ot">∷</span> ℕ) <span class="fu">=</span> (a <span class="ot">∷</span> <span class="dt">Type</span>) <span class="fu">|</span> a <span class="ot">→</span> t n k</code></pre></div>
<p>Then, we can use it to provide an inductive class on the natural numbers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Finite</span> n <span class="kw">where</span>
    induction <span class="ot">∷</span> t ∝ <span class="dt">Z</span> <span class="ot">→</span> (<span class="ot">∀</span> k<span class="fu">.</span> t ∝ k <span class="ot">→</span> t ∝ <span class="dt">S</span> k) <span class="ot">→</span> t ∝ n

<span class="kw">instance</span> <span class="dt">Finite</span> <span class="dt">Z</span> <span class="kw">where</span>
    induction z _ <span class="fu">=</span> z
    <span class="ot">{-# inline induction #-}</span>

<span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span> <span class="dt">Finite</span> (<span class="dt">S</span> n) <span class="kw">where</span>
    induction z s <span class="fu">=</span> s (induction z s)
    <span class="ot">{-# inline induction #-}</span></code></pre></div>
<p>The <code class="sourceCode haskell">induction</code> function reads as the standard mathematical definition of induction: given a proof (value) of the zero case, and a proof that any proof is true for its successor, we can give you a proof of any finite number.</p>
<p>An added bonus here is that the size of something can usually be resolved at compile-time, so any inductive function on it should also be resolved at compile time.</p>
<p>We can use it to provide the standard instances for basic length-indexed lists:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span>
<span class="kw">data</span> <span class="dt">List</span> n a <span class="kw">where</span>
        <span class="dt">Nil</span>  <span class="ot">∷</span> <span class="dt">List</span> <span class="dt">Z</span> a
        (<span class="fu">:-</span>) <span class="ot">∷</span> a <span class="ot">→</span> <span class="dt">List</span> n a <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">S</span> n) a</code></pre></div>
<p>Some instances for those lists are easy:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">List</span> n) <span class="kw">where</span>
    fmap _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span>
    fmap f (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x <span class="fu">:-</span> fmap f xs</code></pre></div>
<p>However, for <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, we need some way to recurse on the size of the list. This is where induction comes in.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="kw">instance</span> <span class="ch">&#39;(List,a) ∝ n = List n a</span></code></pre></div>
<p>This lets us write <code class="sourceCode haskell">pure</code> in a pleasingly simple way:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span>
         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span>
    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)</code></pre></div>
<p>But can we also write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> using induction? Yes! Because we’ve factored out the induction itself, we just need to describe the notion of a “sized” function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> a ↦ b
<span class="kw">type</span> <span class="kw">instance</span> ((x <span class="ot">∷</span> a) ↦ (y <span class="ot">∷</span> b)) ∝ n <span class="fu">=</span> (x ∝ n) <span class="ot">→</span> (y ∝ n)</code></pre></div>
<p>Then we can write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> as so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span>
         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span>
    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)
    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span>
        induction
            (\<span class="dt">Nil</span> <span class="dt">Nil</span> <span class="ot">→</span> <span class="dt">Nil</span>)
            (\k (f <span class="fu">:-</span> fs) (x <span class="fu">:-</span> xs) <span class="ot">→</span> f x <span class="fu">:-</span> k fs xs)</code></pre></div>
<p>What about the <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance? For that, we need a little bit of plumbing: the type signature of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">&gt;&gt;=</span>) <span class="ot">∷</span> m a <span class="ot">→</span> (a <span class="ot">→</span> m b) <span class="ot">→</span> m b</code></pre></div>
<p>One of the parameters (the second <code>a</code>) doesn’t have a size: we’ll need to work around that, with <code class="sourceCode haskell"><span class="dt">Const</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Const</span> a <span class="ot">∷</span> ℕ <span class="ot">→</span> <span class="dt">Type</span>) ∝ n <span class="fu">=</span> <span class="dt">Const</span> a n</code></pre></div>
<p>Using this, we can write our <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">head&#39; <span class="ot">∷</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">→</span> a
head&#39; (x <span class="fu">:-</span> _) <span class="fu">=</span> x

tail&#39; <span class="ot">∷</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">→</span> <span class="dt">List</span> n a
tail&#39; (_ <span class="fu">:-</span> xs) <span class="fu">=</span> xs

<span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span>
         <span class="dt">Monad</span> (<span class="dt">List</span> n) <span class="kw">where</span>
    xs <span class="fu">&gt;&gt;=</span> (f <span class="ot">∷</span> a <span class="ot">→</span> <span class="dt">List</span> n b) <span class="fu">=</span>
        induction
            (\<span class="dt">Nil</span> _ <span class="ot">→</span> <span class="dt">Nil</span>)
            (\k (y <span class="fu">:-</span> ys) fn <span class="ot">→</span> head&#39; (fn (<span class="dt">Const</span> y)) <span class="fu">:-</span>
                               k ys (tail&#39; <span class="fu">.</span> fn <span class="fu">.</span> <span class="dt">Const</span> <span class="fu">.</span> getConst))
            xs
            (f <span class="fu">.</span> getConst <span class="ot">∷</span> <span class="dt">Const</span> a n <span class="ot">→</span> <span class="dt">List</span> n b)</code></pre></div>
<h2 id="type-family-dependencies">Type Family Dependencies</h2>
<p>Getting the above to work actually took a surprising amount of work: the crux is that the <code class="sourceCode haskell">∝</code> type family needs to be injective, so the “successor” proof can typecheck. Unfortunately, this means that every type can only have one notion of “size”. What I’d prefer is to be able to pass in a function indicating exactly <em>how</em> to get the size out of a type, that could change depending on the situation. So we could recurse on the first argument of a function, for instance, or just its second, or just the result. This would need either type-level lambdas (which would be cool), or <a href="https://ghc.haskell.org/trac/ghc/ticket/10832">generalized type family dependencies</a>.</p>
]]></description>
    <pubDate>Sat, 05 May 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-05-05-induction.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>5 Cool Things You Can Do With Pattern Synonyms</title>
    <link>http://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 12, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms">Pattern Synonyms</a> is an excellent extension for Haskell. There are some <a href="https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html">very</a> <a href="https://www.schoolofhaskell.com/user/icelandj/Pattern%20synonyms">cool</a> examples of their use out there, and I thought I’d add to the list.</p>
<h1 id="make-things-look-like-lists">Make Things Look Like Lists</h1>
<p>Lists are <em>the</em> fundamental data structure for functional programmers. Unfortunately, once more specialized structures are required, you often have to switch over to an uncomfortable, annoying API which isn’t as pleasant or fun to use as cons and nil. With pattern synonyms, though, that’s not so! For instance, here’s how you would do it with a run-length-encoded list:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a
    <span class="fu">=</span> <span class="dt">Nil</span>
    <span class="fu">|</span> <span class="dt">ConsN</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>
            a
            (<span class="dt">List</span> a)

<span class="ot">cons ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
cons x (<span class="dt">ConsN</span> i y ys)
  <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> <span class="dt">ConsN</span> (i<span class="fu">+</span><span class="dv">1</span>) y ys
cons x xs <span class="fu">=</span> <span class="dt">ConsN</span> <span class="dv">1</span> x xs

<span class="ot">uncons ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">List</span> a)
uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span>
uncons (<span class="dt">ConsN</span> <span class="dv">1</span> x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)
uncons (<span class="dt">ConsN</span> n x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, <span class="dt">ConsN</span> (n<span class="fu">-</span><span class="dv">1</span>) x xs)

<span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span>
pattern<span class="ot"> (:-) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))
  <span class="kw">where</span>
    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs
<span class="ot">{-# COMPLETE Nil, (:-) #-}</span>

zip<span class="ot"> ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b <span class="ot">-&gt;</span> <span class="dt">List</span> (a,b)
zip (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> (x,y) <span class="fu">:-</span> zip xs ys
zip _ _ <span class="fu">=</span> <span class="dt">Nil</span></code></pre></div>
<p>A little more useful would be to do the same with a heap:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Leaf</span>
    <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)

<span class="ot">smerge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
smerge <span class="dt">Leaf</span> ys <span class="fu">=</span> ys
smerge xs <span class="dt">Leaf</span> <span class="fu">=</span> xs
smerge h1<span class="fu">@</span>(<span class="dt">Node</span> x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> y ly ry)
  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Node</span> x (smerge h2 rx) lx
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> y (smerge h1 ry) ly

<span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
cons x <span class="fu">=</span> smerge (<span class="dt">Node</span> x <span class="dt">Leaf</span> <span class="dt">Leaf</span>)

<span class="ot">uncons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Tree</span> a)
uncons <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">Nothing</span>
uncons (<span class="dt">Node</span> x l r) <span class="fu">=</span> <span class="dt">Just</span> (x, smerge l r)

<span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span>
pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))
  <span class="kw">where</span>
    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs
<span class="ot">{-# COMPLETE Leaf, (:-) #-}</span>

sort<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
sort <span class="fu">=</span> go <span class="fu">.</span> foldr (<span class="fu">:-</span>) <span class="dt">Leaf</span>
  <span class="kw">where</span>
    go <span class="dt">Leaf</span> <span class="fu">=</span> []
    go (x <span class="fu">:-</span> xs) <span class="fu">=</span> x <span class="fu">:</span> go xs</code></pre></div>
<p>In fact, this pattern can be generalized, so <em>any</em> container-like-thing with a cons-like-thing can be modified as you would with lists. You can see the generalization in <a href="https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Cons.html#v::-60-">lens</a>.</p>
<h1 id="retroactively-make-lyah-examples-work">Retroactively Make <a href="http://learnyouahaskell.com">LYAH</a> Examples Work</h1>
<p>One of the most confusing things I remember about learning Haskell early-on was that the vast majority of the Monads examples didn’t work, because they were written pre-transformers. In other words, the state monad was defined like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</code></pre></div>
<p>But in transformers nowadays (which is where you get <code class="sourceCode haskell"><span class="dt">State</span></code> from if you import it in the normal way), the definition is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }

<span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span></code></pre></div>
<p>This results in some <em>very</em> confusing error messages when you try run example code.</p>
<p>However, we can pretend that the change never happened, with a simple pattern synonym:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }

<span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span>

<span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)
runState xs <span class="fu">=</span> runIdentity <span class="fu">.</span> runStateT xs

pattern <span class="dt">State</span><span class="ot"> ::</span> (s <span class="ot">-&gt;</span> (a, s)) <span class="ot">-&gt;</span> <span class="dt">State</span> s a
pattern <span class="dt">State</span> x <span class="ot">&lt;-</span> (runState <span class="ot">-&gt;</span> x)
  <span class="kw">where</span>
    <span class="dt">State</span> x <span class="fu">=</span> <span class="dt">StateT</span> (<span class="dt">Identity</span> <span class="fu">.</span> x)</code></pre></div>
<h1 id="getting-type-level-numbers-with-an-efficient-runtime-representation">Getting Type-Level Numbers With an Efficient Runtime Representation</h1>
<p>If you want to write type-level proofs on numbers, you’ll probably end up using Peano numerals and singletons:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span>

<span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span>
  <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span>
  <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)

<span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
  <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m
  <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)

<span class="ot">plusZeroIsZero ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n
plusZeroIsZero <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span>
plusZeroIsZero (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroIsZero n <span class="kw">of</span>
  <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></code></pre></div>
<p>Pretty cool, right? We can even erase the proof (if we really trust it) using rewrite rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{-# RULES </span>
<span class="co">&quot;plusZeroIsZero&quot; forall n. plusZeroIsZero n = unsafeCoerce Refl</span>
<span class="co">#-}</span></code></pre></div>
<p>This isn’t <em>ideal</em>, but it’s getting there.</p>
<p>However, if we ever want to use these things at runtime (perhaps as a type-level indication of some data structure’s size), we’re going to rely on the value-level Peano addition, which is bad news.</p>
<p>Not so with pattern synonyms!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> family <span class="dt">The</span><span class="ot"> k ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span>

<span class="kw">class</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k) <span class="kw">where</span><span class="ot"> sing ::</span> <span class="dt">The</span> k (<span class="ot">a ::</span> k)

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span>

<span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dt">Natural</span>

<span class="kw">instance</span> <span class="dt">Sing</span> <span class="dt">Z</span> <span class="kw">where</span>
    sing <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span>

<span class="kw">instance</span> <span class="dt">Sing</span> n <span class="ot">=&gt;</span> <span class="dt">Sing</span> (<span class="dt">S</span> n) <span class="kw">where</span>
    sing <span class="fu">=</span>
        (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>) <span class="ot">-&gt;</span> (<span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (<span class="dt">S</span> n)))
            succ sing

<span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span>
        <span class="dt">ZZy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span>
        <span class="dt">SSy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)

<span class="ot">getNatty ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> n
getNatty (<span class="dt">NatSing</span><span class="ot"> n ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n) <span class="fu">=</span> <span class="kw">case</span> n <span class="kw">of</span>
  <span class="dv">0</span> <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">Z</span>) <span class="dt">ZZy</span>
  _ <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">S</span> m) (<span class="dt">SSy</span> (<span class="dt">NatSing</span> (pred n)))

pattern <span class="dt">Zy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">Z</span>) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n
pattern <span class="dt">Zy</span> <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">ZZy</span>) <span class="kw">where</span> <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span>

pattern <span class="dt">Sy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">S</span> m) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n
pattern <span class="dt">Sy</span> x <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">SSy</span> x) <span class="kw">where</span> <span class="dt">Sy</span> (<span class="dt">NatSing</span> x) <span class="fu">=</span> <span class="dt">NatSing</span> (succ x)
<span class="ot">{-# COMPLETE Zy, Sy #-}</span>

<span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
        <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m
        <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)

<span class="co">-- | Efficient addition, with type-level proof.</span>
<span class="ot">add ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)
add <span class="fu">=</span> (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>)
              <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)) (<span class="fu">+</span>)

<span class="co">-- | Proof on efficient representation.</span>
<span class="ot">addZeroRight ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n
addZeroRight <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span>
addZeroRight (<span class="dt">Sy</span> n) <span class="fu">=</span> gcastWith (addZeroRight n) <span class="dt">Refl</span></code></pre></div>
<p>(unfortunately, incomplete pattern warnings don’t work here)</p>
<h1 id="hide-your-implementations">Hide Your Implementations</h1>
<p>So you’ve got a tree type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Tip</span>
    <span class="fu">|</span> <span class="dt">Bin</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</code></pre></div>
<p>And you’ve spent some time writing a (reasonably difficult) function on the tree:</p>
<p><details> <summary> Complicated function on the tree </summary></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showTree ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
showTree <span class="dt">Tip</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span>
showTree (<span class="dt">Bin</span> x&#39; ls&#39; rs&#39;) <span class="fu">=</span> go <span class="dt">True</span> id xlen&#39; ls&#39;
                          <span class="fu">$</span> showString xshw&#39;
                          <span class="fu">$</span> endc ls&#39; rs&#39;
                          <span class="fu">$</span> showChar <span class="ch">&#39;\n&#39;</span>
                          <span class="fu">$</span> go <span class="dt">False</span> id xlen&#39; rs&#39; <span class="st">&quot;&quot;</span>
  <span class="kw">where</span>
    xshw&#39; <span class="fu">=</span> show x&#39;
    xlen&#39; <span class="fu">=</span> length xshw&#39;

    go _ _ _ <span class="dt">Tip</span> <span class="fu">=</span> id
    go up k i (<span class="dt">Bin</span> x ls rs) <span class="fu">=</span> branch <span class="dt">True</span> ls
                            <span class="fu">.</span> k
                            <span class="fu">.</span> pad i
                            <span class="fu">.</span> showChar (bool <span class="ch">&#39;└&#39;</span> <span class="ch">&#39;┌&#39;</span> up)
                            <span class="fu">.</span> showString xshw
                            <span class="fu">.</span> endc ls rs
                            <span class="fu">.</span> showChar <span class="ch">&#39;\n&#39;</span>
                            <span class="fu">.</span> branch <span class="dt">False</span> rs
      <span class="kw">where</span>
        xshw <span class="fu">=</span> show x
        xlen <span class="fu">=</span> length xshw
        branch d
          <span class="fu">|</span> d <span class="fu">==</span> up <span class="fu">=</span> go d (k <span class="fu">.</span> pad i) (xlen <span class="fu">+</span> <span class="dv">1</span>) 
          <span class="fu">|</span> otherwise <span class="fu">=</span> go d (k <span class="fu">.</span> pad i <span class="fu">.</span> showChar <span class="ch">&#39;│&#39;</span>) xlen 

    endc <span class="dt">Tip</span>    <span class="dt">Tip</span>    <span class="fu">=</span> id
    endc <span class="dt">Bin</span> {} <span class="dt">Tip</span>    <span class="fu">=</span> showChar <span class="ch">&#39;┘&#39;</span>
    endc <span class="dt">Tip</span>    <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;┐&#39;</span>
    endc <span class="dt">Bin</span> {} <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;┤&#39;</span>

    pad <span class="fu">=</span> (<span class="fu">++</span>) <span class="fu">.</span> flip replicate <span class="ch">&#39; &#39;</span></code></pre></div>
<p></details></p>
<p>But, for some reason or another, you need to add a field to your <code class="sourceCode haskell"><span class="dt">Bin</span></code> constructor, to store the size of the subtree (for instance). Does this function have to change? No! Simply change the tree definition as so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Tip</span>
    <span class="fu">|</span> <span class="dt">Bin&#39;</span> <span class="dt">Int</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)

pattern <span class="dt">Bin</span> x ls rs <span class="ot">&lt;-</span> <span class="dt">Bin&#39;</span> n x ls rs
<span class="ot">{-# COMPLETE Tip, Bin #-}</span></code></pre></div>
<p>And all the old code works!</p>
<p>This gets to the core of pattern synonyms: it’s another tool which we can use to separate implementation from API.</p>
<h1 id="better-smart-constructors">Better Smart Constructors</h1>
<p>Say you’ve got a data type that has certain constraints on what values it can hold. You’re not writing a paper for ICFP, so expressing those constraints as a beautiful type isn’t required: you just want to only export the constructor and accessors, and write some tests to make sure that those functions always obey the constraints.</p>
<p>But once you do this you’ve lost something: pattern-matching. Let’s get it back with pattern synonyms!</p>
<p>As our simple example, our constraint is going to be “A list where the values are always ordered”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> {<span class="ot"> getList ::</span> [a] }

<span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
cons x (<span class="dt">List</span> xs) <span class="fu">=</span> <span class="dt">List</span> (insert x xs)

<span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span>
pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (<span class="dt">List</span> (x<span class="fu">:</span>xs))
  <span class="kw">where</span>
    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs

pattern <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">List</span> []
<span class="ot">{-# COMPLETE Nil, (:-) #-}</span></code></pre></div>
]]></description>
    <pubDate>Thu, 12 Apr 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Countdown</title>
    <link>http://doisinkidney.com/posts/2018-03-20-countdown.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>There’s a popular UK TV show called <a href="https://en.wikipedia.org/wiki/Countdown_(game_show)">Countdown</a> with a round where contestants have to get as close to some target number as possible by constructing an arithmetic expression from six random numbers.</p>
<p>You don’t have to use all of the numbers, and you’re allowed use four operations: addition, subtraction, multiplication, and division. Additionally, each stage of the calculation must result in a positive integer.</p>
<p>Here’s an example. Try get to the target 586:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>,</mo><mn>25</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">100,25,1,5,3,10</annotation></semantics></math></p>
<p>On the show, contestants get 30 seconds to think of an answer.</p>
<p><details> <summary> Solution </summary> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn><mo>+</mo><mn>100</mn><mo>*</mo><mn>5</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10 + 100 * 5 + 1</annotation></semantics></math> </details></p>
<p>Solving it in Haskell was first explored in depth in <span class="citation">Hutton (<a href="#ref-hutton_countdown_2002">2002</a>)</span>. There, a basic “generate-and-test” implementation was provided and proven correct.</p>
<p>As an optimization problem, there are several factors which will influence the choice of algorithm:</p>
<ol style="list-style-type: decimal">
<li>There’s no obvious heuristic for constructing subexpressions in order to get to a final result. In other words, if we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>*</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 * 10</annotation></semantics></math>, there’s no easy way to tell which is “closer” to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>586</mn><annotation encoding="application/x-tex">586</annotation></semantics></math>. The latter is closer numerically, but the former is what we ended up using in the solution.</li>
<li>Because certain subexpressions aren’t allowed, we’ll be able to prune the search space as we go.</li>
<li>Ideally, we’d only want to calculate each possible subexpression once, making it a pretty standard dynamic programming problem.</li>
</ol>
<p>I’ll be focusing on the third point in this post, but we can add the second point in at the end. First, however, let’s write a naive implementation.</p>
<h2 id="generating-all-expressions">Generating all Expressions</h2>
<p>I can’t think of a simpler way to solve the problem than generate-and-test, so we’ll work from there. Testing is easy (<code class="sourceCode haskell">(target <span class="fu">==</span>) <span class="fu">.</span> eval</code>), so we’ll focus on generation. The core function we’ll use for this is usually called “unmerges”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">unmerges [x,y] <span class="fu">=</span> [([x],[y])]
unmerges (x<span class="fu">:</span>xs) <span class="fu">=</span>
    ([x],xs) <span class="fu">:</span>
    concat
        [ [(x<span class="fu">:</span>ys,zs),(ys,x<span class="fu">:</span>zs)]
        <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs ]
unmerges _ <span class="fu">=</span> []</code></pre></div>
<p>It generates all possible 2-partitions of a list, ignoring order:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> unmerges <span class="st">&quot;abc&quot;</span>
[(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;bc&quot;</span>),(<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;c&quot;</span>),(<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ac&quot;</span>)]</code></pre></div>
<p>I haven’t looked much into how to optimize this function or make it nicer, as we’ll be swapping it out later.</p>
<p>Next, we need to make the recursive calls:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">allExprs ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
allExprs _ [x] <span class="fu">=</span> [x]
allExprs c xs <span class="fu">=</span>
    [ e
    <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs
    , y <span class="ot">&lt;-</span> allExprs c ys
    , z <span class="ot">&lt;-</span> allExprs c zs
    , e <span class="ot">&lt;-</span> c y z ]</code></pre></div>
<p>Finally, using the <a href="https://hackage.haskell.org/package/simple-reflect">simple-reflect</a> library, we can take a look at the output:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y,x<span class="fu">*</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]
[<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>,<span class="dv">1</span> <span class="fu">*</span> <span class="dv">2</span>]
<span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]
[<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>),<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>,<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>)]</code></pre></div>
<p>Even at this early stage, we can actually already write a rudimentary solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">countdown ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]
countdown xs targ <span class="fu">=</span>
    filter
        ((<span class="fu">==</span>) targ <span class="fu">.</span> toInteger)
        (allExprs
             (\x y <span class="ot">-&gt;</span> [x,y,x<span class="fu">+</span>y,x<span class="fu">*</span>y])
             (map fromInteger xs))

<span class="fu">&gt;&gt;&gt;</span> mapM_ print (countdown [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>] <span class="dv">586</span>)
<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))
<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))
<span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))
<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))
<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span>
<span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>
<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span>
<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))
<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))</code></pre></div>
<p>As you can see from the output, there’s a lot of repetition. We’ll need to do some memoization to speed it up.</p>
<h2 id="pure-memoization">Pure Memoization</h2>
<p>The normal way most programmers think about “memoization” is something like this:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">memo_dict <span class="op">=</span> {<span class="dv">0</span>:<span class="dv">0</span>,<span class="dv">1</span>:<span class="dv">1</span>}

<span class="kw">def</span> fib(n):
    <span class="cf">if</span> n <span class="kw">in</span> memo_dict:
        <span class="cf">return</span> memo_dict[n]
    <span class="cf">else</span>:
        res <span class="op">=</span> fib(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib(n<span class="op">-</span><span class="dv">2</span>)
        memo_dict[n] <span class="op">=</span> res
        <span class="cf">return</span> res</code></pre></div>
<p>In other words, it’s a fundamentally stateful process. We need to mutate some mapping when we haven’t seen the argument before.</p>
<p>Using laziness, though, we can emulate the same behavior purely. Instead of mutating the mapping on function calls, we fill the whole thing at the beginning, and then index into it. As long as the mapping is lazy, it’ll only evaluate the function calls when they’re needed. We could use lists as our mapping to the natural numbers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> map fib [<span class="dv">2</span><span class="fu">..</span>]
fib n <span class="fu">=</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">2</span>)</code></pre></div>
<p>The benefit here is that we avoid the extra work of redundant calls. However, we pay for the speedup in three ways:</p>
<ol class="example" style="list-style-type: decimal">
<li>Space: we need to take up memory space storing the cached solutions.</li>
<li>Indexing: while we no longer have to pay for the expensive recursive calls, we <em>do</em> now have to pay for indexing into the data structure. In this example, we’re paying linear time to index into the list.</li>
<li>Generality: the memoization is tied directly to the argument type to the function. We need to be able to use the argument to our memoized function as an index into some data structure. While a lot of argument types admit some type of indexing (whether they’re <code class="sourceCode haskell"><span class="dt">Hashable</span></code>, <code class="sourceCode haskell"><span class="dt">Ord</span></code>, etc.), some don’t, and we can’t memoize those using this technique.</li>
</ol>
<p>We’re going to look at a technique that allow us to somewhat mitigate 2 and 3 above, using something called a <em>nexus</em>.</p>
<h2 id="nexuses">Nexuses</h2>
<p>The standard technique of memoization is focused on the arguments to the function, creating a concrete representation of them in memory to map to the results. Using nexuses, as described in <span class="citation">Bird and Hinze (<a href="#ref-bird_functional_2003">2003</a>)</span>, we’ll instead focus on the function itself, creating a concrete representation of its call graph in memory. Here’s the call graph of Fibonacci:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">                                            ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span>
                                   ┌fib(<span class="dv">2</span>)<span class="fu">=</span><span class="dv">1</span>┤
                                   │        └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span>
                          ┌fib(<span class="dv">3</span>)<span class="fu">=</span><span class="dv">2</span>┤
                          │        └fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span>
                 ┌fib(<span class="dv">4</span>)<span class="fu">=</span><span class="dv">3</span>┤
                 │        │        ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span>
                 │        └fib(<span class="dv">2</span>)<span class="fu">=</span><span class="dv">1</span>┤
                 │                 └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span>
        ┌fib(<span class="dv">5</span>)<span class="fu">=</span><span class="dv">5</span>┤
        │        │                 ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span>
        │        │        ┌fib(<span class="dv">2</span>)<span class="fu">=</span><span class="dv">1</span>┤
        │        │        │        └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span>
        │        └fib(<span class="dv">3</span>)<span class="fu">=</span><span class="dv">2</span>┤
        │                 └fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span>
fib(<span class="dv">6</span>)<span class="fu">=</span><span class="dv">8</span>┤
        │                          ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span>
        │                 ┌fib(<span class="dv">2</span>)<span class="fu">=</span><span class="dv">1</span>┤
        │                 │        └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span>
        │        ┌fib(<span class="dv">3</span>)<span class="fu">=</span><span class="dv">2</span>┤
        │        │        └fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span>
        └fib(<span class="dv">4</span>)<span class="fu">=</span><span class="dv">3</span>┤
                 │        ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span>
                 └fib(<span class="dv">2</span>)<span class="fu">=</span><span class="dv">1</span>┤
                          └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></code></pre></div>
<p>Turning <em>that</em> into a concrete datatype wouldn’t do us much good: it still has the massively redundant computations in it. However, we can recognize that entire subtrees are duplicates of each other: in those cases, instead of creating both subtrees, we could just create one and have each parent point to it<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        ┌fib(<span class="dv">5</span>)<span class="fu">=</span><span class="dv">5</span>┬────────┬fib(<span class="dv">3</span>)<span class="fu">=</span><span class="dv">2</span>┬────────┬fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span>
fib(<span class="dv">6</span>)<span class="fu">=</span><span class="dv">8</span>┤        │        │        │        │
        └────────┴fib(<span class="dv">4</span>)<span class="fu">=</span><span class="dv">3</span>┴────────┴fib(<span class="dv">2</span>)<span class="fu">=</span><span class="dv">1</span>┴fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></code></pre></div>
<p>This is a nexus. In Haskell, it’s not observably different from the other form, except that it takes up significantly less space. It’s also much quicker to construct.</p>
<p>If we use it to memoize <code class="sourceCode haskell">fib</code>, we’ll no longer be indexing on the argument: we’ll instead follow the relevant branch in the tree to the subcomputation, which is just chasing a pointer. It also means the argument doesn’t have to be constrained to any specific type. Here’s how you’d do it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span>
    <span class="fu">=</span> <span class="dt">Leaf</span>
    <span class="fu">|</span> <span class="dt">Node</span>
    {<span class="ot"> val   ::</span> <span class="dt">Integer</span>
    ,<span class="ot"> left  ::</span> <span class="dt">Tree</span>
    ,<span class="ot"> right ::</span> <span class="dt">Tree</span>}

<span class="ot">fib ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fib <span class="fu">=</span> val <span class="fu">.</span> go
  <span class="kw">where</span>
    go <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>
    go <span class="dv">1</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">1</span> (<span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>) <span class="dt">Leaf</span>
    go n <span class="fu">=</span> node t (left t) <span class="kw">where</span> t <span class="fu">=</span> go (n<span class="fu">-</span><span class="dv">1</span>)
    node l r <span class="fu">=</span> <span class="dt">Node</span> (val l <span class="fu">+</span> val r) l r</code></pre></div>
<p>So this approach sounds amazing, right? No constraints on the argument type, no need to pay for indexing: why doesn’t everyone use it everywhere? The main reason is that figuring out a nexus for the call-graph is <em>hard</em>. In fact, finding an optimal one is NP-hard in general <span class="citation">(Steffen and Giegerich <a href="#ref-steffen_table_2006">2006</a>)</span>.</p>
<p>The second problem is that it’s difficult to abstract out. The standard technique of memoization relies on building a mapping from keys to values: about as bread-and-butter as it gets in programming. Even more, we already know how to say “values of this type can be used efficiently as keys in some mapping”: for Data.Map it’s <code class="sourceCode haskell"><span class="dt">Ord</span></code>, for Data.HashMap it’s <code class="sourceCode haskell"><span class="dt">Hashable</span></code>. All of this together means we can build a nice library for memoization which exports the two following functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">memoHash ::</span> <span class="dt">Hashable</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)
<span class="ot">memoOrd ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</code></pre></div>
<p>Building a nexus, however, is not bread-and-butter. On top of that, it’s difficult to say something like “recursive functions of this structure can be constructed using a nexus”. What’s the typeclass for that? In comparison to the signatures above, the constraint will need to be on the <em>arrows</em>, not the <code class="sourceCode haskell">a</code>. Even talking about the structure of recursive functions is regarded as somewhat of an advanced subject: that said, the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> package allows us to do so, and even has facilities for constructing something <em>like</em> nexuses with histomorphisms <span class="citation">(Tobin <a href="#ref-tobin_time_2016">2016</a>)</span>. I’m still looking to see if there’s a library out there that <em>does</em> manage to abstract nexuses in an ergonomic way, so I’d love to hear if there was one (or if there’s some more generalized form which accomplishes the same).</p>
<h2 id="memoizing-countdown">Memoizing Countdown</h2>
<p>That’s enough preamble. The nexus we want to construct for countdown is <em>not</em> going to memoize as much as possible: in particular, we’re only going to memoize the shape of the trees, not the operators used. This will massively reduce the memory overhead, and still give a decent speedup <span class="citation">(Bird and Mu <a href="#ref-bird_countdown:_2005">2005</a>, 11 “building a skeleton tree first”)</span>.</p>
<p>With that in mind, the ideal nexus looks something like this:</p>
<div class="figure">
<img src="/images/boolean-lattice.svg" />

</div>
<p>We can represent the tree in Haskell as a rose tree:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Node</span>
    {<span class="ot"> root   ::</span> a
    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a
    }

<span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</code></pre></div>
<p>Constructing the nexus itself isn’t actually the most interesting part of this solution: <em>consuming</em> it is. We need to be able to go from the structure above into a list that’s the equivalent of <code class="sourceCode haskell">unmerges</code>. Doing a breadth-first traversal of the diagram above (without the top element) will give us:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi><mo>,</mo><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd, ab, ac, bc, ad, bd, cd, a, b, c, d</annotation></semantics></math></p>
<p>If you split that list in half, and zip it with its reverse, you’ll get the output of <code class="sourceCode haskell">unmerges</code>.</p>
<p>However, the breadth-first traversal of the diagram isn’t the same thing as the breadth-first traversal of the rose tree. The latter will traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd</annotation></semantics></math>, and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">ab,ac,bc</annotation></semantics></math>), and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ab,ad,bd</annotation></semantics></math>): and here’s our problem. We traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math> twice, because we can’t know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> are pointing to the same value. What we have to do is first prune the tree, removing duplicates, and then perform a breadth-first traversal on that.</p>
<h3 id="pruning">Pruning</h3>
<p>Luckily, the duplicates follow a pattern, allowing us to remove them without having to do any equality checking. In each row, the first node has no duplicates in its children, the second’s first child is a duplicate, the third’s first and second children are duplicates, and so on. You should be able to see this in the diagram above. Adapting a little from the paper, we get an algorithm like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">para ::</span> (a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
para f b <span class="fu">=</span> go
  <span class="kw">where</span>
    go [] <span class="fu">=</span> b
    go (x<span class="fu">:</span>xs) <span class="fu">=</span> f x xs (go xs)

<span class="ot">prune ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> <span class="dt">Forest</span> a
prune ts <span class="fu">=</span> pruneAt ts <span class="dv">0</span> 
  <span class="kw">where</span>
    pruneAt <span class="fu">=</span> para f (const [])
    f (<span class="dt">Node</span> x []) t _ _ <span class="fu">=</span> <span class="dt">Node</span> x [] <span class="fu">:</span> t
    f (<span class="dt">Node</span> x us) _ a k <span class="fu">=</span>
        <span class="dt">Node</span> x (pruneAt (drop k us) k) <span class="fu">:</span> a (k <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<h3 id="breadth-first-traversal">Breadth-First Traversal</h3>
<p>I went through this in a <a href="/posts/2018-03-17-rose-trees-breadth-first.html">previous post</a>, so this is the end solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]
breadthFirst ts <span class="fu">=</span> foldr f b ts []
  <span class="kw">where</span>
    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs<span class="fu">:</span>bw)

    b [] <span class="fu">=</span> []
    b q <span class="fu">=</span> foldl (foldr f) b q []</code></pre></div>
<p>With the appropriate incantations, this is actually the fastest implementation I’ve found.</p>
<h3 id="fusing">Fusing</h3>
<p>We can actually inline both of the above functions, fusing them together:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">spanNexus ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]
spanNexus ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []
  <span class="kw">where</span>
    f (<span class="dt">Node</span> x us) fw k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k<span class="fu">+</span><span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)

    b [] <span class="fu">=</span> []
    b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []</code></pre></div>
<h3 id="halving-convolving-and-folding">Halving, Convolving, and Folding</h3>
<p>So, now we can go from the tree to our list of splits. Next step is to convert that list into the output of unmerges, by zipping the reverse of the first half with the second. We can use an algorithm described in <span class="citation">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> to do the zipping and reversing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fold xs n <span class="fu">=</span> go xs n (const [])
  <span class="kw">where</span>
    go xs <span class="dv">0</span>     k <span class="fu">=</span> k xs
    go (x<span class="fu">:</span>xs) n k <span class="fu">=</span> go xs (n<span class="fu">-</span><span class="dv">2</span>) (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> k ys)</code></pre></div>
<p>And we can inline the function which collapses those results into one:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fold xs n <span class="fu">=</span> go xs n (const [])
  <span class="kw">where</span>
    go <span class="dv">0</span> xss k <span class="fu">=</span> k xss
    go n (xs<span class="fu">:</span>xss) k <span class="fu">=</span>
        go (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z
                                      <span class="fu">|</span> x <span class="ot">&lt;-</span> xs
                                      , y <span class="ot">&lt;-</span> ys
                                      , z <span class="ot">&lt;-</span> cmb x y
                                      ] <span class="fu">++</span> k yss)</code></pre></div>
<p>And that’s all we need!</p>
<p><details> <summary> Full Code </summary></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Tree</span> <span class="kw">as</span> <span class="dt">Rose</span>

<span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Int</span> a
    <span class="fu">|</span> <span class="dt">Node</span> [<span class="dt">Tree</span> a]
    <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">Functor</span>)
    
<span class="ot">enumerateTrees ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
enumerateTrees _ [] <span class="fu">=</span> []
enumerateTrees cmb xs <span class="fu">=</span> (extract <span class="fu">.</span> steps <span class="fu">.</span> initial) xs
  <span class="kw">where</span>
    step <span class="fu">=</span> map nodes <span class="fu">.</span> group

    steps [x] <span class="fu">=</span> x
    steps xs <span class="fu">=</span> steps (step xs)

    initial <span class="fu">=</span> map (<span class="dt">Leaf</span> <span class="dv">1</span> <span class="fu">.</span> flip <span class="dt">Rose.Node</span> [] <span class="fu">.</span> pure)

    extract (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> Rose.rootLabel x
    extract (<span class="dt">Node</span> [x]) <span class="fu">=</span> extract x

    group [_] <span class="fu">=</span> []
    group (<span class="dt">Leaf</span> _ x<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> [<span class="dt">Leaf</span> <span class="dv">2</span> [x, y] <span class="fu">|</span> <span class="dt">Leaf</span> _ y <span class="ot">&lt;-</span> vs] <span class="fu">:</span> group vs
    group (<span class="dt">Node</span>   u<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb (group u) vs) <span class="fu">:</span> group vs

    comb (<span class="dt">Leaf</span> n xs) (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> <span class="dt">Leaf</span> (n <span class="fu">+</span> <span class="dv">1</span>) (xs <span class="fu">++</span> [x])
    comb (<span class="dt">Node</span> us) (<span class="dt">Node</span> vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb us vs)

    forest ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []
      <span class="kw">where</span>
        f (<span class="dt">Rose.Node</span> x []) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) bw
        f (<span class="dt">Rose.Node</span> x us) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)

        b [] <span class="fu">=</span> []
        b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []

    nodes (<span class="dt">Leaf</span> n x) <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dv">1</span> (node n x)
    nodes (<span class="dt">Node</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (map nodes xs)

    node n ts <span class="fu">=</span> <span class="dt">Rose.Node</span> (walk (<span class="dv">2</span> <span class="fu">^</span> n <span class="fu">-</span> <span class="dv">2</span>) (forest ts) (const [])) ts
      <span class="kw">where</span>
        walk <span class="dv">0</span> xss k <span class="fu">=</span> k xss
        walk n (xs<span class="fu">:</span>xss) k <span class="fu">=</span>
            walk (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z
                                         <span class="fu">|</span> x <span class="ot">&lt;-</span> xs
                                         , y <span class="ot">&lt;-</span> ys
                                         , z <span class="ot">&lt;-</span> cmb x y
                                         ] <span class="fu">++</span> k yss)</code></pre></div>
<p></details></p>
<h2 id="using-it-for-countdown">Using it for Countdown</h2>
<p>The first thing to do for the Countdown solution is to figure out a representation for expressions. The one from simple-reflect is perfect for displaying the result, but we should memoize its calculation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Memoed</span>
  <span class="fu">=</span> <span class="dt">Memoed</span>
  {<span class="ot"> expr   ::</span> <span class="dt">Expr</span>
  ,<span class="ot"> result ::</span> <span class="dt">Int</span>
  }</code></pre></div>
<p>Then, some helpers for building:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Op</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Dif</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="fu">|</span> <span class="dt">Div</span>

binOp f g x y <span class="fu">=</span> <span class="dt">Memoed</span> ((f <span class="ot">`on`</span> expr) x y) ((g <span class="ot">`on`</span> result) x y)

<span class="ot">apply ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span>
apply <span class="dt">Add</span> x y <span class="fu">=</span> binOp (<span class="fu">+</span>) (<span class="fu">+</span>) x y
apply <span class="dt">Dif</span> x y
  <span class="fu">|</span> result y <span class="fu">&lt;</span> result x <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) x y
  <span class="fu">|</span> otherwise <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) y x
apply <span class="dt">Mul</span> x y <span class="fu">=</span> binOp (<span class="fu">*</span>) (<span class="fu">*</span>) x y
apply <span class="dt">Div</span> x y <span class="fu">=</span> binOp div div x y</code></pre></div>
<p>Finally, the full algorithm:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">enumerateExprs ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Memoed</span>]
enumerateExprs <span class="fu">=</span> enumerateTrees cmb <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="dt">Memoed</span> (fromIntegral x) x)
  <span class="kw">where</span>
    cmb x y <span class="fu">=</span>
        nubs <span class="fu">$</span>
        x <span class="fu">:</span>
        y <span class="fu">:</span>
        [ apply op x y
        <span class="fu">|</span> op <span class="ot">&lt;-</span> [<span class="dt">Add</span>, <span class="dt">Dif</span>, <span class="dt">Mul</span>, <span class="dt">Div</span>]
        , legal op (result x) (result y) ]
    legal <span class="dt">Add</span> _ _ <span class="fu">=</span> <span class="dt">True</span>
    legal <span class="dt">Dif</span> x y <span class="fu">=</span> x <span class="fu">/=</span> y
    legal <span class="dt">Mul</span> _ _ <span class="fu">=</span> <span class="dt">True</span>
    legal <span class="dt">Div</span> x y <span class="fu">=</span> x <span class="ot">`mod`</span> y <span class="fu">==</span> <span class="dv">0</span>
    nubs xs <span class="fu">=</span> foldr f (const []) xs IntSet.empty
      <span class="kw">where</span>
        f e a s
          <span class="fu">|</span> IntSet.member (result e) s <span class="fu">=</span> a s
          <span class="fu">|</span> otherwise <span class="fu">=</span> e <span class="fu">:</span> a (IntSet.insert (result e) s)

<span class="ot">countdown ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]
countdown targ <span class="fu">=</span> map expr <span class="fu">.</span> filter ((<span class="fu">==</span>) targ <span class="fu">.</span> result) <span class="fu">.</span> enumerateExprs

<span class="fu">&gt;&gt;&gt;</span> (mapM_ print <span class="fu">.</span> reduction <span class="fu">.</span> head) (countdown <span class="dv">586</span> [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>])
<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">75</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">76</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">76</span> <span class="fu">+</span> (<span class="dv">500</span> <span class="fu">+</span> <span class="dv">10</span>)
<span class="dv">76</span> <span class="fu">+</span> <span class="dv">510</span>
<span class="dv">586</span></code></pre></div>
<p>There are some optimizations going on here, taken mainly from <span class="citation">Bird and Mu (<a href="#ref-bird_countdown:_2005">2005</a>)</span>:</p>
<ol style="list-style-type: decimal">
<li>We filter out illegal operations, as described originally.</li>
<li>We filter out any expressions that have the same value.</li>
</ol>
<h2 id="testing-the-implementation">Testing the Implementation</h2>
<p>So we’ve followed the paper, written the code: time to test. The specification of the function is relatively simple: calculate all applications of the commutative operator to some input, <em>without</em> recalculating subtrees.</p>
<p>We’ll need a free structure for the “commutative operator”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Leaf</span> a
    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a
    <span class="kw">deriving</span> (<span class="dt">Foldable</span>,<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>)</code></pre></div>
<p>Here’s the problem: it’s not commutative! We can remedy it by only exporting a constructor that creates the tree in a commutative way, and we can make it a pattern synonym so it looks normal:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveFoldable  #-}</span>
<span class="ot">{-# LANGUAGE PatternSynonyms #-}</span>

<span class="kw">module</span> <span class="dt">Commutative</span>
  (<span class="dt">Tree</span>(<span class="dt">Leaf</span>)
  ,pattern (<span class="fu">:*:</span>))
  <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Leaf</span> a
    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a
    <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Foldable</span>)

pattern<span class="ot"> (:*:) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
pattern xs <span class="fu">:*:</span> ys <span class="ot">&lt;-</span> xs <span class="fu">:^:</span> ys <span class="kw">where</span>
  xs <span class="fu">:*:</span> ys
      <span class="fu">|</span> xs <span class="fu">&lt;=</span> ys <span class="fu">=</span> xs <span class="fu">:^:</span> ys
      <span class="fu">|</span> otherwise <span class="fu">=</span> ys <span class="fu">:^:</span> xs

<span class="ot">{-# COMPLETE Leaf, (:*:) #-}</span></code></pre></div>
<p>Now we need to check if all applications are actually tested. First, to generate all trees:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">allTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)
allTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)
allTrees xs <span class="fu">=</span> Set.unions (map (uncurry f) (unmerges xs))
  <span class="kw">where</span>
    f ls rs <span class="fu">=</span> Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> (Set.toList <span class="fu">.</span> allTrees)) ls rs)

<span class="ot">allSubTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)
allSubTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)
allSubTrees xs <span class="fu">=</span>
    Set.unions (map (uncurry f <span class="fu">.</span> (allSubTrees <span class="fu">***</span> allSubTrees)) (unmerges xs))
  <span class="kw">where</span>
    f ls rs <span class="fu">=</span>
        Set.unions
            [ls, rs, Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> Set.toList) ls rs)]</code></pre></div>
<p>Then, to test:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prop_exhaustiveSearch ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_exhaustiveSearch n <span class="fu">=</span>
         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]
             expect <span class="fu">=</span> allSubTrees src
             actual <span class="fu">=</span>
                 Set.fromList
                     (enumerateTrees
                          (\xs ys <span class="ot">-&gt;</span>
                                [xs, ys, xs <span class="fu">:*:</span> ys])
                          (map <span class="dt">Leaf</span> src))
         <span class="kw">in</span> expect <span class="fu">==</span> actual

<span class="ot">prop_exhaustiveSearchFull ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_exhaustiveSearchFull n <span class="fu">=</span>
         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]
             expect <span class="fu">=</span> Map.fromSet (const <span class="dv">1</span>) (allTrees src)
             actual <span class="fu">=</span>
                 freqs
                     (enumerateTrees
                          (\xs ys <span class="ot">-&gt;</span> [xs <span class="fu">:*:</span> ys])
                          (map <span class="dt">Leaf</span> src))
         <span class="kw">in</span> expect <span class="fu">==</span> actual</code></pre></div>
<p>Testing for repeated calls is more tricky. Remember, the memoization is supposed to be unobservable: in order to see it, we’re going to have to use some unsafe operations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">traceSubsequences
<span class="ot">    ::</span> ((<span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>]) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>])
    <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
    <span class="ot">-&gt;</span> (<span class="dt">Map</span> (<span class="dt">Tree</span> <span class="dt">Int</span>) <span class="dt">Int</span>, [<span class="dt">Tree</span> <span class="dt">Int</span>])
traceSubsequences enm ints <span class="fu">=</span>
    runST <span class="fu">$</span>
    <span class="kw">do</span> ref <span class="ot">&lt;-</span> newSTRef Map.empty
       <span class="kw">let</span> res <span class="fu">=</span> enm (combine ref) (map (conv ref) ints)
       traverse_ (foldr seq (pure ())) res
       intm <span class="ot">&lt;-</span> readSTRef ref
       pure (intm, res)
  <span class="kw">where</span>
    combine ref xs ys <span class="fu">=</span> unsafeRunST ([xs <span class="fu">:*:</span> ys] <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (xs <span class="fu">:*:</span> ys)))
    <span class="ot">{-# NOINLINE combine #-}</span>
    conv ref x <span class="fu">=</span> unsafeRunST (<span class="dt">Leaf</span> x <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (<span class="dt">Leaf</span> x)))
    <span class="ot">{-# NOINLINE conv #-}</span>
    unsafeRunST cmp <span class="fu">=</span> unsafePerformIO (unsafeSTToIO cmp)

<span class="ot">prop_noRepeatedCalls ::</span> <span class="dt">Property</span>
prop_noRepeatedCalls <span class="fu">=</span>
    property <span class="fu">$</span> sized <span class="fu">$</span>
    \n <span class="ot">-&gt;</span>
         pure <span class="fu">$</span>
         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> n]
             (tint,tres) <span class="fu">=</span> fmap freqs (traceSubsequences enumerateTrees src)
             (fint,fres) <span class="fu">=</span> fmap freqs (traceSubsequences dummyEnumerate src)
         <span class="kw">in</span> counterexample
                (mapCompare (freqs (allSubTrees src)) tint)
                (all (<span class="dv">1</span> <span class="fu">==</span>) tint) <span class="fu">.&amp;&amp;.</span>
            counterexample (mapCompare tres fres) (tres <span class="fu">==</span> fres) <span class="fu">.&amp;&amp;.</span>
            (n <span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">==&gt;</span> tint <span class="fu">/=</span> fint)</code></pre></div>
<p>Here, <code class="sourceCode haskell">dummyEnumerate</code> is some method which performs the same task, but <em>doesn’t</em> construct a nexus, so we can ensure that our tests really do catch faulty implementations.</p>
<div id="refs" class="references">
<div id="ref-bird_functional_2003">
<p>Bird, Richard, and Ralf Hinze. 2003. “Functional Pearl Trouble Shared is Trouble Halved.” In <em>Proceedings of the 2003 ACM SIGPLAN Workshop on Haskell</em>, 1–6. Haskell ’03. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/871895.871896">10.1145/871895.871896</a>. <a href="http://doi.acm.org/10.1145/871895.871896" class="uri">http://doi.acm.org/10.1145/871895.871896</a>.</p>
</div>
<div id="ref-bird_countdown:_2005">
<p>Bird, Richard, and Shin-Cheng Mu. 2005. “Countdown: A case study in origami programming.” <em>Journal of Functional Programming</em> 15 (05) (August): 679. doi:<a href="https://doi.org/10.1017/S0956796805005642">10.1017/S0956796805005642</a>. <a href="http://www.journals.cambridge.org/abstract_S0956796805005642" class="uri">http://www.journals.cambridge.org/abstract_S0956796805005642</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. “There and Back Again.” <em>BRICS Report Series</em> 12 (3). doi:<a href="https://doi.org/10.7146/brics.v12i3.21869">10.7146/brics.v12i3.21869</a>. <a href="https://tidsskrift.dk/brics/article/view/21869" class="uri">https://tidsskrift.dk/brics/article/view/21869</a>.</p>
</div>
<div id="ref-hutton_countdown_2002">
<p>Hutton, Graham. 2002. “The Countdown Problem.” <em>J. Funct. Program.</em> 12 (6) (November): 609–616. doi:<a href="https://doi.org/10.1017/S0956796801004300">10.1017/S0956796801004300</a>. <a href="http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf" class="uri">http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf</a>.</p>
</div>
<div id="ref-steffen_table_2006">
<p>Steffen, Peter, and Robert Giegerich. 2006. “Table Design in Dynamic Programming.” <em>Information and Computation</em> 204 (9) (September): 1325–1345. doi:<a href="https://doi.org/10.1016/j.ic.2006.02.006">10.1016/j.ic.2006.02.006</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-tobin_time_2016">
<p>Tobin, Jared. 2016. “Time Traveling Recursion Schemes.” <em>jtobin.io</em>. <a href="https://jtobin.io/time-traveling-recursion" class="uri">https://jtobin.io/time-traveling-recursion</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If you think that structure looks more like a funny linked list than a tree, that’s because it is. Instead of talking about “left” and “right” branches, we could talk about the first and second elements in a list: in fact, this is exactly what’s happening in the famous <code class="sourceCode haskell">zipWith</code> Fibonacci implementation (in reverse).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</code></pre></div>
<p>Or, in my favourite version:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fib n <span class="fu">=</span> fix ((<span class="fu">:</span>) <span class="dv">0</span> <span class="fu">.</span> scanl (<span class="fu">+</span>) <span class="dv">1</span>) <span class="fu">!!</span> n</code></pre></div>
<a href="#fnref1">↩</a></li>
</ol>
</div>
]]></description>
    <pubDate>Tue, 20 Mar 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-03-20-countdown.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Rose Trees, Breadth-First</title>
    <link>http://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Trees.html">Trees</a>
    
</div>

<p>In contrast to the more common binary trees, in a rose tree every node can have any number of children.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Node</span>
    {<span class="ot"> root   ::</span> a
    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a
    }

<span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</code></pre></div>
<p>One of the important manipulations of this data structure, which forms the basis for several other algorithms, is a breadth-first traversal. I’d like to go through a couple of techniques for implementing it, and how more generally you can often get away with using much simpler data structures if you really pinpoint the API you need from them.</p>
<p>As a general technique, <span class="citation">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span> advises that a queue be used:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">breadthFirst ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
breadthFirst tr <span class="fu">=</span> go (singleton tr)
  <span class="kw">where</span>
    go q <span class="fu">=</span> <span class="kw">case</span> pop q <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []
      <span class="dt">Just</span> (<span class="dt">Node</span> x xs,qs) <span class="ot">-&gt;</span> x <span class="fu">:</span> go (qs <span class="ot">`append`</span> xs)</code></pre></div>
<p>There are three functions left undefined there: <code class="sourceCode haskell">singleton</code>, <code class="sourceCode haskell">pop</code>, and <code class="sourceCode haskell">append</code>. They represent the API of our as-of-yet unimplemented queue, and their complexity will dictate the complexity of the overall algorithm. As a (bad) first choice, we could use simple lists, with the functions defined thus:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">singleton x <span class="fu">=</span> [x]
pop (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x,xs)
pop [] <span class="fu">=</span> <span class="dt">Nothing</span>
append <span class="fu">=</span> (<span class="fu">++</span>)</code></pre></div>
<p>Those repeated appends are bad news. The queue needs to be able to support popping from one side and appending from the other, which is something lists absolutely <em>cannot</em> do well.</p>
<p>We could swap in a more general queue implementation, possibly using Data.Sequence, or a pair of lists. But these are more complex and general than we need, so let’s try and pare down the requirements a little more.</p>
<p>First, we don’t need a pop: the go function can be expressed as a fold instead. Second, we don’t need <em>every</em> append to be immediately stuck into the queue, we can batch them, first appending to a structure that’s efficient for appends, and then converting that to a structure which is efficient for folds. In code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]
breadthFirst ts <span class="fu">=</span> foldr f b ts []
  <span class="kw">where</span>
    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)

    b [] <span class="fu">=</span> []
    b qs <span class="fu">=</span> foldl (foldr f) b qs []</code></pre></div>
<p>We’re consing instead of appending, but the consumption is being done in the correct direction anyway, because of the <code class="sourceCode haskell">foldl</code>.</p>
<h2 id="levels">Levels</h2>
<p>So next step: to get the <code class="sourceCode haskell">levels</code> function from Data.Tree. Instead of doing a breadth-first traversal, it returns the nodes at each <em>level</em> of the tree. Conceptually, every time we did the reverse above (called <code class="sourceCode haskell">foldl</code>), we will do a cons as well:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">levels ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [[a]]
levels ts <span class="fu">=</span> foldl f b ts [] []
  <span class="kw">where</span>
    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)

    b _ [] <span class="fu">=</span> []
    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</code></pre></div>
<h2 id="unfolding">Unfolding</h2>
<p>The original reason I started work on these problems was <a href="https://github.com/haskell/containers/issues/124">this</a> issue in containers. It concerns the <a href="https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#v:unfoldTreeM_BF"><code>unfoldTreeM_BF</code></a> function. An early go at rewriting it, inspired by levels above, looks like this:</p>
<div class="sourceCode"><table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)
unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (const id)
  <span class="kw">where</span>
    b [] k <span class="fu">=</span> pure (k [] [])
    b qs k <span class="fu">=</span> foldl (foldr t) b qs [] (\x <span class="ot">-&gt;</span> k [] <span class="fu">.</span> foldr (uncurry run) id x)

    t a fw bw k <span class="fu">=</span> <span class="kw">do</span>
        (x,cs) <span class="ot">&lt;-</span> f a
        <span class="kw">let</span> <span class="fu">!</span>n <span class="fu">=</span> length cs
        fw (cs <span class="fu">:</span> bw) (k <span class="fu">.</span> (<span class="fu">:</span>) (x, n))

    run x n xs ys <span class="fu">=</span>
      <span class="kw">case</span> splitAt n ys <span class="kw">of</span>
          (cs,zs) <span class="ot">-&gt;</span> <span class="dt">Node</span> x cs <span class="fu">:</span> xs zs</code></pre></td></tr></table></div>
<p>It basically performs the same this as the levels function, but builds the tree back up in the end using the <code class="sourceCode haskell">run</code> function. In order to do that, we store the length of each subforest on line 9, so that each node knows how much to take from each level.</p>
<p>A possible optimization is to stop taking the length. Anything in list processing that takes a length screams “wrong” to me (although it’s not always true!) so I often try to find a way to avoid it. The first option would be to keep the <code class="sourceCode haskell">cs</code> on line 8 around, and use <em>it</em> as an indicator for the length. That keeps it around longer than strictly necessary, though. The other option is to add a third level: for <code class="sourceCode haskell">breadthFirst</code> above, we had one level; for <code class="sourceCode haskell">levels</code>, we added another, to indicate the structure of the nodes and their subtrees; here, we can add a third, to maintain that structure when building back up:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)
unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (\ls <span class="ot">-&gt;</span> concat <span class="fu">.</span> ls)
  <span class="kw">where</span>
    b [] k <span class="fu">=</span> pure (k id [])
    b qs k <span class="fu">=</span> foldl g b qs [] (\ls <span class="ot">-&gt;</span> k id <span class="fu">.</span> ls)

    g a xs qs k <span class="fu">=</span> foldr t (\ls ys <span class="ot">-&gt;</span> a ys (k <span class="fu">.</span> run ls)) xs [] qs

    t a fw xs bw <span class="fu">=</span> f a <span class="fu">&gt;&gt;=</span> \(x,cs) <span class="ot">-&gt;</span> fw (x<span class="fu">:</span>xs) (cs<span class="fu">:</span>bw)

    run x xs <span class="fu">=</span> uncurry (<span class="fu">:</span>) <span class="fu">.</span> foldl go ((,) [] <span class="fu">.</span> xs) x
      <span class="kw">where</span>
        go ys y (z<span class="fu">:</span>zs) <span class="fu">=</span> (<span class="dt">Node</span> y z <span class="fu">:</span> ys&#39;, zs&#39;)
          <span class="kw">where</span>
            (ys&#39;,zs&#39;) <span class="fu">=</span> ys zs</code></pre></div>
<p>This unfortunately <em>slows down</em> the code.</p>
<div id="refs" class="references">
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. “Breadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.” In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131–136. ICFP ’00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>. <a href="https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf" class="uri">https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 17 Mar 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Single-Pass Huffman Coding</title>
    <link>http://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/folds.html">folds</a>
    
</div>

<p>While working on something else, I figured out a nice Haskell implementation of Huffman coding, and I thought I’d share it here. I’ll go through a few techniques for transforming a multi-pass algorithm into a single-pass one first, and then I’ll show how to use them for Huffman. If you just want to skip to the code, it’s provided at the end.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>The algorithm isn’t single-pass in the sense of <a href="https://www2.cs.duke.edu/csed/curious/compression/adaptivehuff.html">Adaptive Huffman Coding</a>: it still uses the normal Huffman algorithm, but the input is transformed in the same traversal that builds the tree to transform it.</p>
<h2 id="circular-programming">Circular Programming</h2>
<p>There are several techniques for turning multi-pass algorithms into single-pass ones in functional languages. Perhaps the most famous is circular programming: using <em>laziness</em> to eliminate a pass. <span class="citation">R. S. Bird (<a href="#ref-bird_using_1984">1984</a>)</span> used this to great effect in solving the repmin problem:</p>
<blockquote>
<p>Given a tree of integers, replace every integer with the minimum integer in the tree, in one pass.</p>
</blockquote>
<p>For an imperative programmer, the problem is relatively easy: first, write the code to find the minimum value in the tree in the standard way, using a loop and a “smallest so far” accumulator. Then, inside the loop, after updating the accumulator, set the value of the leaf to be a <em>reference</em> to the accumulator.</p>
<p>At first, that solution may seem necessarily impure: we’re using global, mutable state to update many things at once. However, as the paper shows, we can claw back purity using laziness:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a

<span class="ot">repMin ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Integer</span>
repMin xs <span class="fu">=</span> ys <span class="kw">where</span>
  (m, ys) <span class="fu">=</span> go xs
  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (x, <span class="dt">Leaf</span> m)
  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (min x y, xs&#39; <span class="fu">:*:</span> ys&#39;)
    <span class="kw">where</span>
      (x,xs&#39;) <span class="fu">=</span> go xs
      (y,ys&#39;) <span class="fu">=</span> go ys</code></pre></div>
<h2 id="there-and-back-again">There and Back Again</h2>
<p>Let’s say we don’t have laziness at our disposal: are we hosed? No!<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <span class="citation">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> explore this very issue, by posing the question:</p>
<blockquote>
<p>Given two lists, xs and ys, can you zip xs with the reverse of ys in one pass?</p>
</blockquote>
<p>The technique used to solve the problem is named “There and Back Again”; it should be clear why from one of the solutions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">convolve xs ys <span class="fu">=</span> walk xs const <span class="kw">where</span>
  walk [] k <span class="fu">=</span> k [] ys
  walk (x<span class="fu">:</span>xs) k <span class="fu">=</span> walk xs (\r (y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> k ((x,y) <span class="fu">:</span> r) ys)</code></pre></div>
<p>The traversal of one list builds up the function to consume the other. We could write repmin in the same way:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">repMin <span class="fu">=</span> uncurry (<span class="fu">$</span>) <span class="fu">.</span> go <span class="kw">where</span>
  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (<span class="dt">Leaf</span>, x)
  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (\m <span class="ot">-&gt;</span> xs&#39; m <span class="fu">:*:</span> ys&#39; m, min xm ym) <span class="kw">where</span>
    (xs&#39;,xm) <span class="fu">=</span> go xs
    (ys&#39;,ym) <span class="fu">=</span> go ys</code></pre></div>
<h2 id="cayley-representations">Cayley Representations</h2>
<p>If you’re doing a lot of appending to some list-like structure, you probably don’t want to use actual lists: you’ll end up traversing the left-hand-side of the append many more times than necessary. A type you can drop in to use instead is difference lists <span class="citation">(Hughes <a href="#ref-hughes_novel_1986">1986</a>)</span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DList</span> a <span class="fu">=</span> [a] <span class="ot">-&gt;</span> [a]

<span class="ot">rep ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">DList</span> a
rep <span class="fu">=</span> (<span class="fu">++</span>)

abs<span class="ot"> ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> [a]
abs xs <span class="fu">=</span> xs []

<span class="ot">append ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a
append <span class="fu">=</span> (<span class="fu">.</span>)</code></pre></div>
<p><code class="sourceCode haskell">append</code> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> in this representation. In fact, for any monoid with a slow <code class="sourceCode haskell">mappend</code>, you can use the same trick: it’s called the Cayley representation, and available as <code class="sourceCode haskell"><span class="dt">Endo</span></code> in <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:Endo">Data.Monoid</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rep ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> a
rep x <span class="fu">=</span> <span class="dt">Endo</span> (mappend x)

abs<span class="ot"> ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> a <span class="ot">-&gt;</span> a
abs (<span class="dt">Endo</span> f) <span class="fu">=</span> f mempty

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Endo</span> id
  mappend (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="fu">=</span> <span class="dt">Enfo</span> (f <span class="fu">.</span> g)</code></pre></div>
<p>You can actually do the same transformation for “monoids” in the categorical sense: applying it to monads, for instance, will give you codensity <span class="citation">(Rivas and Jaskelioff <a href="#ref-rivas_notions_2014">2014</a>)</span>.</p>
<h2 id="traversable">Traversable</h2>
<p>Looking back—just for a second—to the repmin example, we should be able to spot a pattern we can generalize. There’s really nothing tree-specific about it, so why can’t we apply it to lists? Or other structures, for that matter? It turns out we can: the <code class="sourceCode haskell">mapAccumL</code> function is tailor-made to this need:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">repMin ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> t <span class="dt">Integer</span> <span class="ot">-&gt;</span> t <span class="dt">Integer</span>
repMin xs <span class="fu">=</span> ys <span class="kw">where</span>
  (<span class="fu">~</span>(<span class="dt">Just</span> m), ys) <span class="fu">=</span> mapAccumL f <span class="dt">Nothing</span> xs
  f <span class="dt">Nothing</span> x <span class="fu">=</span> (<span class="dt">Just</span> x, m)
  f (<span class="dt">Just</span> y) x <span class="fu">=</span> (<span class="dt">Just</span> (min x y), m)</code></pre></div>
<p>The tilde before the <code class="sourceCode haskell"><span class="dt">Just</span></code> ensures this won’t fail on empty input.</p>
<h1 id="huffman-coding">Huffman Coding</h1>
<p>Finally, it’s time for the main event. Huffman coding is a <em>very</em> multi-pass algorithm, usually. The steps look like this:</p>
<ol style="list-style-type: decimal">
<li>Build a frequency table for each character in the input.</li>
<li>Build a priority queue from that frequency table.</li>
<li>Iteratively pop elements and combine them (into Huffman trees) from the queue until there’s only one left.</li>
<li>That Huffman tree can be used to construct the mapping from items back to their Huffman codes.</li>
<li>Traverse the input again, using the constructed mapping to replace elements with their codes.</li>
</ol>
<p>We can’t <em>skip</em> any of these steps: we can try perform them all at once, though.</p>
<p>Let’s write the multi-pass version first. We’ll need the frequency table:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">frequencies ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span>
frequencies <span class="fu">=</span> Map.fromListWith (<span class="fu">+</span>) <span class="fu">.</span> map (flip (,) <span class="dv">1</span>)</code></pre></div>
<p>And a heap, ordered on the frequencies of its elements (I’m using a skew heap here):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Heap</span> a
  <span class="fu">=</span> <span class="dt">Nil</span>
  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span>
  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys
  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs
  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)
    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx
    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly
  mempty <span class="fu">=</span> <span class="dt">Nil</span></code></pre></div>
<p>Next, we need to build the tree<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. We can use the tree type from above.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">buildTree ::</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a)
buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span>
  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k) <span class="dt">Nil</span> <span class="dt">Nil</span>)
  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span>
    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x
    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span>
      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (x <span class="fu">:*:</span> y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</code></pre></div>
<p>Then, a way to convert between the tree and a map:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]
toMapping (<span class="dt">Leaf</span> x) <span class="fu">=</span> Map.singleton x []
toMapping (xs <span class="fu">:*:</span> ys) <span class="fu">=</span>
    Map.union (fmap (<span class="dt">True</span><span class="fu">:</span>) (toMapping xs)) (fmap (<span class="dt">False</span><span class="fu">:</span>) (toMapping ys))</code></pre></div>
<p>And finally, putting the whole thing together:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">huffman ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), [[<span class="dt">Bool</span>]])
huffman xs <span class="fu">=</span> (tree, map (mapb <span class="fu">Map.!</span>) xs) <span class="kw">where</span>
  freq <span class="fu">=</span> frequencies xs
  tree <span class="fu">=</span> buildTree freq
  mapb <span class="fu">=</span> maybe Map.empty toMapping tree</code></pre></div>
<h2 id="removing-the-passes">Removing the passes</h2>
<p>The first thing to fix is the <code class="sourceCode haskell">toMapping</code> function: at every level, it calls <code class="sourceCode haskell">union</code>, a complex and expensive operation. However, <code class="sourceCode haskell">union</code> and <code class="sourceCode haskell">empty</code> form a monoid, so we can use the Cayley representation to reduce the calls to a minimum. Next, we want to get rid of the <code class="sourceCode haskell">fmap</code>s: we can do that by assembling a function to perform the <code class="sourceCode haskell">fmap</code> as we go, as in <code class="sourceCode haskell">convolve</code><a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]
toMapping tree <span class="fu">=</span> go tree id Map.empty <span class="kw">where</span>
  go (<span class="dt">Leaf</span> x) k <span class="fu">=</span> Map.insert x (k [])
  go (xs <span class="fu">:*:</span> ys) k <span class="fu">=</span>
    go xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> go ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</code></pre></div>
<p>Secondly, we can integrate the <code class="sourceCode haskell">toMapping</code> function with the <code class="sourceCode haskell">buildTree</code> function, removing another pass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])
buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span>
  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)
  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span>
    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)
    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span>
      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))
  leaf x k <span class="fu">=</span> Map.insert x (k [])
  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)
  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)</code></pre></div>
<p>Finally, to remove the second pass over the list, we can copy repmin, using <code class="sourceCode haskell">mapAccumL</code> to both construct the mapping and apply it to the structure in one go.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])
huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span>
  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs
  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)
  tree <span class="fu">=</span> buildTree freq
  mapb <span class="fu">=</span> maybe Map.empty snd tree</code></pre></div>
<p>And that’s it!</p>
<h1 id="generalization">Generalization</h1>
<p>The similarity between the repmin function and the solution above is suggestive: is there a way to <em>encode</em> this idea of making a multi-pass algorithm single-pass? Of course! We can use an applicative:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Circular</span> a b c <span class="fu">=</span>
    <span class="dt">Circular</span> <span class="fu">!</span>a
             (b <span class="ot">-&gt;</span> c)

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span>
    fmap f (<span class="dt">Circular</span> tally run) <span class="fu">=</span> <span class="dt">Circular</span> tally (f <span class="fu">.</span> run)

<span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span>
         <span class="dt">Applicative</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span>
    pure x <span class="fu">=</span> <span class="dt">Circular</span> mempty (const x)
    <span class="dt">Circular</span> fl fr <span class="fu">&lt;*&gt;</span> <span class="dt">Circular</span> xl xr <span class="fu">=</span>
        <span class="dt">Circular</span>
            (mappend fl xl)
            (\r <span class="ot">-&gt;</span> fr r (xr r))

liftHuffman
<span class="ot">    ::</span> <span class="dt">Ord</span> a
    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) [<span class="dt">Bool</span>]
liftHuffman x <span class="fu">=</span> <span class="dt">Circular</span> (Map.singleton x <span class="dv">1</span>) (<span class="fu">Map.!</span> x)

runHuffman
<span class="ot">    ::</span> <span class="dt">Ord</span> a
    <span class="ot">=&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) r <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), r)
runHuffman (<span class="dt">Circular</span> smry run) <span class="fu">=</span>
    maybe (<span class="dt">Nothing</span>, run Map.empty) (<span class="dt">Just</span> <span class="fu">***</span> run) (buildTree smry)

huffman
<span class="ot">    ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t)
    <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])
huffman <span class="fu">=</span> runHuffman <span class="fu">.</span> traverse liftHuffman</code></pre></div>
<p>Thanks to it being an applicative, you can do all the fun lensy things with it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showBin ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">String</span>
showBin <span class="fu">=</span> map (bool <span class="ch">&#39;0&#39;</span> <span class="ch">&#39;1&#39;</span>)

<span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> liftBin <span class="fu">=</span> fmap showBin <span class="fu">.</span> liftHuffman
<span class="fu">&gt;&gt;&gt;</span> (snd <span class="fu">.</span> runHuffman <span class="fu">.</span> (each<span class="fu">.</span>traverse) liftBin) (<span class="st">&quot;abb&quot;</span>, <span class="st">&quot;cad&quot;</span>, <span class="st">&quot;c&quot;</span>)
([<span class="st">&quot;01&quot;</span>,<span class="st">&quot;11&quot;</span>,<span class="st">&quot;11&quot;</span>],[<span class="st">&quot;00&quot;</span>,<span class="st">&quot;01&quot;</span>,<span class="st">&quot;10&quot;</span>],[<span class="st">&quot;00&quot;</span>])</code></pre></div>
<p>Bringing us back to the start, it can also let us solve repmin!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftRepMin ::</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a a
liftRepMin x <span class="fu">=</span> <span class="dt">Circular</span> (pure (pure x)) id

<span class="ot">runRepMin ::</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a b <span class="ot">-&gt;</span> b
runRepMin (<span class="dt">Circular</span> m r) <span class="fu">=</span> r (<span class="kw">case</span> m <span class="kw">of</span>
  <span class="dt">Option</span> (<span class="dt">Just</span> (<span class="dt">Min</span> x)) <span class="ot">-&gt;</span> x)

<span class="ot">repMin ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a
repMin <span class="fu">=</span> runRepMin <span class="fu">.</span> traverse liftRepMin</code></pre></div>
<h1 id="related">Related</h1>
<p>So the <code class="sourceCode haskell"><span class="dt">Circular</span></code> type is actually just the product of reader and writer, and is closely related to the <a href="https://github.com/treeowl/sort-traversable">sort</a> type.</p>
<p>It’s also related to the <a href="https://www.reddit.com/r/haskell/comments/7qwzn4/an_update_about_the_store_monad_and_state_comonad/"><code class="sourceCode haskell"><span class="dt">Prescient</span></code></a> type, which I noticed after I’d written the above.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bird_using_1984">
<p>Bird, R. S. 1984. “Using Circular Programs to Eliminate Multiple Traversals of Data.” <em>Acta Inf.</em> 21 (3) (October): 239–250. doi:<a href="https://doi.org/10.1007/BF00264249">10.1007/BF00264249</a>. <a href="http://dx.doi.org/10.1007/BF00264249" class="uri">http://dx.doi.org/10.1007/BF00264249</a>.</p>
</div>
<div id="ref-bird_more_1997">
<p>Bird, Richard, Geraint Jones, and Oege De Moor. 1997. “More haste‚ less speed: Lazy versus eager evaluation.” <em>Journal of Functional Programming</em> 7 (5) (September): 541–547. doi:<a href="https://doi.org/10.1017/S0956796897002827">10.1017/S0956796897002827</a>. <a href="https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01" class="uri">https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. “There and Back Again.” <a href="http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf" class="uri">http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf</a>.</p>
</div>
<div id="ref-hughes_novel_1986">
<p>Hughes, R. John Muir. 1986. “A Novel Representation of Lists and Its Application to the Function ‘Reverse’.” <em>Information Processing Letters</em> 22 (3) (March): 141–144. doi:<a href="https://doi.org/10.1016/0020-0190(86)90059-1">10.1016/0020-0190(86)90059-1</a>. <a href="http://www.sciencedirect.com/science/article/pii/0020019086900591" class="uri">http://www.sciencedirect.com/science/article/pii/0020019086900591</a>.</p>
</div>
<div id="ref-pippenger_pure_1997">
<p>Pippenger, Nicholas. 1997. “Pure Versus Impure Lisp.” <em>ACM Trans. Program. Lang. Syst.</em> 19 (2) (March): 223–238. doi:<a href="https://doi.org/10.1145/244795.244798">10.1145/244795.244798</a>. <a href="http://doi.acm.org/10.1145/244795.244798" class="uri">http://doi.acm.org/10.1145/244795.244798</a>.</p>
</div>
<div id="ref-rivas_notions_2014">
<p>Rivas, Exequiel, and Mauro Jaskelioff. 2014. “Notions of Computation as Monoids.” <em>arXiv:1406.4823 [cs, math]</em> (May). <a href="http://arxiv.org/abs/1406.4823" class="uri">http://arxiv.org/abs/1406.4823</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Huffman coding single-pass implementation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Data.Map.Strict</span>  (<span class="dt">Map</span>)
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span>  <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import           </span><span class="dt">Data.Traversable</span> (mapAccumL)

<span class="kw">data</span> <span class="dt">Heap</span> a
  <span class="fu">=</span> <span class="dt">Nil</span>
  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span>
  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys
  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs
  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)
    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx
    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly
  mempty <span class="fu">=</span> <span class="dt">Nil</span>

<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a

<span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])
buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span>
  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)
  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span>
    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)
    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span>
      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))
  leaf x k <span class="fu">=</span> Map.insert x (k [])
  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)
  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)

<span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])
huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span>
  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs
  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)
  tree <span class="fu">=</span> buildTree freq
  mapb <span class="fu">=</span> maybe Map.empty snd tree</code></pre></div>
<a href="#fnref1">↩</a></li>
<li id="fn2"><p>Well, that’s a little bit of a lie. In terms of asympostics, <span class="citation">Pippenger (<a href="#ref-pippenger_pure_1997">1997</a>)</span> stated a problem that could be solved in linear time in impure Lisp, but <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Omega(n \log n)</annotation></semantics></math> in pure Lisp. <span class="citation">R. Bird, Jones, and Moor (<a href="#ref-bird_more_1997">1997</a>)</span> then produced an algorithm that could solve the problem in linear time, by using laziness. So, in some cases, laziness will give you asymptotics you can’t get without it (if you want to stay pure).<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>There’s actually a nicer version of the <code class="sourceCode haskell">buildTree</code> function which uses <code class="sourceCode haskell"><span class="dt">StateT</span> (<span class="dt">Heap</span> a) <span class="dt">Maybe</span></code>, but it’s equivalent to this one under the hood, and I though might be a little distracting.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Something to notice about this function is that it’s going top-down and bottom-up at the same time. Combining the maps (with <code class="sourceCode haskell">(<span class="fu">.</span>)</code>) is done bottom-up, but building the codes is top-down. This means the codes are built in reverse order! That’s why the accumulating parameter (<code class="sourceCode haskell">k</code>) is a difference list, rather than a normal list. As it happens, if normal lists were used, the function would be slightly more efficient through sharing, but the codes would all be reversed.<a href="#fnref4">↩</a></p></li>
</ol>
</div>
]]></description>
    <pubDate>Sat, 17 Feb 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Monadic List Functions</title>
    <link>http://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 11, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/applicative.html">applicative</a>
    
</div>

<p>Here’s an old Haskell chestnut:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
[[],[<span class="dv">3</span>],[<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</code></pre></div>
<p><code class="sourceCode haskell">filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>])</code> gives the power set of some input list. It’s one of the especially magical demonstrations of monads. From a high-level perspective, it makes sense: for each element in the list, we want it to be present in one output, and not present in another. It’s hard to see how it actually <em>works</em>, though. The (old<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>) <a href="https://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#filterM">source</a> for <code class="sourceCode haskell">filterM</code> doesn’t help hugely, either:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">filterM          ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]
filterM _ []     <span class="fu">=</span>  return []
filterM p (x<span class="fu">:</span>xs) <span class="fu">=</span>  <span class="kw">do</span>
   flg <span class="ot">&lt;-</span> p x
   ys  <span class="ot">&lt;-</span> filterM p xs
   return (<span class="kw">if</span> flg <span class="kw">then</span> x<span class="fu">:</span>ys <span class="kw">else</span> ys)</code></pre></div>
<p>Again, elegant and beautiful (aside from the three-space indent), but opaque. Despite not really getting how it works, I was encouraged by its simplicity to try my hand at some of the other functions from Data.List.</p>
<h2 id="grouping">Grouping</h2>
<p>Let’s start with the subject of my <a href="2018-01-07-groupBy.html">last post</a>. Here’s the implementation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]
groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span>
  <span class="kw">let</span> f x a q
        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)
        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)
        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)
  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))</code></pre></div>
<p>It translates over pretty readily:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">groupByM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [[a]]
groupByM p xs <span class="fu">=</span>
  fmap snd (foldr f (const (pure ([], []))) xs (const (pure (<span class="dt">False</span>))))
  <span class="kw">where</span>
    f x a q <span class="fu">=</span> liftA2 st (q x) (a (p x)) <span class="kw">where</span>
      st b (ys,zs)
        <span class="fu">|</span> b <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)
        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], (x<span class="fu">:</span>ys)<span class="fu">:</span>zs)</code></pre></div>
<p>Let’s try it with a similar example to <code class="sourceCode haskell">filterM</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> groupByM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
[[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]]</code></pre></div>
<p>It gives the partitions of the list!</p>
<h2 id="sorting">Sorting</h2>
<p>So these monadic generalisations have been discovered before, several times over. There’s even a <a href="https://hackage.haskell.org/package/monadlist-0.0.2">package</a> with monadic versions of the functions in Data.List. Exploring this idea with a little more formality is the paper “All Sorts of Permutations” <span class="citation">(Christiansen, Danilenko, and Dylus <a href="#ref-christiansen_all_2016">2016</a>)</span>, and accompanying presentation <a href="https://www.youtube.com/watch?v=vV3jqTxJ9Wc">on YouTube</a>. They show that the monadic version of sort produces permutations of the input list, and examine the output from different sorting algorithms. Here’s a couple of their implementations, altered slightly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]
insertM _ x [] <span class="fu">=</span> pure [x]
insertM p x yys<span class="fu">@</span>(y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">do</span>
  lte <span class="ot">&lt;-</span> p x y
  <span class="kw">if</span> lte
    <span class="kw">then</span> pure (x<span class="fu">:</span>yys)
    <span class="kw">else</span> fmap (y<span class="fu">:</span>) (insertM p x ys)

<span class="ot">insertSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]
insertSortM p <span class="fu">=</span> foldrM (insertM p) []

<span class="ot">partitionM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m ([a],[a])
partitionM p <span class="fu">=</span> foldr f (pure ([],[])) <span class="kw">where</span>
  f x <span class="fu">=</span> liftA2 ifStmt (p x) <span class="kw">where</span>
    ifStmt flg (tr,fl)
      <span class="fu">|</span> flg <span class="fu">=</span> (x<span class="fu">:</span>tr,fl)
      <span class="fu">|</span> otherwise <span class="fu">=</span> (tr,x<span class="fu">:</span>fl)
      
<span class="ot">quickSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]
quickSortM p [] <span class="fu">=</span> pure []
quickSortM p (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span>
  (gt,le) <span class="ot">&lt;-</span> partitionM (p x) xs
  ls <span class="ot">&lt;-</span> quickSortM p le
  gs <span class="ot">&lt;-</span> quickSortM p gt
  pure (ls <span class="fu">++</span> [x] <span class="fu">++</span> gs)

<span class="fu">&gt;&gt;&gt;</span> insertSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]]

<span class="fu">&gt;&gt;&gt;</span> quickSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
[[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</code></pre></div>
<p>As it should be easy to see, they’re very concise and elegant, and strongly resemble the pure versions of the algorithms.</p>
<h2 id="state"> State</h2>
<p>So the examples above are very interesting and cool, but they don’t necessarily have a place in real Haskell code. If you wanted to find the permutations, partitions, or power set of a list you’d probably use a more standard implementation. That’s not to say that these monadic functions have no uses, though: especially when coupled with <code class="sourceCode haskell"><span class="dt">State</span></code> they yield readable and fast implementations for certain tricky functions. <code class="sourceCode haskell">ordNub</code>, for instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ordNub ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
ordNub <span class="fu">=</span>
  flip evalState Set.empty <span class="fu">.</span>
  filterM
    (\x <span class="ot">-&gt;</span> <span class="kw">do</span>
       flg <span class="ot">&lt;-</span> gets (Set.notMember x)
       when flg (modify (Set.insert x))
       pure flg)</code></pre></div>
<p>Alternatively, using a monadic version of <code class="sourceCode haskell">maximumOn</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">maximumOnM ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Ord</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> a)
maximumOnM p <span class="fu">=</span> (fmap <span class="fu">.</span> fmap) snd <span class="fu">.</span> foldl f (pure <span class="dt">Nothing</span>)
  <span class="kw">where</span>
    f a e <span class="fu">=</span> liftA2 g a (p e)
      <span class="kw">where</span>
        g <span class="dt">Nothing</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)
        g b<span class="fu">@</span>(<span class="dt">Just</span> (o, y)) q
          <span class="fu">|</span> o <span class="fu">&lt;</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)
          <span class="fu">|</span> otherwise <span class="fu">=</span> b</code></pre></div>
<p>You can write a one-pass <code class="sourceCode haskell">mostFrequent</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mostFrequent ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
mostFrequent <span class="fu">=</span>
  flip evalState Map.empty <span class="fu">.</span>
  maximumOnM
    (\x <span class="ot">-&gt;</span> maybe <span class="dv">1</span> succ <span class="fu">&lt;$&gt;</span> state (Map.insertLookupWithKey (const (<span class="fu">+</span>)) x <span class="dv">1</span>))</code></pre></div>
<h2 id="decision-trees">Decision Trees</h2>
<p>One of the nicest things about the paper was the diagrams of decision trees provided for each sorting algorithm. I couldn’t find a library to do that for me, so I had a go at producing my own. First, we’ll need a data type to represent the tree itself:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DecTree</span> t a
  <span class="fu">=</span> <span class="dt">Pure</span> a
  <span class="fu">|</span> <span class="dt">Choice</span> t (<span class="dt">DecTree</span> t a) (<span class="dt">DecTree</span> t a)
  <span class="kw">deriving</span> <span class="dt">Functor</span></code></pre></div>
<p>We’ll say the left branch is “true” and the right “false”. Applicative and monad instances are relatively mechanical<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Pure</span>
  <span class="dt">Pure</span> f <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fmap f xs
  <span class="dt">Choice</span> c ls rs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&lt;*&gt;</span> xs) (rs <span class="fu">&lt;*&gt;</span> xs)
  
<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span>
  <span class="dt">Pure</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x
  <span class="dt">Choice</span> c ls rs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&gt;&gt;=</span> f) (rs <span class="fu">&gt;&gt;=</span> f)</code></pre></div>
<p>We can now create a comparator function that constructs one of these trees, and remembers the values it was given:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traceCompare ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) <span class="dt">Bool</span>
traceCompare x y <span class="fu">=</span> <span class="dt">Choice</span> (x,y) (<span class="dt">Pure</span> <span class="dt">True</span>) (<span class="dt">Pure</span> <span class="dt">False</span>)</code></pre></div>
<p>Finally, to draw the tree, I’ll use a function from my <a href="https://github.com/oisdk/binary-tree">binary tree</a> library:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">printDecTree ::</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
printDecTree rel t <span class="fu">=</span> putStr (drawTreeWith id (go t) <span class="st">&quot;&quot;</span>) <span class="kw">where</span>
  go (<span class="dt">Pure</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (show xs) <span class="dt">Leaf</span> <span class="dt">Leaf</span>
  go (<span class="dt">Choice</span> (x,y) tr fl) <span class="fu">=</span>
    <span class="dt">Node</span> (show x <span class="fu">++</span> rel <span class="fu">++</span> show y) (go tr) (go fl)</code></pre></div>
<p>And we get these really nice diagrams out:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> insertSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

         ┌[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
    ┌<span class="dv">1</span><span class="fu">&lt;=</span><span class="dv">2</span>┤
    │    │    ┌[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]
    │    └<span class="dv">1</span><span class="fu">&lt;=</span><span class="dv">3</span>┤
    │         └[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]
<span class="dv">2</span><span class="fu">&lt;=</span><span class="dv">3</span>┤
    │    ┌[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]
    └<span class="dv">1</span><span class="fu">&lt;=</span><span class="dv">3</span>┤
         │    ┌[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]
         └<span class="dv">1</span><span class="fu">&lt;=</span><span class="dv">2</span>┤
              └[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]

<span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> quickSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

              ┌[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
         ┌<span class="dv">2</span><span class="fu">&lt;=</span><span class="dv">3</span>┤
         │    └[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]
    ┌<span class="dv">1</span><span class="fu">&lt;=</span><span class="dv">3</span>┤
    │    └[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]
<span class="dv">1</span><span class="fu">&lt;=</span><span class="dv">2</span>┤
    │    ┌[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]
    └<span class="dv">1</span><span class="fu">&lt;=</span><span class="dv">3</span>┤
         │    ┌[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]
         └<span class="dv">2</span><span class="fu">&lt;=</span><span class="dv">3</span>┤
              └[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</code></pre></div>
<p>We can also try it out with the other monadic list functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;=&quot;</span> <span class="fu">.</span> groupByM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

       ┌[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]
   ┌<span class="dv">2</span><span class="fu">=</span><span class="dv">3</span>┤
   │   └[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]]
<span class="dv">1</span><span class="fu">=</span><span class="dv">2</span>┤
   │   ┌[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]]
   └<span class="dv">2</span><span class="fu">=</span><span class="dv">3</span>┤
       └[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]]</code></pre></div>
<h2 id="applicative"> Applicative</h2>
<p>You might notice that none of these “monadic” functions actually require a monad constraint: they’re all applicative. There’s a straightforward implementation that relies only on applicative for most of these functions, with a notable exception: sort. Getting <em>that</em> to work with just applicative is the subject of a future post.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-christiansen_all_2016">
<p>Christiansen, Jan, Nikita Danilenko, and Sandra Dylus. 2016. “All Sorts of Permutations (Functional Pearl).” In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 168–179. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951949">10.1145/2951913.2951949</a>. <a href="http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf" class="uri">http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The definition has since been <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Control.Monad.html#filterM">updated</a> to more modern Haskell: it now uses a fold, and only requires <code class="sourceCode haskell"><span class="dt">Applicative</span></code>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Part of the reason the instances are so mechanical is that this type strongly resembles the <a href="https://hackage.haskell.org/package/free-5/docs/Control-Monad-Free.html#t:Free">free monad</a>:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="fu">=</span> <span class="dt">Pure</span> a <span class="fu">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))</code></p>
<p>In fact, the example given in the <code class="sourceCode haskell"><span class="dt">MonadFree</span></code> class is the following:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span> <span class="dt">Pair</span> a a</code></p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Pair</span></code></p>
<p>The only difference with the above type and the decision tree is that the decision tree carries a tag with it.</p>
<p>So what’s so interesting about this relationship? Well, <code class="sourceCode haskell"><span class="dt">Pair</span></code> is actually a <a href="https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Rep.html">representable functor</a>. Any representable functor <code class="sourceCode haskell">f a</code> can be converted to (and from) a function <code class="sourceCode haskell">key <span class="ot">-&gt;</span> a</code>, where <code class="sourceCode haskell">key</code> is the specific key for <code class="sourceCode haskell">f</code>. The key for <code class="sourceCode haskell"><span class="dt">Pair</span></code> is <code class="sourceCode haskell"><span class="dt">Bool</span></code>: the result of the function we passed in to the sorting functions!</p>
<p>In general, you can make a “decision tree” for any function of type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> b</code> like so:</p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DecTree</span> a b r <span class="fu">=</span> <span class="dt">Rep</span> f <span class="fu">~</span> b <span class="ot">=&gt;</span> <span class="dt">Free</span> (<span class="dt">Compose</span> ((,) a) f) r</code></p>
<p>But more on that in a later post.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></description>
    <pubDate>Sun, 11 Feb 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>groupBy</title>
    <link>http://doisinkidney.com/posts/2018-01-07-groupBy.html</link>
    <description><![CDATA[<div class="info">
    Posted on January  7, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>Here’s a useful function from <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-List.html#v:groupBy">Data.List</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]

groupBy (<span class="fu">==</span>) <span class="st">&quot;aabcdda&quot;</span>
<span class="co">-- [&quot;aa&quot;,&quot;b&quot;,&quot;c&quot;,&quot;dd&quot;,&quot;a&quot;]</span></code></pre></div>
<p>However, as has been pointed out before<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, <code class="sourceCode haskell">groupBy</code> expects an equivalence relation, and can exhibit surprising behavior when it doesn’t get one. Let’s say, for instance, that we wanted to group numbers that were close together:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">groupClose ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [[<span class="dt">Integer</span>]]
groupClose <span class="fu">=</span> groupBy (\x y <span class="ot">-&gt;</span> abs (x <span class="fu">-</span> y) <span class="fu">&lt;</span> <span class="dv">3</span>)</code></pre></div>
<p>What would you expect on the list <code>[1, 2, 3, 4, 5]</code>? All in the same group? Well, what you actually get is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>]]</code></pre></div>
<p>This is because the implementation of <code class="sourceCode haskell">groupBy</code> only compares to the first element in each group:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">groupBy _  []           <span class="fu">=</span>  []
groupBy eq (x<span class="fu">:</span>xs)       <span class="fu">=</span>  (x<span class="fu">:</span>ys) <span class="fu">:</span> groupBy eq zs
                           <span class="kw">where</span> (ys,zs) <span class="fu">=</span> span (eq x) xs</code></pre></div>
<p>Brandon Simmons gave a <a href="http://brandon.si/code/an-alternative-definition-for-datalistgroupby/">definition</a> of <code class="sourceCode haskell">groupBy</code> that is perhaps more useful, but it used explicit recursion, rather than a fold.</p>
<p>A definition with <code class="sourceCode haskell">foldr</code> turned out to be trickier than I expected. I found some of the laziness properties especially difficult:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> head (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))
[<span class="dv">1</span>]
<span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span>undefined))
<span class="dv">1</span>
<span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head <span class="fu">.</span> tail) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))
<span class="dv">2</span></code></pre></div>
<p>Here’s the definition I came up with, after some deliberation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]
groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span>
  <span class="kw">let</span> f x a q
        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)
        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)
        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)
  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))
<span class="ot">{-# INLINE groupBy #-}</span></code></pre></div>
<p>Seemingly benign changes to the function will break one or more of the above tests. In particular, the laziness of a “where” binding needs to be taken into account. Here’s an early attempt which failed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]
groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span> 
  <span class="kw">let</span> f x a q d
        <span class="fu">|</span> q x <span class="fu">=</span> a (p x) (d <span class="fu">.</span> (<span class="fu">:</span>) x)
        <span class="fu">|</span> otherwise <span class="fu">=</span> d [] (a (p x) (c <span class="fu">.</span> (<span class="fu">:</span>) x))
  <span class="kw">in</span> foldr f (\_ d <span class="ot">-&gt;</span> d [] n) xs (const <span class="dt">False</span>) (\ _ y <span class="ot">-&gt;</span> y))</code></pre></div>
<p>Once done, though, it works as expected:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) <span class="st">&quot;aaabcccdda&quot;</span>
[<span class="st">&quot;aaa&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ccc&quot;</span>,<span class="st">&quot;dd&quot;</span>,<span class="st">&quot;a&quot;</span>]
<span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) []
[]
<span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">&lt;=</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">2</span>]
[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">2</span>]]</code></pre></div>
<p>It’s the fastest version I could find that obeyed the above laziness properties.</p>
<p>The <a href="https://ghc.haskell.org/trac/ghc/ticket/13593">GHC page on the issue</a> unfortunately seems to indicate the implementation won’t be changed. Ah, well. Regardless, I have a <a href="https://github.com/oisdk/groupBy">repository</a> with the implementation above (with extra fusion machinery added) and comparisons to other implementations.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There are several threads on the libraries mailing list on this topic:</p>
<dl>
<dt>2006</dt>
<dd><a href="http://www.haskell.org/pipermail/haskell-cafe/2006-October/019148.html">mapAccumL - find max in-sequence subsequence</a>
</dd>
<dt>2007</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2007-August/008028.html">Data.List.groupBy with non-transitive equality predicate</a> (this is the longest discussion on the topic)
</dd>
<dt>2008</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2008-September/010629.html">Generalize groupBy in a useful way?</a>
</dd>
<dt>2009</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2009-June/011866.html">nubBy seems broken in recent GHCs</a>
</dd>
</dl>
<a href="#fnref1">↩</a></li>
</ol>
</div>
]]></description>
    <pubDate>Sun, 07 Jan 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-01-07-groupBy.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Balancing Folds</title>
    <link>http://doisinkidney.com/posts/2017-10-30-balancing-folds.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 30, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>There are three main ways to fold things in Haskell: from the right, from the left, and from either side. Let’s look at the left vs right variants first. <code class="sourceCode haskell">foldr</code> works from the right:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))</code></pre></div>
<p>And <code class="sourceCode haskell">foldl</code> from the left:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldl (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></code></pre></div>
<p>As you’ll notice, the result of the two operations above is the same (6; although one may take much longer than the other). In fact, <em>whenever</em> the result of <code class="sourceCode haskell">foldr</code> and <code class="sourceCode haskell">foldl</code> is the same for a pair of arguments (in this case <code class="sourceCode haskell"><span class="fu">+</span></code> and <code class="sourceCode haskell"><span class="dv">0</span></code>), we say that that pair forms a <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html#t:Monoid"><code class="sourceCode haskell"><span class="dt">Monoid</span></code></a> for some type (well, there’s some extra stuff to do with <code class="sourceCode haskell"><span class="dv">0</span></code>, but I only care about associativity at the moment). In this case, the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> monoid is formed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Sum</span> a <span class="fu">=</span> <span class="dt">Sum</span> {<span class="ot"> getSum ::</span> a }

<span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Sum</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Sum</span> <span class="dv">0</span>
  mappend (<span class="dt">Sum</span> x) (<span class="dt">Sum</span> y) <span class="fu">=</span> <span class="dt">Sum</span> (x <span class="fu">+</span> y)</code></pre></div>
<p>When you know that you have a monoid, you can use the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html#v:foldMap"><code class="sourceCode haskell">foldMap</code></a> function: this is the third kind of fold. It says that you don’t care which of <code class="sourceCode haskell">foldl</code> or <code class="sourceCode haskell">foldr</code> is used, so the implementer of <code class="sourceCode haskell">foldMap</code> can put the parentheses wherever they want:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldMap <span class="dt">Sum</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
(<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>)
<span class="dv">0</span> <span class="fu">+</span> ((<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span>)
((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></code></pre></div>
<p>And we can’t tell the difference from the result. This is a pretty bare-bones introduction to folds and monoids: you won’t need to know more than that for the rest of this post, but the topic area is fascinating and deep, so don’t let me give you the impression that I’ve done anything more than scratched the surface.</p>
<h1 id="other-ways-to-fold">Other Ways to Fold</h1>
<p>Quite often, we <em>do</em> care about where the parentheses go. Take, for instance, a binary tree type, with values at the leaves:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
  <span class="fu">=</span> <span class="dt">Empty</span>
  <span class="fu">|</span> <span class="dt">Leaf</span> a
  <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span>
         <span class="dt">Show</span> (<span class="dt">Tree</span> a) <span class="kw">where</span>
    show <span class="dt">Empty</span> <span class="fu">=</span> <span class="st">&quot;()&quot;</span>
    show (<span class="dt">Leaf</span> x) <span class="fu">=</span> show x
    show (l <span class="fu">:*:</span> r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show l <span class="fu">++</span> <span class="st">&quot;*&quot;</span> <span class="fu">++</span> show r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></code></pre></div>
<p>We can’t (well, shouldn’t) us <code class="sourceCode haskell">foldMap</code> here, because we would be able to tell the difference between different arrangements of parentheses:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldMap something [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span>()))
(()<span class="fu">*</span>((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>))
(((()<span class="fu">*</span><span class="dv">1</span>)<span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)</code></pre></div>
<p>So we use one of the folds which lets us choose the arrangements of parentheses:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(foldr (<span class="fu">:*:</span>) <span class="dt">Empty</span> <span class="fu">.</span> map <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
<span class="co">-- (1*(2*(3*(4*(5*(6*()))))))</span>

(foldl (<span class="fu">:*:</span>) <span class="dt">Empty</span> <span class="fu">.</span> map <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
<span class="co">-- ((((((()*1)*2)*3)*4)*5)*6)</span></code></pre></div>
<p>The issue is that neither of the trees generated are necessarily what we want: often, we want something more <em>balanced</em>.</p>
<h2 id="treefold">TreeFold</h2>
<p>To try and find a more balanced fold, let’s (for now) assume we’re always going to get non-empty input. This will let us simplify the <code class="sourceCode haskell"><span class="dt">Tree</span></code> type a little, to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
  <span class="fu">=</span> <span class="dt">Leaf</span> a
  <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a
  <span class="kw">deriving</span> <span class="dt">Foldable</span>

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span>
         <span class="dt">Show</span> (<span class="dt">Tree</span> a) <span class="kw">where</span>
    show (<span class="dt">Leaf</span> x) <span class="fu">=</span> show x
    show (l <span class="fu">:*:</span> r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show l <span class="fu">++</span> <span class="st">&quot;*&quot;</span> <span class="fu">++</span> show r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></code></pre></div>
<p>Then, we can use Jon Fairbairn’s fold described in <a href="http://www.mail-archive.com/haskell@haskell.org/msg01788.html">this</a> email, adapted a bit for our non-empty input:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span>(..))

<span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a
treeFold f <span class="fu">=</span> go
  <span class="kw">where</span>
    go (x <span class="fu">:|</span> []) <span class="fu">=</span> x
    go (a <span class="fu">:|</span> b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b <span class="fu">:|</span> pairMap l)
    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest
    pairMap xs <span class="fu">=</span> xs</code></pre></div>
<p>There are two parts to this function: <code class="sourceCode haskell">pairMap</code> and the <code class="sourceCode haskell">go</code> helper. <code class="sourceCode haskell">pairMap</code> combines adjacent elements in the list using the combining function. As a top-level function it might look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pairMap f (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap f rest
pairMap f xs <span class="fu">=</span> xs

pairMap (<span class="fu">++</span>) [<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>,<span class="st">&quot;d&quot;</span>,<span class="st">&quot;e&quot;</span>]
<span class="co">-- [&quot;ab&quot;,&quot;cd&quot;,&quot;e&quot;]</span></code></pre></div>
<p>As you can see, it leaves any leftovers untouched at the end of the list.</p>
<p>The <code class="sourceCode haskell">go</code> helper applies <code class="sourceCode haskell">pairMap</code> repeatedly to the list until it has only one element. This gives us much more balanced results that <code class="sourceCode haskell">foldl</code> or <code class="sourceCode haskell">foldr</code> (turn on <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedLists</span></code> to write non-empty lists using this syntax):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
<span class="co">-- (((1*2)*(3*4))*(5*6))</span>

(treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]
<span class="co">-- (((1*2)*(3*4))*((5*6)*(7*8)))</span></code></pre></div>
<p>However, there are still cases where one branch will be much larger than its sibling. The fold fills a balanced binary tree from the left, but any leftover elements are put at the top level. In other words:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]
<span class="co">-- ((((1*2)*(3*4))*((5*6)*(7*8)))*9)</span></code></pre></div>
<p>That <code class="sourceCode haskell"><span class="dv">9</span></code> hanging out on its own there is a problem.</p>
<h2 id="typewriters-and-slaloms">Typewriters and Slaloms</h2>
<p>One observation we can make is that <code class="sourceCode haskell">pairMap</code> always starts from the same side on each iteration, like a typewriter moving from one line to the next. This has the consequence of building up the leftovers on one side, leaving them until the top level.</p>
<p>We can improve the situation slightly by going back and forth, slalom-style, so we consume leftovers on each iteration:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a
treeFold f <span class="fu">=</span> goTo <span class="kw">where</span>
  
  goTo (y <span class="fu">:|</span> []) <span class="fu">=</span> y
  goTo (a <span class="fu">:|</span> b <span class="fu">:</span> rest) <span class="fu">=</span> goFro (pairMap f (f a b) rest)
  goFro (y <span class="fu">:|</span> []) <span class="fu">=</span> y
  goFro (a <span class="fu">:|</span> b <span class="fu">:</span> rest) <span class="fu">=</span> goTo (pairMap (flip f) (f b a) rest)

  pairMap f <span class="fu">=</span> go [] <span class="kw">where</span>
    go ys y (a<span class="fu">:</span>b<span class="fu">:</span>rest) <span class="fu">=</span> go (y<span class="fu">:</span>ys) (f a b) rest
    go ys y [z] <span class="fu">=</span> z <span class="fu">:|</span> y <span class="fu">:</span> ys
    go ys y [] <span class="fu">=</span> y <span class="fu">:|</span> ys</code></pre></div>
<p>Notice that we have to flip the combining function to make sure the ordering is the same on output. For the earlier example, this solves the issue:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]
<span class="co">-- (((1*2)*((3*4)*(5*6)))*((7*8)*9))</span></code></pre></div>
<p>It does <em>not</em> build up the tree as balanced as it possibly could, though:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
<span class="co">-- ((1*2)*((3*4)*(5*6)))</span></code></pre></div>
<p>There’s four elements in the right branch, and two in the left in the above example. Three in each would be optimal.</p>
<p>Wait—optimal in what sense, exactly? What do we mean when we say one tree is more balanced than another? Let’s say the “balance factor” is the largest difference in size of two sibling trees:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">balFac ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span>
balFac <span class="fu">=</span> fst <span class="fu">.</span> go <span class="kw">where</span>
<span class="ot">  go ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>)
  go (<span class="dt">Leaf</span> _) <span class="fu">=</span> (<span class="dv">0</span>, <span class="dv">1</span>)
  go (l <span class="fu">:*:</span> r) <span class="fu">=</span> (lb <span class="ot">`max`</span> rb <span class="ot">`max`</span> abs (rs <span class="fu">-</span> ls), rs <span class="fu">+</span> ls) <span class="kw">where</span>
    (lb,ls) <span class="fu">=</span> go l
    (rb,rs) <span class="fu">=</span> go r</code></pre></div>
<p>And one tree is more balanced than another if it has a smaller balance factor.</p>
<p>There’s effectively no limit on the balance factor for the typewriter method: when the input is one larger than a power of two, it’ll stick the one extra in one branch and the rest in another (as with <code class="sourceCode haskell">[<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</code> in the example above).</p>
<p>For the slalom method, it looks like there’s something more interesting going on, limit-wise. I haven’t been able to verify this formally (yet), but from what I can tell, a tree of height <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> will have at most a balance factor of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th <a href="https://oeis.org/A001045">Jacobsthal number</a>. That’s (apparently) also the number of ways to tie a tie using <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n + 2</annotation></semantics></math> turns.</p>
<p>That was just gathered from some quick experiments and <a href="https://oeis.org/">oeis.org</a>, but it seems to make sense intuitively. Jacobsthal numbers are defined like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">j <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
j <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
j n <span class="fu">=</span> j (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> j (n<span class="fu">-</span><span class="dv">2</span>)</code></pre></div>
<p>So, at the top level, there’s the imbalance caused by the second-last <code class="sourceCode haskell">pairFold</code>, plus the imbalance caused by the third-to-last. However, the third-to-last imbalance is twice what it was at that level, because it is now working with an already-paired-up list. Why isn’t the second last imbalance also doubled? Because it’s counteracted by the fact that we turned around: the imbalance is in an element that’s a leftover element. At least that’s what my intuition is at this point.</p>
<p>The minimum balance factor is, of course, one. Unfortunately, to achieve that, I lost some of the properties of the previous folds:</p>
<h2 id="lengths">Lengths</h2>
<p>Up until now, I have been avoiding taking the length of the incoming list. It would lose a lot of laziness, cause an extra traversal, and generally seems like an ugly solution. Nonetheless, it gives the most balanced results I could find so far:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a
treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> go (length (x<span class="fu">:</span>xs)) (x<span class="fu">:</span>xs) <span class="kw">where</span>
  go <span class="dv">1</span> [y] <span class="fu">=</span> y
  go n ys <span class="fu">=</span> f (go m a) (go (n<span class="fu">-</span>m) b) <span class="kw">where</span>
    (a,b) <span class="fu">=</span> splitAt m ys 
    m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></code></pre></div>
<p><code class="sourceCode haskell">splitAt</code> is an inefficient operation, but if we let the left-hand call return its unused input from the list, we can avoid it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a
treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> fst (go (length (x<span class="fu">:</span>xs)) (x<span class="fu">:</span>xs)) <span class="kw">where</span>
  go <span class="dv">1</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (y,ys)
  go n ys <span class="fu">=</span> (f l r, rs) <span class="kw">where</span>
    (l,ls) <span class="fu">=</span> go m ys
    (r,rs) <span class="fu">=</span> go (n<span class="fu">-</span>m) ls
    m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></code></pre></div>
<p>Finally, you may have spotted the state monad in this last version. We can make the similarity explicit:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a
treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> evalState (go (length (x<span class="fu">:</span>xs))) (x<span class="fu">:</span>xs) <span class="kw">where</span>
  go <span class="dv">1</span> <span class="fu">=</span> state (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (y,ys))
  go n <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span>
    l <span class="ot">&lt;-</span> go m
    r <span class="ot">&lt;-</span> go (n<span class="fu">-</span>m)
    return (f l r)</code></pre></div>
<p>And there you have it: three different ways to fold in a more balanced way. Perhaps surprisingly, the first is the fastest in my tests. I’d love to hear if there’s a more balanced version (which is lazy, ideally) that is just as efficient as the first implementation.</p>
<h1 id="stable-summation">Stable Summation</h1>
<p>I have found two other uses for these folds other than simply constructing more balanced binary trees. The first is summation of floating-point numbers. If you sum floating-point numbers in the usual way with <code class="sourceCode haskell">foldl&#39;</code> (or, indeed, with an accumulator in an imperative language), you will see an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the number of floats you’re summing.</p>
<p>A well-known solution to this problem is the <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a>. It carries with it a running compensation for accumulating errors, giving it <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> error growth. There are two downsides to the algorithm: it takes four times the number of numerical operations to perform, and isn’t parallel.</p>
<p>For that reason, it’s often not used in practice: instead, floats are summed <em>pairwise</em>, in a manner often referred to as <a href="https://en.wikipedia.org/wiki/Pairwise_summation">cascade summation</a>. This is what’s used in <a href="https://github.com/numpy/numpy/pull/3685">NumPy</a>. The error growth isn’t quite as good—<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log{n})</annotation></semantics></math>—but it takes the exact same number of operations as normal summation. On top of that:</p>
<h1 id="parallelization">Parallelization</h1>
<p>Dividing a fold into roughly-equal chunks is exactly the kind of problem encountered when trying to parallelize certain algorithms. Adapting the folds above so that their work is performed in parallel is surprisingly easy:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">splitPar ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
splitPar f <span class="fu">=</span> go
  <span class="kw">where</span>
    go l r <span class="dv">0</span> <span class="fu">=</span> f (l <span class="dv">0</span>) (r <span class="dv">0</span>)
    go l r n <span class="fu">=</span> lt <span class="ot">`par`</span> (rt <span class="ot">`pseq`</span> f lt rt)
      <span class="kw">where</span>
        lt <span class="fu">=</span> l (n<span class="fu">-</span>m)
        rt <span class="fu">=</span> r m
        m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span>

<span class="ot">treeFoldParallel ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a
treeFoldParallel f xs <span class="fu">=</span>
    treeFold const (splitPar f) xs numCapabilities</code></pre></div>
<p>The above will split the fold into <code class="sourceCode haskell">numCapabilities</code> chunks, and perform each one in parallel. <code class="sourceCode haskell">numCapabilities</code> is a constant defined in <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Conc.html">GHC.Conc</a>: it’s the number of threads which can be run simultaneously at any one time. Alternatively, you could the function include a parameter for how many chunks to split the computation into. You could also have the fold adapt as it went, choosing whether or not to spark based on how many sparks exist at any given time:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseq ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b
parseq a b <span class="fu">=</span>
    runST
        (bool (par a b) (seq a b) <span class="fu">&lt;$&gt;</span>
         unsafeIOToST (liftA2 (<span class="fu">&gt;</span>) numSparks getNumCapabilities))

<span class="ot">treeFoldAdaptive ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
treeFoldAdaptive f <span class="fu">=</span>
    Lazy.treeFold
        (\l r <span class="ot">-&gt;</span>
              r <span class="ot">`parseq`</span> (l <span class="ot">`parseq`</span> f l r))</code></pre></div>
<p>Adapted from <a href="https://www.reddit.com/r/haskell/comments/73umrw/another_parallelism_primitive_parseq/dnurduu/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=haskell">this</a> comment by Edward Kmett. This is actually the fastest version of all the folds.</p>
<p>All of this is provided in a <a href="https://hackage.haskell.org/package/treefold">library</a> I’ve put up on Hackage.</p>
]]></description>
    <pubDate>Mon, 30 Oct 2017 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2017-10-30-balancing-folds.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Convolutions and Semirings</title>
    <link>http://doisinkidney.com/posts/2017-10-13-convolutions-and-semirings.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 13, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Semirings.html">Semirings</a>
    
</div>

<p>I have been working a little more on my <a href="https://hackage.haskell.org/package/semiring-num">semirings library</a> recently, and I have come across some interesting functions in the process. First, a quick recap on the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class and some related functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span>
<span class="ot">  one ::</span> a
<span class="ot">  zero ::</span> a
  <span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">&lt;+&gt;</span>
<span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
  <span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">&lt;.&gt;</span>
<span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

<span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Semiring</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a
add <span class="fu">=</span> foldl&#39; (<span class="fu">&lt;+&gt;</span>) zero

<span class="ot">mul ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Semiring</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a
mul <span class="fu">=</span> foldl&#39; (<span class="fu">&lt;.&gt;</span>) one

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dv">1</span>
  zero <span class="fu">=</span> <span class="dv">0</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dt">True</span>
  zero <span class="fu">=</span> <span class="dt">False</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">||</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</code></pre></div>
<p>You can think of it as a replacement for <code class="sourceCode haskell"><span class="dt">Num</span></code>, but it turns out to be much more generally useful than that.</p>
<h1 id="matrix-multiplication">Matrix Multiplication</h1>
<p>The first interesting function is to do with matrix multiplication. Here’s the code for multiplying two matrices represented as nested lists:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mulMatrix ::</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]]
mulMatrix xs ys <span class="fu">=</span> map (\row <span class="ot">-&gt;</span> map (add <span class="fu">.</span> zipWith (<span class="fu">&lt;.&gt;</span>) row) cs) xs
  <span class="kw">where</span>
    cs <span class="fu">=</span> transpose ys</code></pre></div>
<p>One of the issues with this code (other than its woeful performance) is that it seems needlessly list-specific. <code class="sourceCode haskell">zipWith</code> seems like the kind of thing that exists on a bunch of different structures. Indeed, the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#t:ZipList"><code class="sourceCode haskell"><span class="dt">ZipList</span></code> wrapper</a> uses <code class="sourceCode haskell">zipWith</code> as its <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> implementation. Let’s try that for now:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mulMatrix ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)
mulMatrix xs ys <span class="fu">=</span> fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs
  <span class="kw">where</span>
    cs <span class="fu">=</span> transpose ys</code></pre></div>
<p>Of course, now <code class="sourceCode haskell">add</code> needs to work on our <code class="sourceCode haskell">f</code>, so it should be <code class="sourceCode haskell"><span class="dt">Foldable</span></code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mulMatrix 
<span class="ot">  ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f, <span class="dt">Foldable</span> f) 
  <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)
mulMatrix <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p><code class="sourceCode haskell">transpose</code> is the missing piece now. A little bit of <code class="sourceCode haskell"><span class="dt">Applicative</span></code> magic can help us out again, though: <code class="sourceCode haskell">sequenceA</code> is <code class="sourceCode haskell">transpose</code> on <code class="sourceCode haskell"><span class="dt">ZipList</span></code>s <span class="citation">(McBride and Paterson <a href="#ref-mcbride_applicative_2008">2008</a>)</span>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mulMatrix 
<span class="ot">  ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f, <span class="dt">Traversable</span> f) 
  <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)
mulMatrix xs ys <span class="fu">=</span> 
    fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs
  <span class="kw">where</span>
    cs <span class="fu">=</span> sequenceA ys</code></pre></div>
<p>One further generalization: The two <code class="sourceCode haskell">f</code>s don’t actually need to be the same:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mulMatrix
<span class="ot">    ::</span> (<span class="dt">Applicative</span> n
       ,<span class="dt">Traversable</span> m
       ,<span class="dt">Applicative</span> m
       ,<span class="dt">Applicative</span> p
       ,<span class="dt">Semiring</span> a)
    <span class="ot">=&gt;</span> n (m a) <span class="ot">-&gt;</span> m (p a) <span class="ot">-&gt;</span> n (p a)
mulMatrix xs ys <span class="fu">=</span> fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs
  <span class="kw">where</span>
    cs <span class="fu">=</span> sequenceA ys</code></pre></div>
<p>Happily, the way that the wrappers (<code class="sourceCode haskell">n</code>, <code class="sourceCode haskell">m</code>, and <code class="sourceCode haskell">p</code>) match up coincides precisely with how matrix dimensions match up in matrix multiplication. Quoting from the <a href="https://en.wikipedia.org/wiki/Matrix_multiplication">Wikipedia definition</a>:</p>
<blockquote>
<p>if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math> matrix and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">m \times p</annotation></semantics></math> matrix, their matrix product <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n \times p</annotation></semantics></math> matrix</p>
</blockquote>
<p>This function is present in the <a href="https://hackage.haskell.org/package/linear-1.20.7/docs/Linear-Matrix.html#v:-33--42--33-">linear package</a> with some different constraints. In fairness, <code class="sourceCode haskell"><span class="dt">Applicative</span></code> probably isn’t the best thing to use here since it doesn’t work for so many instances (<a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad-Zip.html"><code class="sourceCode haskell"><span class="dt">MonadZip</span></code></a> or something similar may be more suitable), but it’s very handy to have, and works out-of the box for types like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Three</span> a 
  <span class="fu">=</span> <span class="dt">Three</span> a a a 
  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Three</span> <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Three</span> x x x
  <span class="dt">Three</span> fx fy fz <span class="fu">&lt;*&gt;</span> <span class="dt">Three</span> xx xy xz <span class="fu">=</span> <span class="dt">Three</span> (fx xx) (fy xy) (fz xz)</code></pre></div>
<p>Which makes it (to my mind) useful enough to keep. Also, it hugely simplified the code for <a href="https://github.com/oisdk/Square/blob/master/src/Data/Square.hs#L183">matrix multiplication in square matrices</a> I had, from <span class="citation">Okasaki (<a href="#ref-okasaki_fast_1999">1999</a>)</span>.</p>
<h1 id="convolutions">Convolutions</h1>
<p>If you’re putting a general class in a library that you want people to use, and there exist sensible instances for common Haskell types, you should probably provide those instances in the library to avoid orphans. The meaning of “sensible” here is vague: generally speaking, if there is only one obvious or clear instance, then it’s sensible. For a list instance for the semiring class, for instance, I could figure out several law-abiding definitions for <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, <code class="sourceCode haskell">one</code> and <code class="sourceCode haskell">zero</code>, but only one for <code class="haskel">&lt;.&gt;</code>: polynomial multiplication. You know, where you multiply two polynomials like so:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mn>5</mn><mi>x</mi><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>9</mn><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><mn>15</mn><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><mn>18</mn><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>28</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>38</mn><mi>x</mi><mo>+</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">(x^3 + 2x + 3)(5x + 3x^2 + 4) = 9x^5 + 15x^4 + 18x^3 + 28x^2 + 38x + 24</annotation></semantics></math></p>
<p>A more general definition looks something like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>b</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">(a_0x^0 + a_1x^1 + a_2x^2)(b_0x^0 + b_1x^1 + b_2x^2) =</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">a_0b_0x^0 + (a_0b_1 + a_1b_0)x^1 + (a_0b_2 + a_1b_1 + a_2b_0)x^2 + (a_1b_2 + a_2b_1)x^3 + a_2b_2x^4</annotation></semantics></math></p>
<p>Or, fully generalized:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mi>k</mi></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">c_k = a_0b_k + a_1b_{k-1} + \ldots + a_{k-1}b_1 + a_kb_0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></munderover><msub><mi>c</mi><mi>i</mi></msub><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">f(x) \times g(x) = \sum_{i=0}^{n+m}c_ix^i</annotation></semantics></math></p>
<p>So it turns out that you can represent polynomials pretty elegantly as lists. Take an example from above:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">x^3 + 2x + 3</annotation></semantics></math></p>
<p>And rearrange it in order of the powers of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">3x^0 + 2x^1 + x^3</annotation></semantics></math></p>
<p>And fill in missing coefficients:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mn>0</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">3x^0 + 2x^1 + 0x^2 + 1x^3</annotation></semantics></math></p>
<p>And then the list representation of that polynomial is the list of those coefficients:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>]</code></pre></div>
<p>For me, the definitions of multiplication above were pretty hard to understand. In Haskell, however, the definition is quite beautiful:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span>
  one <span class="fu">=</span> [one]
  zero <span class="fu">=</span> []
  [] <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> ys
  xs <span class="fu">&lt;+&gt;</span> [] <span class="fu">=</span> xs
  (x<span class="fu">:</span>xs) <span class="fu">&lt;+&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> (xs <span class="fu">&lt;+&gt;</span> ys)
  _ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []
  [] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []
  (x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">&lt;.&gt;</span>y) <span class="fu">:</span> map (x<span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> xs <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys)</code></pre></div>
<p>This definition for <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> can be found on page 4 of <span class="citation">McIlroy (<a href="#ref-mcilroy_power_1999">1999</a>)</span>. Although there was a version of the paper with a slightly different definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">_ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []
[] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []
(x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) 
  <span class="fu">=</span> (x<span class="fu">&lt;.&gt;</span>y) <span class="fu">:</span> (map (x<span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> map (<span class="fu">&lt;.&gt;</span>y) xs <span class="fu">&lt;+&gt;</span> (zero <span class="fu">:</span> (xs <span class="fu">&lt;.&gt;</span> ys)))</code></pre></div>
<p>Similar to one which appeared in <span class="citation">Dolan (<a href="#ref-dolan_fun_2013">2013</a>)</span>.</p>
<p>As it happens, I prefer the first definition. It’s shorter, and I figured out how to write it as a fold:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">_ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []
xs <span class="fu">&lt;.&gt;</span> ys <span class="fu">=</span> foldr f [] xs <span class="kw">where</span>
  f x zs <span class="fu">=</span> map (x <span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> (zero <span class="fu">:</span> zs)</code></pre></div>
<p>And if you inline the <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, you get a reasonable speedup:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">xs <span class="fu">&lt;.&gt;</span> ys <span class="fu">=</span> foldr f [] xs
  <span class="kw">where</span>
    f x zs <span class="fu">=</span> foldr (g x) id ys (zero <span class="fu">:</span> zs)
    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">&lt;+&gt;</span> z <span class="fu">:</span> a zs
    g x y a [] <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">:</span> a []</code></pre></div>
<p>The definition of <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> can also use a fold on either side for fusion purposes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> foldr f id <span class="kw">where</span>
  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> xs ys
  f x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs []

(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> flip (foldr f id) <span class="kw">where</span>
  f y ys (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> ys xs
  f y ys [] <span class="fu">=</span> y <span class="fu">:</span> ys []</code></pre></div>
<p>There are rules in the library to choose one of the above definitions if fusion is available.</p>
<p>This definition is much more widely useful than it may seem at first. Say, for instance, you wanted to search through pairs of things from two infinite lists. You can’t use the normal way to pair things for lists, the Cartesian product, because it will diverge:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[(x,y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>]]
<span class="co">-- [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)...</span></code></pre></div>
<p>You’ll never get beyond 1 in the first list. Zipping isn’t an option either, because you won’t really explore the search space, only corresponding pairs. <a href="https://byorgey.wordpress.com/2008/04/22/list-convolutions/">Brent Yorgey showed</a> that if you want a list like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[(y,x<span class="fu">-</span>y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>x] ]
<span class="co">-- [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0)...</span></code></pre></div>
<p>Then what you’re looking for is a convolution (the same thing as polynomial multiplication). <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> above can be adapted readily:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">convolve ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [[(a,b)]]
convolve xs ys <span class="fu">=</span> foldr f [] xs
  <span class="kw">where</span>
    f x zs <span class="fu">=</span> foldr (g x) id ys ([] <span class="fu">:</span> zs)
    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> ((x, y) <span class="fu">:</span> z) <span class="fu">:</span> a zs
    g x y a [] <span class="fu">=</span> [(x, y)] <span class="fu">:</span> a []</code></pre></div>
<p>Flatten out this result to get your ordering. This convolution is a little different from the one in the blog post. By inlining <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> we can avoid the expensive <code class="sourceCode haskell"><span class="fu">++</span></code> function, without using difference lists.</p>
<h1 id="long-multiplication">Long Multiplication</h1>
<p>Here’s another cool use of lists as polynomials: they can be used as a <a href="https://en.Wikipedia.org/wiki/Positional_notation">positional numeral system</a>. Most common numeral systems are positional, including Arabic (the system you most likely use, where twenty-four is written as 24) and binary. Non-positional systems are things like Roman numerals. Looking at the Arabic system for now, we see that the way of writing down numbers:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1989</mn><annotation encoding="application/x-tex">1989</annotation></semantics></math></p>
<p>Can be thought of the sum of each digit multiplied by ten to the power of its position:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1</mn><mo>×</mo><msup><mn>10</mn><mn>3</mn></msup><mo>+</mo><mn>9</mn><mo>×</mo><msup><mn>10</mn><mn>2</mn></msup><mo>+</mo><mn>8</mn><mo>×</mo><msup><mn>10</mn><mn>1</mn></msup><mo>+</mo><mn>9</mn><mo>×</mo><msup><mn>10</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">1989 = 1 \times 10^3 \plus 9 \times 10^2 \plus 8 \times 10^1 \plus 9 \times 10^0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1</mn><mo>×</mo><mn>1000</mn><mo>+</mo><mn>9</mn><mo>×</mo><mn>100</mn><mo>+</mo><mn>8</mn><mo>×</mo><mn>10</mn><mo>+</mo><mn>9</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1989 = 1 \times 1000 \plus 9 \times 100 \plus 8 \times 10 \plus 9 \times 1</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1000</mn><mo>+</mo><mn>900</mn><mo>+</mo><mn>80</mn><mo>+</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">1989 = 1000 \plus 900 \plus 80 \plus 9</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1989</mn></mrow><annotation encoding="application/x-tex">1989 = 1989</annotation></semantics></math></p>
<p>Where the positions are numbered from the right. In other words, it’s our polynomial list from above in reverse. As well as that, the convolution is long multiplication.</p>
<p>Now, taking this straight off we can try some examples:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 12 + 15 = 27</span>
[<span class="dv">2</span>, <span class="dv">1</span>] <span class="fu">&lt;+&gt;</span> [<span class="dv">5</span>, <span class="dv">1</span>] <span class="fu">==</span> [<span class="dv">7</span>, <span class="dv">2</span>]

<span class="co">-- 23 * 2 = 46</span>
[<span class="dv">3</span>, <span class="dv">2</span>] <span class="fu">&lt;.&gt;</span> [<span class="dv">2</span>] <span class="fu">==</span> [<span class="dv">6</span>, <span class="dv">4</span>]</code></pre></div>
<p>The issue, of course, is that we’re not handling carrying properly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dv">6</span>] <span class="fu">&lt;+&gt;</span> [<span class="dv">6</span>] <span class="fu">==</span> [<span class="dv">12</span>]</code></pre></div>
<p>No matter: we can perform all the carries after the addition, and everything works out fine:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">carry
<span class="ot">    ::</span> <span class="dt">Integral</span> a
    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
carry base xs <span class="fu">=</span> foldr f (toBase base) xs <span class="dv">0</span>
  <span class="kw">where</span>
    f e a cin <span class="fu">=</span> r <span class="fu">:</span> a q <span class="kw">where</span>
      (q,r) <span class="fu">=</span> quotRem (cin <span class="fu">+</span> e) base
        
<span class="ot">toBase ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
toBase base <span class="fu">=</span> unfoldr f <span class="kw">where</span>
  f <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  f n <span class="fu">=</span> <span class="dt">Just</span> (swap (quotRem n base))</code></pre></div>
<p>Wrap the whole thing in a newtype and we can have a <code class="sourceCode haskell"><span class="dt">Num</span></code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Positional</span> 
  <span class="fu">=</span> <span class="dt">Positional</span> 
  {<span class="ot"> withBase ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>] 
  } 

<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Positional</span> <span class="kw">where</span>
  <span class="dt">Positional</span> x <span class="fu">+</span> <span class="dt">Positional</span> y <span class="fu">=</span> <span class="dt">Positional</span> (carry <span class="fu">&lt;*&gt;</span> x <span class="fu">&lt;+&gt;</span> y)
  <span class="dt">Positional</span> x <span class="fu">*</span> <span class="dt">Positional</span> y <span class="fu">=</span> <span class="dt">Positional</span> (carry <span class="fu">&lt;*&gt;</span> x <span class="fu">&lt;.&gt;</span> y)
  fromInteger m <span class="fu">=</span> <span class="dt">Positional</span> (\base <span class="ot">-&gt;</span> toBase base m)
  abs <span class="fu">=</span> id
  signum <span class="fu">=</span> id
  negate <span class="fu">=</span> id
  
<span class="ot">toDigits ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Positional</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
toDigits base p <span class="fu">=</span> reverse (withBase p base)</code></pre></div>
<p>This also lets us choose our base after the fact:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sumHundred <span class="fu">=</span> (sum <span class="fu">.</span> map fromInteger) [<span class="dv">1</span><span class="fu">..</span><span class="dv">100</span>]
toDigits <span class="dv">10</span> sumHundred
<span class="co">-- [5,0,5,0]</span>
toDigits <span class="dv">2</span> sumHundred
<span class="co">-- [1,0,0,1,1,1,0,1,1,1,0,1,0]</span></code></pre></div>
<h1 id="vectors">Vectors</h1>
<p>All the hand-optimizing, inlining, and fusion magic in the world won’t make a list-based implementation of convolution faster than a proper one on vectors, unfortunately. In particular, for larger vectors, a fast Fourier transform can be used. Also, usually code like this will be parallelized, rather than sequential. That said, it can be helpful to implement the slower version on vectors, in the usual indexed way, for comparison’s sake:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span>
         <span class="dt">Semiring</span> (<span class="dt">Vector</span> a) <span class="kw">where</span>
    one <span class="fu">=</span> Vector.singleton one
    zero <span class="fu">=</span> Vector.empty
    xs <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span>
        <span class="kw">case</span> compare (Vector.length xs) (Vector.length ys) <span class="kw">of</span>
            <span class="dt">EQ</span> <span class="ot">-&gt;</span> Vector.zipWith (<span class="fu">&lt;+&gt;</span>) xs ys
            <span class="dt">LT</span> <span class="ot">-&gt;</span> Vector.unsafeAccumulate (<span class="fu">&lt;+&gt;</span>) ys (Vector.indexed xs)
            <span class="dt">GT</span> <span class="ot">-&gt;</span> Vector.unsafeAccumulate (<span class="fu">&lt;+&gt;</span>) xs (Vector.indexed ys)
    signal <span class="fu">&lt;.&gt;</span> kernel
      <span class="fu">|</span> Vector.null signal <span class="fu">=</span> Vector.empty
      <span class="fu">|</span> Vector.null kernel <span class="fu">=</span> Vector.empty
      <span class="fu">|</span> otherwise <span class="fu">=</span> Vector.generate (slen <span class="fu">+</span> klen <span class="fu">-</span> <span class="dv">1</span>) f
      <span class="kw">where</span>
        f n <span class="fu">=</span>
            foldl&#39;
                (\a k <span class="ot">-&gt;</span>
                      a <span class="fu">&lt;+&gt;</span>
                      Vector.unsafeIndex signal k <span class="fu">&lt;.&gt;</span>
                      Vector.unsafeIndex kernel (n <span class="fu">-</span> k))
                zero
                [kmin <span class="fu">..</span> kmax]
          <span class="kw">where</span>
            <span class="fu">!</span>kmin <span class="fu">=</span> max <span class="dv">0</span> (n <span class="fu">-</span> (klen <span class="fu">-</span> <span class="dv">1</span>))
            <span class="fu">!</span>kmax <span class="fu">=</span> min n (slen <span class="fu">-</span> <span class="dv">1</span>)
        <span class="fu">!</span>slen <span class="fu">=</span> Vector.length signal
        <span class="fu">!</span>klen <span class="fu">=</span> Vector.length kernel</code></pre></div>
<h1 id="search">Search</h1>
<p>As has been observed before <span class="citation">(Rivas, Jaskelioff, and Schrijvers <a href="#ref-rivas_monoids_2015">2015</a>)</span> there’s a pretty suggestive similarity between semirings and the <code class="sourceCode haskell"><span class="dt">Applicative</span></code>/<code class="sourceCode haskell"><span class="dt">Alternative</span></code> classes in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span>
<span class="ot">  one ::</span> a
<span class="ot">  zero ::</span> a
<span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

<span class="kw">class</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">class</span> <span class="dt">Alternative</span> f <span class="kw">where</span>
<span class="ot">  empty ::</span> f a
<span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</code></pre></div>
<p>So can our implementation of convolution be used to implement the methods for these classes? Partially:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Search</span> f a <span class="fu">=</span> <span class="dt">Search</span> {<span class="ot"> runSearch ::</span> [f a] }

<span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Search</span> f) <span class="kw">where</span>
  fmap f (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap) f xs)

<span class="kw">instance</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Search</span> f) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Search</span> [pure x]
  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> [] <span class="fu">=</span> <span class="dt">Search</span> []
  <span class="dt">Search</span> xs <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (foldr f [] xs) <span class="kw">where</span>
    f x zs <span class="fu">=</span> foldr (g x) id ys (empty <span class="fu">:</span> zs)
    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> (x <span class="fu">&lt;*&gt;</span> y <span class="fu">&lt;|&gt;</span> z) <span class="fu">:</span> a zs
    g x y a [] <span class="fu">=</span> (x <span class="fu">&lt;*&gt;</span> y) <span class="fu">:</span> a []

<span class="kw">instance</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Search</span> f) <span class="kw">where</span>
  <span class="dt">Search</span> xs <span class="fu">&lt;|&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (go xs ys) <span class="kw">where</span>
    go [] ys <span class="fu">=</span> ys
    go xs [] <span class="fu">=</span> xs
    go (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">&lt;|&gt;</span> y) <span class="fu">:</span> go xs ys
  empty <span class="fu">=</span> <span class="dt">Search</span> []</code></pre></div>
<p>At first, this seems perfect: the types all match up, and the definitions seem sensible. The issue is with the laws: <code class="sourceCode haskell"><span class="dt">Applicative</span></code> and <code class="sourceCode haskell"><span class="dt">Alternative</span></code> are missing <em>four</em> that semirings require. In particular: commutativity of plus, annihilation by zero, and distributivity left and right:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">xs <span class="fu">&lt;|&gt;</span> ys <span class="fu">=</span> ys <span class="fu">&lt;|&gt;</span> xs
empty <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> empty <span class="fu">=</span> empty
fs <span class="fu">&lt;*&gt;</span> (xs <span class="fu">&lt;|&gt;</span> ys) <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">&lt;|&gt;</span> fs <span class="fu">&lt;*&gt;</span> ys
(fs <span class="fu">&lt;|&gt;</span> gs) <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">&lt;|&gt;</span> gs <span class="fu">&lt;*&gt;</span> ys</code></pre></div>
<p>The vast majority of the instances of <code class="sourceCode haskell"><span class="dt">Alternative</span></code> today fail one or more of these laws. Taking lists as an example, <code class="sourceCode haskell"><span class="fu">++</span></code> obviously isn’t commutative, and <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> only distributes when it’s on the right.</p>
<p>What’s the problem, though? Polynomial multiplication follows <em>more</em> laws than those required by <code class="sourceCode haskell"><span class="dt">Applicative</span></code>: why should that worry us? Unfortunately, in order for multiplication to follow those laws, it actually relies on the underlying semiring being law-abiding. And it <em>fails</em> the applicative laws when it isn’t.</p>
<p>There are two angles from which we could come at this problem: either we relax the semiring laws and try and make our implementation of convolution rely on them as little as possible, or we find <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instances which follow the semiring laws. Or we could meet in the middle, relaxing the laws as much as possible until we find some <code class="sourceCode haskell"><span class="dt">Alternative</span></code>s that meet our standards.</p>
<p>This has actually been accomplished in several papers: the previously mentioned <span class="citation">Rivas, Jaskelioff, and Schrijvers (<a href="#ref-rivas_monoids_2015">2015</a>)</span> discusses near-semirings, defined as semiring-like structures with associativity, identity, and these two laws:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \times x = 0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>z</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>×</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>×</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x \plus y) \times z = (x \times z) \plus (y \times z)</annotation></semantics></math></p>
<p>In contrast to normal semirings, zero only annihilates when it’s on the left, and multiplication only distributes over addition when it’s on the right. Addition is not required to be commutative.</p>
<p>The lovely paper <span class="citation">Spivey (<a href="#ref-spivey_algebras_2009">2009</a>)</span> has a similar concept: a “bunch”.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Bunch</span> m <span class="kw">where</span>
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
<span class="ot">  zero ::</span> m a
<span class="ot">  (&lt;|&gt;) ::</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a
<span class="ot">  wrap ::</span> m a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>The laws are all the same (with <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> implemented in terms of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code>), and the extra <code class="sourceCode haskell">wrap</code> operation can be expressed like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">wrap ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Search</span> f a <span class="ot">-&gt;</span> <span class="dt">Search</span> f a
wrap (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> (empty <span class="fu">:</span> xs)</code></pre></div>
<p>A definition of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> for our polynomials is also provided:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[] <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> []
(x<span class="fu">:</span>xs) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldr (<span class="fu">&lt;|&gt;</span>) empty (fmap f x) <span class="fu">&lt;|&gt;</span> wrap (xs <span class="fu">&gt;&gt;=</span> f)</code></pre></div>
<p>This will require the underlying <code class="sourceCode haskell">f</code> to be <code class="sourceCode haskell"><span class="dt">Foldable</span></code>. We can inline a little, and express the whole thing as a fold:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Foldable</span> f, <span class="dt">Alternative</span> f) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Search</span> f) <span class="kw">where</span>
  <span class="dt">Search</span> xs <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> foldr f empty xs <span class="kw">where</span>
    f e a <span class="fu">=</span> foldr ((<span class="fu">&lt;|&gt;</span>) <span class="fu">.</span> k) (wrap a) e</code></pre></div>
<p>For <code class="sourceCode haskell"><span class="dt">Search</span></code> to meet the requirements of a bunch, the paper notes that the <code class="sourceCode haskell">f</code> must be assumed to be a bag, i.e., the order of its elements must be ignored.</p>
<p><span class="citation">Kiselyov et al. (<a href="#ref-kiselyov_backtracking_2005">2005</a>)</span> kind of goes the other direction, defining a monad which has fair disjunction and conjunction. Unfortunately, the fair conjunction loses associativity.</p>
<h1 id="distance">Distance</h1>
<p>The end of the paper on algebras for combinatorial search wonders if notions of distance could be added to some of the algebras. I <em>think</em> that should be as simple as supplying a suitable near-semiring for <code class="sourceCode haskell">f</code>, but the definition of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> would need to be changed. The near-semiring I had in mind was the probability monad. It works correctly if inlined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Search</span> s a <span class="fu">=</span> <span class="dt">Search</span> {<span class="ot"> runSearch ::</span> [[(a,s)]] }

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Search</span> s) <span class="kw">where</span>
  fmap f (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap<span class="fu">.</span>first) f xs)

<span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Search</span> s) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Search</span> [[(x,one)]]
  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> [] <span class="fu">=</span> <span class="dt">Search</span> []
  <span class="dt">Search</span> xs <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (foldr f [] xs) <span class="kw">where</span>
    f x zs <span class="fu">=</span> foldr (g x) id ys (empty <span class="fu">:</span> zs)
    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> (m x y <span class="fu">++</span> z) <span class="fu">:</span> a zs
    g x y a [] <span class="fu">=</span> (m x y) <span class="fu">:</span> a []
    m ls rs <span class="fu">=</span> [(l r, lp<span class="fu">&lt;.&gt;</span>rp) <span class="fu">|</span> (l,lp) <span class="ot">&lt;-</span> ls, (r,rp) <span class="ot">&lt;-</span> rs]

<span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Search</span> s) <span class="kw">where</span>
  <span class="dt">Search</span> xs <span class="fu">&lt;|&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (go xs ys) <span class="kw">where</span>
    go [] ys <span class="fu">=</span> ys
    go xs [] <span class="fu">=</span> xs
    go (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">++</span> y) <span class="fu">:</span> go xs ys
  empty <span class="fu">=</span> <span class="dt">Search</span> []

<span class="ot">wrap ::</span> <span class="dt">Search</span> s a <span class="ot">-&gt;</span> <span class="dt">Search</span> s a
wrap (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ([] <span class="fu">:</span> xs)

<span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Search</span> s) <span class="kw">where</span>
  <span class="dt">Search</span> xs <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> foldr f empty xs <span class="kw">where</span>
    f e a <span class="fu">=</span> foldr ((<span class="fu">&lt;|&gt;</span>) <span class="fu">.</span> uncurry (mulIn <span class="fu">.</span> k)) (wrap a) e
    mulIn (<span class="dt">Search</span> x) xp <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap<span class="fu">.</span>fmap) (xp<span class="fu">&lt;.&gt;</span>) x)</code></pre></div>
<p>But I couldn’t figure out how to get it to work for a more generalized inner monad. The above could probably be sped up, or randomized, using the many well-known techniques for probability monad optimization.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. “Fun with semirings: A functional pearl on the abuse of linear algebra.” In, 48:101. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500613">10.1145/2500365.2500613</a>. <a href="https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf" class="uri">https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf</a>.</p>
</div>
<div id="ref-kiselyov_backtracking_2005">
<p>Kiselyov, Oleg, Chung-chieh Shan, Daniel P Friedman, and Amr Sabry. 2005. “Backtracking, interleaving, and terminating monad transformers (functional pearl).” <em>ACM SIGPLAN Notices</em> 40 (9): 192–203. <a href="http://okmij.org/ftp/Computation/monads.html#LogicT" class="uri">http://okmij.org/ftp/Computation/monads.html#LogicT</a>.</p>
</div>
<div id="ref-mcbride_applicative_2008">
<p>McBride, Conor, and Ross Paterson. 2008. “Applicative programming with effects.” <em>Journal of functional programming</em> 18 (01): 1–13. <a href="http://strictlypositive.org/Idiom.pdf" class="uri">http://strictlypositive.org/Idiom.pdf</a>.</p>
</div>
<div id="ref-mcilroy_power_1999">
<p>McIlroy, M. Douglas. 1999. “Power Series, Power Serious.” <em>J. Funct. Program.</em> 9 (3) (May): 325–337. doi:<a href="https://doi.org/10.1017/S0956796899003299">10.1017/S0956796899003299</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999. “From Fast Exponentiation to Square Matrices: An Adventure in Types.” In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP’99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. “From monoids to near-semirings: The essence of MonadPlus and Alternative.” In <em>Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming</em>, 196–207. ACM. doi:<a href="https://doi.org/10.1145/2790449.2790514">10.1145/2790449.2790514</a>. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf" class="uri">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. “Algebras for combinatorial search.” <em>Journal of Functional Programming</em> 19 (3-4) (July): 469–487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>. <a href="https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf" class="uri">https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 13 Oct 2017 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2017-10-13-convolutions-and-semirings.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Applicative Arithmetic</title>
    <link>http://doisinkidney.com/posts/2017-09-25-applicative-arithmetic.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 25, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="safer-arithmetic">Safer Arithmetic</h1>
<p>There are a couple partial functions in the Haskell Prelude which people seem to agree shouldn’t be there. <code class="sourceCode haskell">head</code>, for example, will throw an error on an empty list. Most seem to agree that it should work something more like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">head<span class="ot"> ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
head <span class="fu">=</span> foldr (const <span class="fu">.</span> <span class="dt">Just</span>) <span class="dt">Nothing</span></code></pre></div>
<p>There are other examples, like <code class="sourceCode haskell">last</code>, <code class="sourceCode haskell"><span class="fu">!!</span></code>, etc.</p>
<p>One which people <em>don’t</em> agree on, however, is division by zero. In the current Prelude, the following will throw an error:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dv">1</span> <span class="fu">/</span> <span class="dv">0</span></code></pre></div>
<p>The “safe” version might have a signature like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(/) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</code></pre></div>
<p>However, this turns out to be quite a headache for writing code generally. So the default is the (somewhat) unsafe version.</p>
<p>Is there a way to introduce a safer version without much overhead, so the programmer is given the option? Of course! With some newtype magic, it’s pretty simple to write a wrapper which catches division by zero in some arbitrary monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">AppNum</span> f a <span class="fu">=</span> <span class="dt">AppNum</span>
    {<span class="ot"> runAppNum ::</span> f a
    } <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Applicative</span>,<span class="dt">Monad</span>,<span class="dt">Alternative</span>,<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">MonadFail</span>)

<span class="kw">instance</span> (<span class="dt">Num</span> a, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span>
         <span class="dt">Num</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span>
    abs <span class="fu">=</span> fmap abs
    signum <span class="fu">=</span> fmap signum
    (<span class="fu">+</span>) <span class="fu">=</span> liftA2 (<span class="fu">+</span>)
    (<span class="fu">*</span>) <span class="fu">=</span> liftA2 (<span class="fu">*</span>)
    (<span class="fu">-</span>) <span class="fu">=</span> liftA2 (<span class="fu">-</span>)
    negate <span class="fu">=</span> fmap negate
    fromInteger <span class="fu">=</span> pure <span class="fu">.</span> fromInteger

<span class="kw">instance</span> (<span class="dt">Fractional</span> a, <span class="dt">MonadFail</span> f, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span>
         <span class="dt">Fractional</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span>
    fromRational <span class="fu">=</span> pure <span class="fu">.</span> fromRational
    xs <span class="fu">/</span> ys <span class="fu">=</span>
        ys <span class="fu">&gt;&gt;=</span>
        \<span class="kw">case</span>
            <span class="dv">0</span> <span class="ot">-&gt;</span> fail <span class="st">&quot;divide by zero&quot;</span>
            y <span class="ot">-&gt;</span> fmap (<span class="fu">/</span> y) xs</code></pre></div>
<p>I’m using the <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XLambdaCase</span></code> extension and <code class="sourceCode haskell"><span class="dt">MonadFail</span></code> here.</p>
<h1 id="free-applicatives">Free Applicatives</h1>
<p>You’ll notice that you only need <code class="sourceCode haskell"><span class="dt">Applicative</span></code> for most of the arithmetic operations above. In fact, you only need <code class="sourceCode haskell"><span class="dt">Monad</span></code> when you want to examine the contents of <code class="sourceCode haskell">f</code>. Using that fact, we can manipulate expression trees using the free applicative from the <a href="https://hackage.haskell.org/package/free">free</a> package. Say, for instance, we want to have free variables in our expressions. Using <code class="sourceCode haskell"><span class="dt">Either</span></code>, it’s pretty easy:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) <span class="dt">Integer</span>

<span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span>
var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Left</span></code></pre></div>
<p>We can collect the free variables from an expression:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
vars <span class="fu">=</span> runAp_ (either pure (const [])) <span class="fu">.</span> runAppNum

x <span class="fu">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">WithVars</span>
y <span class="fu">=</span> var <span class="st">&quot;y&quot;</span>
z <span class="fu">=</span> var <span class="st">&quot;z&quot;</span>

vars (x <span class="fu">+</span> y <span class="fu">+</span> z) <span class="co">-- [&quot;y&quot;,&quot;z&quot;]</span></code></pre></div>
<p>If we want to sub in, though, we’re going to run into a problem: we can’t just pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span></code> because you’re able to construct values like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bad ::</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
bad <span class="fu">=</span> <span class="dt">AppNum</span> (liftAp (<span class="dt">Left</span> <span class="st">&quot;oh noes&quot;</span>))</code></pre></div>
<p>We’d need to pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)</code> as well; in fact you’d need a map for every possible type. Which isn’t feasible.</p>
<h1 id="gadts">GADTs</h1>
<p>Luckily, we <em>can</em> constrain the types of variables in our expression so that they’re always <code class="sourceCode haskell"><span class="dt">Integer</span></code>, using a GADT:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Variable</span> a <span class="kw">where</span>
        <span class="dt">Constant</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Variable</span> a
        <span class="dt">Variable</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Variable</span> <span class="dt">Integer</span></code></pre></div>
<p>The type above seems useless on its own: it doesn’t have a <code class="sourceCode haskell"><span class="dt">Functor</span></code> instance, never mind an <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, so how can it fit into <code class="sourceCode haskell"><span class="dt">AppNum</span></code>?</p>
<p>The magic comes from the free applicative, which converts any type of kind <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> into an applicative. With that in mind, we can change around the previous code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> <span class="dt">Variable</span>) <span class="dt">Integer</span>

<span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span>
var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Variable</span>

<span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
vars <span class="fu">=</span> runAp_ f <span class="fu">.</span> runAppNum
  <span class="kw">where</span>
<span class="ot">    f ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]
    f (<span class="dt">Constant</span> _) <span class="fu">=</span> []
    f (<span class="dt">Variable</span> s) <span class="fu">=</span> [s]</code></pre></div>
<p>And write the function to sub in for us:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">variableA
<span class="ot">    ::</span> <span class="dt">Applicative</span> f
    <span class="ot">=&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> f <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> f a
variableA _ (<span class="dt">Constant</span> x) <span class="fu">=</span> pure x
variableA f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s

<span class="ot">variable ::</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> a
variable _ (<span class="dt">Constant</span> x) <span class="fu">=</span> x
variable f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s

<span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
replace m <span class="fu">=</span> runAp (variable (m <span class="fu">Map.!</span>)) <span class="fu">.</span> runAppNum

replace (Map.fromList [(<span class="st">&quot;z&quot;</span>,<span class="dv">2</span>), (<span class="st">&quot;y&quot;</span>,<span class="dv">3</span>)]) (x <span class="fu">+</span> y <span class="fu">+</span> z)
<span class="co">-- 6</span></code></pre></div>
<h1 id="accumulation">Accumulation</h1>
<p>This will fail if a free variable isn’t present in the map, unfortunately. To fix it, we <em>could</em> use <code class="sourceCode haskell"><span class="dt">Either</span></code> instead of <code class="sourceCode haskell"><span class="dt">Identity</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Integer</span>
replace m <span class="fu">=</span>
    runAp
        (variableA <span class="fu">$</span>
         \s <span class="ot">-&gt;</span>
              maybe (<span class="dt">Left</span> s) <span class="dt">Right</span> (Map.lookup s m)) <span class="fu">.</span>
    runAppNum</code></pre></div>
<p>But this only gives us the first missing variable encountered. We’d like to get back <em>all</em> of the missing variables, ideally: accumulating the <code class="sourceCode haskell"><span class="dt">Left</span></code>s. <code class="sourceCode haskell"><span class="dt">Either</span></code> doesn’t accumulate values, as if it did it would <a href="https://stackoverflow.com/a/23611068/4892417">break the monad laws</a>.</p>
<p>There’s no issue with the <em>applicative</em> laws, though, which is why the <a href="https://hackage.haskell.org/package/validation-0.5.4">validation</a> package provides a <em>non-monadic</em> either-like type, which we can use here.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">AccValidation</span> [<span class="dt">String</span>] <span class="dt">Integer</span>
replace m <span class="fu">=</span>
    runAp
        (variableA <span class="fu">$</span>
         \s <span class="ot">-&gt;</span>
              maybe (<span class="dt">AccFailure</span> [s]) pure (Map.lookup s m)) <span class="fu">.</span>
    runAppNum

replace (Map.fromList []) (x <span class="fu">+</span> y <span class="fu">+</span> z)
<span class="co">-- AccFailure [&quot;y&quot;,&quot;z&quot;]</span></code></pre></div>
<h1 id="other-uses">Other uses</h1>
<p>There are a bunch more applicatives you could use instead of <code class="sourceCode haskell"><span class="dt">Either</span></code>. Using lists, for instance, you could calculate the possible outcomes from a range of inputs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">range<span class="ot"> ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
range <span class="fu">=</span> runAp (variable (const [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>])) <span class="fu">.</span> runAppNum

range (x <span class="fu">+</span> y <span class="fu">+</span> z)
<span class="co">-- [3,4,5,4,5,6,5,6,7]</span></code></pre></div>
<p>Or you could ask the user for input:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">query ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Integer</span>
query <span class="fu">=</span> runAp (variable f) <span class="fu">.</span> runAppNum
  <span class="kw">where</span>
    f s <span class="fu">=</span> <span class="kw">do</span>
      putStr <span class="st">&quot;Input a value for &quot;</span>
      putStrLn s
      fmap read getLine</code></pre></div>
<p>Finally, and this one’s a bit exotic, you could examine every variable in turn, with defaults for the others:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zygo
<span class="ot">    ::</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x)
    <span class="ot">-&gt;</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b)
    <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a
    <span class="ot">-&gt;</span> [b]
zygo (<span class="ot">l ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x) (<span class="ot">c ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b) <span class="fu">=</span>
    fst <span class="fu">.</span> go id
  <span class="kw">where</span>
<span class="ot">    go ::</span> forall c<span class="fu">.</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Ap</span> f c <span class="ot">-&gt;</span> ([b], c)
    go _ (<span class="dt">Pure</span> x) <span class="fu">=</span> ([], x)
    go k (<span class="dt">Ap</span> x f) <span class="fu">=</span> (c x (k <span class="fu">.</span> ls) <span class="fu">:</span> xs, ls lx)
      <span class="kw">where</span>
        (xs,ls) <span class="fu">=</span> go (k <span class="fu">.</span> (<span class="fu">$</span> lx)) f
        lx <span class="fu">=</span> l x

<span class="ot">examineEach ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>]
examineEach <span class="fu">=</span> zygo (variable (const <span class="dv">1</span>)) g <span class="fu">.</span> runAppNum
  <span class="kw">where</span>
<span class="ot">    g ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> b
    g (<span class="dt">Constant</span> x) rhs _ <span class="fu">=</span> rhs x
    g (<span class="dt">Variable</span> _) rhs i <span class="fu">=</span> rhs i</code></pre></div>
<p>This produces a list of functions which are equivalent to subbing in for each variable with the rest set to 1.</p>
]]></description>
    <pubDate>Mon, 25 Sep 2017 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2017-09-25-applicative-arithmetic.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>

    </channel>
</rss>
