<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Donnacha Oisín Kidney's Blog</title>
        <link>http://doisinkidney.com</link>
        <description><![CDATA[Mainly writing about programming]]></description>
        <atom:link href="http://doisinkidney.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 03 Jun 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>Breadth-First Traversals in Far Too Much Detail</title>
    <link>http://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  3, 2018
</div>
<div class="info">
    
        Part 3 of a <a href="/series/Breadth-First%20Traversals.html">3-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Trees.html">Trees</a>
    
</div>

<p>After looking at the algorithms I <a href="2018-06-01-rose-trees-breadth-first-traversing.html">posted last time</a>, I noticed some patterns emerging which I thought deserved a slightly longer post. I’ll go through the problem <span class="citation" data-cites="gibbons_breadth-first_2015">(Gibbons <a href="#ref-gibbons_breadth-first_2015">2015</a>)</span> in a little more detail, and present some more algorithms to go along with it.</p>
<h1 id="the-problem">The Problem</h1>
<p>The original question was posed by <a href="https://www.facebook.com/groups/programming.haskell/permalink/985981691412832/">Etian Chatav</a>:</p>
<blockquote>
<p>What is the correct way to write breadth first traversal of a <code class="sourceCode haskell">[<span class="dt">Tree</span>]</code>?</p>
</blockquote>
<p>The breadth-first traversal here is a traversal in the lensy sense, i.e:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a] <span class="ot">-&gt;</span> f [<span class="dt">Tree</span> b]</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">Tree</span></code> type we’re referring to here is a rose tree; we can take the one defined in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#t:Tree"><code class="sourceCode haskell"><span class="dt">Data.Tree</span></code></a>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    {<span class="ot"> rootLabel ::</span> a</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    ,<span class="ot"> subForest ::</span> [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    }</a></code></pre></div>
<p>Finally, instead of solving the (somewhat intermediate) problem of traversing a forest, we’ll look directly at traversing the tree itself. In other words, our solution should have the type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a></code></pre></div>
<h1 id="breadth-first-enumeration">Breadth-First Enumeration</h1>
<p>As in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>, let’s first look at just converting the tree to a list in breadth-first order. In other words, given the tree:</p>
<pre><code>   ┌3
 ┌2┤
 │ └4
1┤
 │ ┌6
 └5┤
   └7</code></pre>
<p>We want the list:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]</a></code></pre></div>
<p>Last time I looked at this problem, the function I arrived at was as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">breadthFirstEnumerate ts <span class="fu">=</span> f ts b []</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>It’s admittedly a little difficult to understand, but it’s really not too complex: we’re popping items off the front of a queue, and pushing the subforest onto the end. <code class="sourceCode haskell">fw</code> is the recursive call here: that’s where we send the queue with the element pushed on. Even though it may <em>look</em> like we’re pushing onto the front (as we’re using a cons), this is really the <em>end</em> of the queue, since it’s being consumed in reverse, with <code class="sourceCode haskell">foldl</code>.</p>
<p>We can compare it to the technique used in <span class="citation" data-cites="allison_circular_2006">Allison (<a href="#ref-allison_circular_2006">2006</a>)</span> and <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>, where it’s called <em>corecursive queues</em>. Breadth-first enumeration is accomplished as follows in <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">levelOrder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">levelOrder tr <span class="fu">=</span> map rootLabel qs</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    qs <span class="fu">=</span> enqs [tr] <span class="dv">0</span> qs</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    enqs []     n xs <span class="fu">=</span> deq n xs</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    enqs (t<span class="fu">:</span>ts) n xs <span class="fu">=</span> t <span class="fu">:</span> enqs  ts (n<span class="fu">+</span><span class="dv">1</span>) xs</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    deq <span class="dv">0</span> _      <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    deq n (x<span class="fu">:</span>xs) <span class="fu">=</span> enqs (subForest x) (n<span class="fu">-</span><span class="dv">1</span>) xs</a></code></pre></div>
<p>We get to avoid tracking the length of the queue, however.</p>
<h1 id="level-order-enumeration">Level-Order Enumeration</h1>
<p>Before we go the full way to traversal, we can try add a little structure to our breadth-first enumeration, by delimiting between levels in the tree. We want our function to have the following type:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>Looking back at our example tree:</p>
<pre><code>   ┌3
 ┌2┤
 │ └4
1┤
 │ ┌6
 └5┤
   └7</code></pre>
<p>We now want the list:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]]</a></code></pre></div>
<p>This function is strictly more powerful than <code class="sourceCode haskell">breadthFirstEnumerate</code>, as we can define one in terms of the other:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">breadthFirstEnumerate <span class="fu">=</span> concat <span class="fu">.</span> levels</a></code></pre></div>
<p>It’s also just a generally useful function, so there are several example implementations available online.</p>
<h3 id="iterative-style">Iterative-Style</h3>
<p>The one provided in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/src/Data.Tree.html#levels">Data.Tree</a> is as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">levels t <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    map (map rootLabel) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">        takeWhile (not <span class="fu">.</span> null) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        iterate (concatMap subForest) [t]</a></code></pre></div>
<p>Pretty nice, but it looks to me like it’s doing a lot of redundant work. We could write it as an unfold:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">levels t <span class="fu">=</span>  unfoldr (f <span class="fu">.</span> concat) [[t]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    f [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    f xs <span class="fu">=</span> <span class="dt">Just</span> (unzip [(y,ys) <span class="fu">|</span> <span class="dt">Node</span> y ys <span class="ot">&lt;-</span> xs])</a></code></pre></div>
<p>The performance danger here lies in <code class="sourceCode haskell">unzip</code>: one could potentially optimize that for a speedup.</p>
<h3 id="with-an-implicit-queue">With an (implicit) Queue</h3>
<p>Another definition, in the style of <code class="sourceCode haskell">breadthFirstEnumerate</code> above, is as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">levels ts <span class="fu">=</span> f b ts [] []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<p>Here, we maintain a stack building up the current level, as well as a queue that we send to the next level. Because we’re consing onto the front of the stack, the subforest needs to be traversed in reverse, to build up the output list in the right order. This is why we’re using a second <code class="sourceCode haskell">foldl</code> here, whereas the original had <code class="sourceCode haskell">foldr</code> on the inner loop.</p>
<h3 id="zippy-style">Zippy-Style</h3>
<p>Looking at the implicit queue version, I noticed that it’s just using a church-encoded pair to reverse the direction of the fold. Instead of doing both reversals, we can use a normal pair, and run it in one direction:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">levels ts <span class="fu">=</span> b (f ts ([],[]))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (ls,qs) <span class="fu">=</span> (x<span class="fu">:</span>ls,xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    b (_,[]) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    b (k,qs) <span class="fu">=</span> k <span class="fu">:</span> b (foldr (flip (foldr f)) ([],[]) qs)</a></code></pre></div>
<p>Secondly, we’re running a fold on the second component of the pair: why not run the fold immediately, rather than building the intermediate list. In fact, we’re running a fold over the <em>whole</em> thing, which we can do straight away:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">levels ts <span class="fu">=</span> f ts []</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>After looking at it for a while, I realized it’s similar to an inlined version of the algorithm presented in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">levels t <span class="fu">=</span> [rootLabel t] <span class="fu">:</span> foldr (lzw (<span class="fu">++</span>)) [] (map levels (subForest t))</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    lzw f (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> f x y <span class="fu">:</span> lzw f xs ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    lzw _ xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    lzw _ [] ys <span class="fu">=</span> ys</a></code></pre></div>
<h1 id="cofree">Cofree</h1>
<p>Before going any further, all of the functions so far can be redefined to work on the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Comonad-Cofree.html">cofree comonad</a>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>When <code class="sourceCode haskell">f</code> is specialized to <code class="sourceCode haskell">[]</code>, we get the original rose tree. So far, though, all we actually require is <code class="sourceCode haskell"><span class="dt">Foldable</span></code>.</p>
<p>From now on, then, we’ll use <code class="sourceCode haskell"><span class="dt">Cofree</span></code> instead of <code class="sourceCode haskell"><span class="dt">Tree</span></code>.</p>
<h1 id="traversing">Traversing</h1>
<p>Finally, we can begin on the traversal itself. We know how to execute the effects in the right order, what’s missing is to build the tree back up in the right order.</p>
<h3 id="filling">Filling</h3>
<p>First thing we’ll use is a trick with <code class="sourceCode haskell"><span class="dt">Traversable</span></code>, where we fill a container from a list. In other words:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fill [(),(),(),()] [<span class="dv">1</span><span class="fu">..</span>] <span class="fu">=</span> ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">5</span><span class="fu">..</span>])</a></code></pre></div>
<p>With the state monad (or applicative, in this case, I suppose), we can define a “pop” action, which takes an element from the supply:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">pop <span class="fu">=</span> state (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x,xs))</a></code></pre></div>
<p>And then we <code class="sourceCode haskell">traverse</code> that action over our container:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>When we use fill, it’ll have the following type:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">breadthFirst <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">    fill ::</span> t (<span class="dt">Cofree</span> t a) <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">Cofree</span> t b] (t (<span class="dt">Cofree</span> t b))</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>Hopefully that makes sense: we’re going to get the subforest from here:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> t a <span class="fu">=</span> a <span class="fu">:&lt;</span> t (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">                       <span class="fu">^^^^^^^^^^^^^^</span></a></code></pre></div>
<p>And we’re going to fill it with the result of the traversal, which changes the contents from <code>a</code>s to <code>b</code>s.</p>
<h3 id="composing-applicatives">Composing Applicatives</h3>
<p>One of the nice things about working with applicatives is that they compose, in a variety of different ways. In other words, if I have one effect, <code class="sourceCode haskell">f</code>, and another <code class="sourceCode haskell">g</code>, and I want to run them both on the contents of some list, I can do it in one pass, either by layering the effects, or putting them side-by-side.</p>
<p>In our case, we need to deal with two effects: the one generated by the traversal, (the one the caller wants to use), and the internal state we’re using to fill up the forests in our tree. We could use <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Functor-Compose.html#t:Compose"><code class="sourceCode haskell"><span class="dt">Compose</span></code></a> explicitly, but we can avoid some calls to <code class="sourceCode haskell">pure</code> if we write the combinators we’re going to use directly:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">map2</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">map2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    fmap (\y <span class="ot">-&gt;</span> fmap (f y) xs) x</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">app2</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> g)</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c) <span class="ot">-&gt;</span> f (g d)</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">app2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    liftA2 (\y <span class="ot">-&gt;</span> liftA2 (f y) xs) x</a></code></pre></div>
<p>The outer applicative (<code>f</code>) will be the user’s effect, the inner will be <code>State</code>.</p>
<h1 id="take-1-zippy-style-traversing">Take 1: Zippy-Style Traversing</h1>
<p>First we’ll try convert the zippy-style <code class="sourceCode haskell">levels</code> to a traversal. First, convert the function over to the cofree comonad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">levels tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, instead of building up a list of just the root labels, we’ll pair them with the subforests:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, we’ll fill the subforests:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Then, we can run the applicative effect on the root label:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((c x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(c x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Now, to combine the effects, we can use the combinators we defined before:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>This builds a list containing all of the level-wise traversals of the tree. To collapse them into one, we can use a fold:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">             <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">             <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    head <span class="fu">&lt;$&gt;</span> foldr (liftA2 evalState) (pure []) (f tr [])</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-11" data-line-number="11">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<h1 id="take-2-queue-based-traversing">Take 2: Queue-Based Traversing</h1>
<p>Converting the queue-based implementation is easy once we’ve done it with the zippy one. The result is (to my eye) a little easier to read, also:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    fmap head (f b tr e [])</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">      k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) ls) (xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb31-9" data-line-number="9"></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    b _ [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">    b l qs <span class="fu">=</span> liftA2 evalState l (foldl (foldl f) b qs e [])</a>
<a class="sourceLine" id="cb31-12" data-line-number="12"></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>There are a couple things to notice here: first, we’re not using <code class="sourceCode haskell">map2</code> anywhere. That’s because in the zippy version we were able to notice when the queue was exhausted, so we could just output the singleton effect. Here, instead, we’re using <code class="sourceCode haskell">pure (pure [])</code>: this is potentially a source of inefficiency, as <code class="sourceCode haskell">liftA2 f (pure x) y</code> is less efficient than <code class="sourceCode haskell">fmap (f x) y</code> for some applicatives.</p>
<p>On the other hand, we don’t build up a list of levels to be combined with <code class="sourceCode haskell">foldr (liftA2 evalState)</code> at any point: we combine them at every level immediately. You may be able to do the same in the zippy version, but I haven’t figured it out yet.</p>
<h3 id="yoneda">Yoneda</h3>
<p>The final point to make here is to do with the very last thing we do in the traversal: <code class="sourceCode haskell">fmap head</code>. Strictly speaking, any <code class="sourceCode haskell">fmap</code>s in the code should be unnecessary: we <em>should</em> be able to fuse them all with any call to <code class="sourceCode haskell">liftA2</code>. This transformation is often called the “Yoneda embedding”. We can use it here like so:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot">    ::</span> <span class="ot">∀</span> t a f b<span class="fu">.</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span> f (b head) tr e []</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="ot">    b ::</span> <span class="ot">∀</span> x<span class="fu">.</span> ([<span class="dt">Cofree</span> t b] <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">      <span class="ot">-&gt;</span> f (<span class="dt">State</span> [<span class="dt">Cofree</span> t b] [<span class="dt">Cofree</span> t b])</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">      <span class="ot">-&gt;</span> [t (<span class="dt">Cofree</span> t a)]</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">      <span class="ot">-&gt;</span> f x</a>
<a class="sourceLine" id="cb32-13" data-line-number="13">    b k _ [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    b k l qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-15" data-line-number="15">        liftA2 (\x <span class="ot">-&gt;</span> k <span class="fu">.</span> evalState x) l (foldl (foldl f) (b id) qs e [])</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>Notice that we need scoped type variables here, since the type of <code class="sourceCode haskell">b</code> changes depending on when it’s called.</p>
<h1 id="take-3-iterative-traversing">Take 3: Iterative Traversing</h1>
<p>Transforming the iterative version is slightly different from the other two:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-5" data-line-number="5">        liftA2</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">            evalState</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">            (go (foldr (\(_<span class="fu">:&lt;</span>ys) b <span class="ot">-&gt;</span> foldr (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">    f (x<span class="fu">:&lt;</span>xs) <span class="fu">=</span> <span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs))</a></code></pre></div>
<p>We’re using <code class="sourceCode haskell"><span class="dt">Compose</span></code> directly here, in contrast to the other two algorithms.</p>
<h1 id="comparison">Comparison</h1>
<p>Performance-wise, no one algorithm wins out in every case. For enumeration, the zippy algorithm is the fastest in most cases—except when the tree had a large branching factor; then, the iterative algorithm wins out. For the traversals, the iterative algorithm is usually better—except for monads with more expensive applicative instances.</p>
<p>I’m still not convinced that the zippy traversal is as optimized as it could be, however. If anyone has a better implementation, I’d love to see it!</p>
<h1 id="fusion">Fusion</h1>
<p>Using the composability of applicatives, we can fuse several operations over traversables into one pass. Unfortunately, however, this can often introduce a memory overhead that makes the whole operation slower overall. One such example is the iterative algorithm above:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    go xs <span class="fu">=</span> liftA2 evalState zs (go (ys []))</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">        <span class="dt">Compose</span> (<span class="dt">Endo</span> ys,<span class="dt">Compose</span> zs) <span class="fu">=</span> traverse f xs</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">    f (x <span class="fu">:&lt;</span> xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">        <span class="dt">Compose</span></a>
<a class="sourceLine" id="cb34-9" data-line-number="9">            (<span class="dt">Endo</span> (flip (foldr (<span class="fu">:</span>)) xs)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">            ,<span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs)))</a></code></pre></div>
<p>We only traverse the subforest of each node once now, fusing the fill operation with building the list to send to the recursive call. This is expensive (especially memory-wise), though, and traversing the descendant is cheap; the result is that the one-pass version is slower (in my tests).</p>
<h1 id="generalizing">Generalizing</h1>
<p>The cofree comonad allows us to generalize over the type of “descendants”—from lists (in <code class="sourceCode haskell"><span class="dt">Tree</span></code>) to anything traversable. We could also generalize over the type of the traversal itself: given a way to access the descendants of a node, we should be able to traverse all nodes in a breadth-first order. This kind of thing is usually accomplished by <a href="http://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Plated.html">Plated</a>: it’s a class that gives you a traversal over the immediate descendants of some recursive type. Adapting the iterative version is relatively simple:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">breadthFirstOf ::</span> <span class="dt">Traversal&#39;</span> a a <span class="ot">-&gt;</span> <span class="dt">Traversal&#39;</span> a a</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">breadthFirstOf trav c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">        liftA2</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">            evalState</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb35-9" data-line-number="9">            (go (foldr (\ys b <span class="ot">-&gt;</span> foldrOf trav (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb35-10" data-line-number="10">    f xs <span class="fu">=</span> <span class="dt">Compose</span> (fmap fill (c xs))</a>
<a class="sourceLine" id="cb35-11" data-line-number="11">    fill <span class="fu">=</span> trav (const (<span class="dt">State</span> (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x, xs))))</a></code></pre></div>
<p>We can use this version to get back some of the old functions above:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span>  <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> <span class="dt">Cofree</span> f a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">breadthFirstEnumerate <span class="fu">=</span> toListOf (breadthFirstOf plate <span class="fu">.</span> _extract)</a></code></pre></div>
<h1 id="unfolding">Unfolding</h1>
<p>Building a tree breadth-first, monadically, is still an unsolved problem <span class="citation" data-cites="feuer_is_2015">(it looks like: Feuer <a href="#ref-feuer_is_2015">2015</a>)</span>.</p>
<p>Using some of these we can implement a monadic breadth-first unfold for the cofree comonad:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">unfoldM ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">        <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, t b))</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">        <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">        <span class="ot">-&gt;</span> m (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">unfoldM c tr <span class="fu">=</span> go head [tr]</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">    go k [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">    go k xs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb37-9" data-line-number="9">        ys <span class="ot">&lt;-</span> traverse c xs</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">        go (k <span class="fu">.</span> evalState (traverse f ys)) (toList (<span class="dt">Compose</span> (<span class="dt">Compose</span> ys)))</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">    f (x,xs) <span class="fu">=</span> fmap (x<span class="fu">:&lt;</span>) (fill xs)</a></code></pre></div>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. “Circular Programs and Self-Referential Structures.” <em>Software: Practice and Experience</em> 19 (2) (October): 99–109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>. <a href="http://users.monash.edu/~lloyd/tildeFP/1989SPE/" class="uri">http://users.monash.edu/~lloyd/tildeFP/1989SPE/</a>.</p>
</div>
<div id="ref-feuer_is_2015">
<p>Feuer, David. 2015. “Is a lazy, breadth-first monadic rose tree unfold possible?” Question. <em>Stack Overflow</em>. <a href="https://stackoverflow.com/q/27748526" class="uri">https://stackoverflow.com/q/27748526</a>.</p>
</div>
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. “Breadth-First Traversal.” <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. “Lloyd Allison’s Corecursive Queues: Why Continuations Matter.” <em>The Monad.Reader</em> 14 (14) (July): 28. <a href="https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf" class="uri">https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 03 Jun 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Breadth-First Rose Trees: Traversals and the Cofree Comonad</title>
    <link>http://doisinkidney.com/posts/2018-06-01-rose-trees-breadth-first-traversing.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  1, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Breadth-First%20Traversals.html">3-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Trees.html">Trees</a>
    
</div>

<p>I was looking again at the issue of writing breadth-first traversals for rose trees, and in particular the problem explored in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>. The breadth-first traversal here is a traversal in the lensy sense.</p>
<p>First, let’s look back at getting the levels out of the tree. Here’s the old function I arrived at last time:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">levels ts <span class="fu">=</span> foldl f b ts [] []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<p>After wrangling the definition a little, I got to the following (much cleaner) definition:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">levels tr <span class="fu">=</span> f tr [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  f (<span class="dt">Node</span> x xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">:</span>y) <span class="fu">:</span> foldr f ys xs</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<h1 id="cofree">Cofree</h1>
<p>Before going any further, all of the functions so far can be redefined to work on the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Comonad-Cofree.html">cofree comonad</a>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>When <code class="sourceCode haskell">f</code> is specialized to <code class="sourceCode haskell">[]</code>, we get the original rose tree. But what we actually require is much less specific: <code class="sourceCode haskell">levels</code>, for instance, only needs <code class="sourceCode haskell"><span class="dt">Foldable</span></code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">levelsCofree ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Cofree</span> f a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">levelsCofree tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">:</span>y) <span class="fu">:</span> foldr f ys xs</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Using this, we can write the efficient breadth-first traversal:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">breadthFirst c (t<span class="fu">:&lt;</span>ts) <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    liftA2 evalState (map2 (<span class="fu">:&lt;</span>) (c t) (fill ts)) chld</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    chld <span class="fu">=</span> foldr (liftA2 evalState) (pure []) (foldr f [] ts)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    fill <span class="fu">=</span> traverse (const (state (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x,xs))))</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">        <span class="fu">=</span> app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) q</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">        <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    f (x<span class="fu">:&lt;</span>xs) []</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">        <span class="fu">=</span> map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">        <span class="fu">:</span> foldr f [] xs</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    map2 k x xs <span class="fu">=</span> fmap   (\y <span class="ot">-&gt;</span> fmap   (k y) xs) x</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    app2 k x xs <span class="fu">=</span> liftA2 (\y <span class="ot">-&gt;</span> liftA2 (k y) xs) x</a></code></pre></div>
<p>At every level, the subforest’s shape it taken (<code class="sourceCode haskell">fill</code>), and it’s traversed recursively. We can fuse these two steps into one:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a  <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">breadthFirst c (t<span class="fu">:&lt;</span>ts) <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    liftA2</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        evalState</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">        (map2 (<span class="fu">:&lt;</span>) (c t) fill)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        (foldr (liftA2 evalState) (pure []) (chld []))</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    <span class="dt">Compose</span> (<span class="dt">Endo</span> chld,fill) <span class="fu">=</span> go ts</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    go <span class="fu">=</span> traverse (\x <span class="ot">-&gt;</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> (f x), state (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (y,ys))))</a>
<a class="sourceLine" id="cb6-13" data-line-number="13"></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) r q <span class="fu">:</span> rs qs</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">      <span class="kw">where</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> rs,r) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span> map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) r <span class="fu">:</span> rs []</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      <span class="kw">where</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> rs,r) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb6-18" data-line-number="18"></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    map2 k x xs <span class="fu">=</span> fmap   (\y <span class="ot">-&gt;</span> fmap   (k y) xs) x</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    app2 k x xs <span class="fu">=</span> liftA2 (\y <span class="ot">-&gt;</span> liftA2 (k y) xs) x</a></code></pre></div>
<p>The overhead from this approach scraps any benefit, though.</p>
<div id="refs" class="references">
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. “Breadth-First Traversal.” <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 01 Jun 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-06-01-rose-trees-breadth-first-traversing.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Sorting Small Things in Haskell</title>
    <link>http://doisinkidney.com/posts/2018-05-06-sorting-small.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  6, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Sorting.html">1-part series on Sorting</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>I was working on some performance-intensive stuff recently, and I ran into the issue of sorting very small amounts of values (think 3, 4, 5).</p>
<p>The standard way to do this is with <a href="https://en.wikipedia.org/wiki/Sorting_network">sorting networks</a>. The way I’ll be using doesn’t actually perform any parallelism (unfortunately), but it is a clean way to write the networks in Haskell without too much repetition.</p>
<p><a href="http://pages.ripco.net/~jgamble/nw.html">This</a> website will generate an optimal sorting network for your given size, and the output (for 3) looks like this:</p>
<pre><code>[[1,2]]
[[0,2]]
[[0,1]]</code></pre>
<p>Each pair of indices represents a “compare-and-swap” operation: so the first line means “compare the value at 1 to the value at 2: if it’s bigger, swap them”. For 5, the network looks like this:</p>
<pre><code>[[0,1],[2,3]]
[[0,2],[1,3]]
[[1,2],[0,4]]
[[1,4]]
[[2,4]]
[[3,4]]</code></pre>
<p>Pairs on the same line can be performed in parallel.</p>
<p>For our case, I’m going to be looking at sorting tuples, but the technique can easily be generalized to vectors, etc.</p>
<p>The first trick is to figure out how to do “swapping”: we don’t want mutation, so what we can do instead is swap the <em>reference</em> to some value, by shadowing its name. In other words:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">swap2 lte x y <span class="fu">|</span> lte x y <span class="fu">=</span> (x, y)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">              <span class="fu">|</span> otherwise <span class="fu">=</span> (y, x)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a) <span class="ot">-&gt;</span> (a,a,a)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="fu">=</span> <span class="kw">case</span> swap2 lte _1 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      (_1, _2) <span class="ot">-&gt;</span> <span class="kw">case</span> swap2 lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        (_0, _2) <span class="ot">-&gt;</span> <span class="kw">case</span> swap2 lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">          (_0, _1) <span class="ot">-&gt;</span> (_0, _1, _2)</a></code></pre></div>
<p>The indentation is hard to read, though, and wrapping-and-unwrapping tuples makes me nervous about the performance (although it may be inlined). The next step is to <em>church-encode</em> the pairs returned:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">swap2 lte x y k</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="fu">|</span> lte x y <span class="fu">=</span> k x y</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="fu">|</span> otherwise <span class="fu">=</span> k y x</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a) <span class="ot">-&gt;</span> (a,a,a)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="fu">=</span> swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">      swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">      (_0,_1,_2)</a></code></pre></div>
<p>Then, to get this to compile down to efficient code, we can make judicious use of <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#v:inline"><code class="sourceCode haskell">inline</code></a> from GHC.Exts:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">GHC.Exts</span> (inline)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">swap2 lte x y k</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="fu">|</span> inline lte x y <span class="fu">=</span> inline k x y</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="fu">|</span> otherwise <span class="fu">=</span> inline k y x</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">{-# INLINE swap2 #-}</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a, a, a) <span class="ot">-&gt;</span> (a, a, a)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="fu">=</span> swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">      swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">      (_0,_1,_2)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="ot">{-# INLINE sort3 #-}</span></a></code></pre></div>
<p>And to see if this really does make efficient code, let’s look at the core (cleaned up):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">sort3</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="fu">=</span> \ (<span class="ot">lte ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">      (<span class="ot">ds ::</span> (a, a, a)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      <span class="kw">case</span> ds <span class="kw">of</span> wild_X8 (_0, _1, _2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">      <span class="kw">case</span> lte _1 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        <span class="dt">False</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">          <span class="kw">case</span> lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">            <span class="dt">False</span> <span class="ot">-&gt;</span> (_2, _1, _0)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">            <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">              <span class="kw">case</span> lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_2, _0, _1)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">                <span class="dt">True</span> <span class="ot">-&gt;</span> (_0, _2, _1)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">        <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">          <span class="kw">case</span> lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">            <span class="dt">False</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">              <span class="kw">case</span> lte _2 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_1, _2, _0)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">                <span class="dt">True</span> <span class="ot">-&gt;</span> (_2, _1, _0)</a>
<a class="sourceLine" id="cb6-19" data-line-number="19">            <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">              <span class="kw">case</span> lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_1, _0, _2)</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">                <span class="dt">True</span> <span class="ot">-&gt;</span> wild_X8</a></code></pre></div>
<p>Fantastic! When we specialize to <code class="sourceCode haskell"><span class="dt">Int</span></code>, we get all of the proper unpacking:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">sort3Int ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">sort3Int <span class="fu">=</span> inline sort3 (<span class="fu">&lt;=</span>)</a></code></pre></div>
<p>Core (with just the variable names cleaned up this time):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">sort3Int</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="fu">=</span> \ (<span class="ot">w ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">      <span class="kw">case</span> w <span class="kw">of</span> w_X { (_0, _1, _2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      <span class="kw">case</span> _0 <span class="kw">of</span> w_0 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _0U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">case</span> _1 <span class="kw">of</span> w_1 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _1U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="kw">case</span> _2 <span class="kw">of</span> w_2 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _2U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">      <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _1U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            __DEFAULT <span class="ot">-&gt;</span> (w_2, w_1, w_0);</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">            <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">                __DEFAULT <span class="ot">-&gt;</span> (w_2, w_0, w_1);</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> (w_0, w_2, w_1)</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">              }</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">          };</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">          <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">            __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _2U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">                __DEFAULT <span class="ot">-&gt;</span> (w_1, w_2, w_0);</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> (w_2, w_1, w_0)</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">              };</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">            <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">                __DEFAULT <span class="ot">-&gt;</span> (w_1, w_0, w_2);</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> w_X</a>
<a class="sourceLine" id="cb8-28" data-line-number="28">              }</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">          }</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">      }</a>
<a class="sourceLine" id="cb8-31" data-line-number="31">      }</a>
<a class="sourceLine" id="cb8-32" data-line-number="32">      }</a>
<a class="sourceLine" id="cb8-33" data-line-number="33">      }</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">      }</a></code></pre></div>
<p>Now, for the real test: sorting 5-tuples, using the network above.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">sort5 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a,a,a) <span class="ot">-&gt;</span> (a,a,a,a,a)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">sort5 lte (_0,_1,_2,_3,_4)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">=</span> swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">      swap2 lte _2 _3 <span class="fu">$</span> \ _2 _3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">      swap2 lte _1 _3 <span class="fu">$</span> \ _1 _3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">      swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      swap2 lte _0 _4 <span class="fu">$</span> \ _0 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">      swap2 lte _1 _4 <span class="fu">$</span> \ _1 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">      swap2 lte _2 _4 <span class="fu">$</span> \ _2 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">      swap2 lte _3 _4 <span class="fu">$</span> \ _3 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">      (_0,_1,_2,_3,_4)</a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="ot">{-# INLINE sort5 #-}</span></a></code></pre></div>
<p>The core output from this is over 1000 lines long: you can see it (with the variable names cleaned up) <a href="https://gist.github.com/oisdk/ec25d76d918135c4c28777e1b84ead5f">here</a>.</p>
<p>In my benchmarks, these functions are indeed quicker than their counterparts in vector, but I’m not confident in my knowledge of Haskell performance to make much of a strong statement about them.</p>
]]></description>
    <pubDate>Sun, 06 May 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-05-06-sorting-small.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Type-Level Induction in Haskell</title>
    <link>http://doisinkidney.com/posts/2018-05-05-induction.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  5, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>The code from this post is available as a <a href="https://gist.github.com/oisdk/23c430b807c788dd43dc4d986c5fdfdd">gist</a>.</p>
<p>One of the most basic tools for use in type-level programming is the Peano definition of the natural numbers:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> ℕ</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">S</span> ℕ</a></code></pre></div>
<p>Using the new <code class="sourceCode haskell"><span class="dt">TypeFamilyDependencies</span></code> extension, we can parameterize the notion of “size”. I’m going to use the proportion symbol here:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> family (t <span class="ot">∷</span> k) ∝ (n <span class="ot">∷</span> ℕ) <span class="fu">=</span> (a <span class="ot">∷</span> <span class="dt">Type</span>) <span class="fu">|</span> a <span class="ot">→</span> t n k</a></code></pre></div>
<p>Then, we can use it to provide an inductive class on the natural numbers:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Finite</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    induction <span class="ot">∷</span> t ∝ <span class="dt">Z</span> <span class="ot">→</span> (<span class="ot">∀</span> k<span class="fu">.</span> t ∝ k <span class="ot">→</span> t ∝ <span class="dt">S</span> k) <span class="ot">→</span> t ∝ n</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Finite</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    induction z _ <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="ot">{-# inline induction #-}</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span> <span class="dt">Finite</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    induction z s <span class="fu">=</span> s (induction z s)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="ot">{-# inline induction #-}</span></a></code></pre></div>
<p>The <code class="sourceCode haskell">induction</code> function reads as the standard mathematical definition of induction: given a proof (value) of the zero case, and a proof that any proof is true for its successor, we can give you a proof of any finite number.</p>
<p>An added bonus here is that the size of something can usually be resolved at compile-time, so any inductive function on it should also be resolved at compile time.</p>
<p>We can use it to provide the standard instances for basic length-indexed lists:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">        <span class="dt">Nil</span>  <span class="ot">∷</span> <span class="dt">List</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">        (<span class="fu">:-</span>) <span class="ot">∷</span> a <span class="ot">→</span> <span class="dt">List</span> n a <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>Some instances for those lists are easy:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    fmap _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    fmap f (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x <span class="fu">:-</span> fmap f xs</a></code></pre></div>
<p>However, for <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, we need some way to recurse on the size of the list. This is where induction comes in.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> <span class="ch">&#39;(List,a) ∝ n = List n a</span></a></code></pre></div>
<p>This lets us write <code class="sourceCode haskell">pure</code> in a pleasingly simple way:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)</a></code></pre></div>
<p>But can we also write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> using induction? Yes! Because we’ve factored out the induction itself, we just need to describe the notion of a “sized” function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> a ↦ b</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">type</span> <span class="kw">instance</span> ((x <span class="ot">∷</span> a) ↦ (y <span class="ot">∷</span> b)) ∝ n <span class="fu">=</span> (x ∝ n) <span class="ot">→</span> (y ∝ n)</a></code></pre></div>
<p>Then we can write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> as so:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        induction</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">            (\<span class="dt">Nil</span> <span class="dt">Nil</span> <span class="ot">→</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">            (\k (f <span class="fu">:-</span> fs) (x <span class="fu">:-</span> xs) <span class="ot">→</span> f x <span class="fu">:-</span> k fs xs)</a></code></pre></div>
<p>What about the <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance? For that, we need a little bit of plumbing: the type signature of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> is:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">(<span class="fu">&gt;&gt;=</span>) <span class="ot">∷</span> m a <span class="ot">→</span> (a <span class="ot">→</span> m b) <span class="ot">→</span> m b</a></code></pre></div>
<p>One of the parameters (the second <code>a</code>) doesn’t have a size: we’ll need to work around that, with <code class="sourceCode haskell"><span class="dt">Const</span></code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Const</span> a <span class="ot">∷</span> ℕ <span class="ot">→</span> <span class="dt">Type</span>) ∝ n <span class="fu">=</span> <span class="dt">Const</span> a n</a></code></pre></div>
<p>Using this, we can write our <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">head&#39; <span class="ot">∷</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">→</span> a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">head&#39; (x <span class="fu">:-</span> _) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">tail&#39; <span class="ot">∷</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">→</span> <span class="dt">List</span> n a</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">tail&#39; (_ <span class="fu">:-</span> xs) <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">         <span class="dt">Monad</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    xs <span class="fu">&gt;&gt;=</span> (f <span class="ot">∷</span> a <span class="ot">→</span> <span class="dt">List</span> n b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        induction</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">            (\<span class="dt">Nil</span> _ <span class="ot">→</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">            (\k (y <span class="fu">:-</span> ys) fn <span class="ot">→</span> head&#39; (fn (<span class="dt">Const</span> y)) <span class="fu">:-</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">                               k ys (tail&#39; <span class="fu">.</span> fn <span class="fu">.</span> <span class="dt">Const</span> <span class="fu">.</span> getConst))</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">            xs</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">            (f <span class="fu">.</span> getConst <span class="ot">∷</span> <span class="dt">Const</span> a n <span class="ot">→</span> <span class="dt">List</span> n b)</a></code></pre></div>
<h2 id="type-family-dependencies">Type Family Dependencies</h2>
<p>Getting the above to work actually took a surprising amount of work: the crux is that the <code class="sourceCode haskell">∝</code> type family needs to be injective, so the “successor” proof can typecheck. Unfortunately, this means that every type can only have one notion of “size”. What I’d prefer is to be able to pass in a function indicating exactly <em>how</em> to get the size out of a type, that could change depending on the situation. So we could recurse on the first argument of a function, for instance, or just its second, or just the result. This would need either type-level lambdas (which would be cool), or <a href="https://ghc.haskell.org/trac/ghc/ticket/10832">generalized type family dependencies</a>.</p>
]]></description>
    <pubDate>Sat, 05 May 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-05-05-induction.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>5 Cool Things You Can Do With Pattern Synonyms</title>
    <link>http://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 12, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms">Pattern Synonyms</a> is an excellent extension for Haskell. There are some <a href="https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html">very</a> <a href="https://www.schoolofhaskell.com/user/icelandj/Pattern%20synonyms">cool</a> examples of their use out there, and I thought I’d add to the list.</p>
<h1 id="make-things-look-like-lists">Make Things Look Like Lists</h1>
<p>Lists are <em>the</em> fundamental data structure for functional programmers. Unfortunately, once more specialized structures are required, you often have to switch over to an uncomfortable, annoying API which isn’t as pleasant or fun to use as cons and nil. With pattern synonyms, though, that’s not so! For instance, here’s how you would do it with a run-length-encoded list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">ConsN</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">            a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">            (<span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">cons ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">cons x (<span class="dt">ConsN</span> i y ys)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> <span class="dt">ConsN</span> (i<span class="fu">+</span><span class="dv">1</span>) y ys</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">cons x xs <span class="fu">=</span> <span class="dt">ConsN</span> <span class="dv">1</span> x xs</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">uncons ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">uncons (<span class="dt">ConsN</span> <span class="dv">1</span> x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">uncons (<span class="dt">ConsN</span> n x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, <span class="dt">ConsN</span> (n<span class="fu">-</span><span class="dv">1</span>) x xs)</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">pattern<span class="ot"> (:-) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="ot">{-# COMPLETE Nil, (:-) #-}</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">zip<span class="ot"> ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b <span class="ot">-&gt;</span> <span class="dt">List</span> (a,b)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">zip (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> (x,y) <span class="fu">:-</span> zip xs ys</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">zip _ _ <span class="fu">=</span> <span class="dt">Nil</span></a></code></pre></div>
<p>A little more useful would be to do the same with a heap:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">smerge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">smerge <span class="dt">Leaf</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">smerge xs <span class="dt">Leaf</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">smerge h1<span class="fu">@</span>(<span class="dt">Node</span> x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> y ly ry)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Node</span> x (smerge h2 rx) lx</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> y (smerge h1 ry) ly</a>
<a class="sourceLine" id="cb2-11" data-line-number="11"></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">cons x <span class="fu">=</span> smerge (<span class="dt">Node</span> x <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb2-14" data-line-number="14"></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="ot">uncons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">uncons <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">uncons (<span class="dt">Node</span> x l r) <span class="fu">=</span> <span class="dt">Just</span> (x, smerge l r)</a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb2-24" data-line-number="24"><span class="ot">{-# COMPLETE Leaf, (:-) #-}</span></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">sort<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">sort <span class="fu">=</span> go <span class="fu">.</span> foldr (<span class="fu">:-</span>) <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb2-28" data-line-number="28">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">    go <span class="dt">Leaf</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-30" data-line-number="30">    go (x <span class="fu">:-</span> xs) <span class="fu">=</span> x <span class="fu">:</span> go xs</a></code></pre></div>
<p>In fact, this pattern can be generalized, so <em>any</em> container-like-thing with a cons-like-thing can be modified as you would with lists. You can see the generalization in <a href="https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Cons.html#v::-60-">lens</a>.</p>
<h1 id="retroactively-make-lyah-examples-work">Retroactively Make <a href="http://learnyouahaskell.com">LYAH</a> Examples Work</h1>
<p>One of the most confusing things I remember about learning Haskell early-on was that the vast majority of the Monads examples didn’t work, because they were written pre-transformers. In other words, the state monad was defined like so:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</a></code></pre></div>
<p>But in transformers nowadays (which is where you get <code class="sourceCode haskell"><span class="dt">State</span></code> from if you import it in the normal way), the definition is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span></a></code></pre></div>
<p>This results in some <em>very</em> confusing error messages when you try run example code.</p>
<p>However, we can pretend that the change never happened, with a simple pattern synonym:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">runState xs <span class="fu">=</span> runIdentity <span class="fu">.</span> runStateT xs</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">pattern <span class="dt">State</span><span class="ot"> ::</span> (s <span class="ot">-&gt;</span> (a, s)) <span class="ot">-&gt;</span> <span class="dt">State</span> s a</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">pattern <span class="dt">State</span> x <span class="ot">&lt;-</span> (runState <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="dt">State</span> x <span class="fu">=</span> <span class="dt">StateT</span> (<span class="dt">Identity</span> <span class="fu">.</span> x)</a></code></pre></div>
<h1 id="getting-type-level-numbers-with-an-efficient-runtime-representation">Getting Type-Level Numbers With an Efficient Runtime Representation</h1>
<p>If you want to write type-level proofs on numbers, you’ll probably end up using Peano numerals and singletons:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="ot">plusZeroIsZero ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">plusZeroIsZero <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">plusZeroIsZero (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroIsZero n <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>Pretty cool, right? We can even erase the proof (if we really trust it) using rewrite rules:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">{-# RULES </span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">&quot;plusZeroIsZero&quot; forall n. plusZeroIsZero n = unsafeCoerce Refl</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">#-}</span></a></code></pre></div>
<p>This isn’t <em>ideal</em>, but it’s getting there.</p>
<p>However, if we ever want to use these things at runtime (perhaps as a type-level indication of some data structure’s size), we’re going to rely on the value-level Peano addition, which is bad news.</p>
<p>Not so with pattern synonyms!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> family <span class="dt">The</span><span class="ot"> k ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">class</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k) <span class="kw">where</span><span class="ot"> sing ::</span> <span class="dt">The</span> k (<span class="ot">a ::</span> k)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dt">Natural</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Sing</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    sing <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Sing</span> n <span class="ot">=&gt;</span> <span class="dt">Sing</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    sing <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>) <span class="ot">-&gt;</span> (<span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (<span class="dt">S</span> n)))</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">            succ sing</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"></a>
<a class="sourceLine" id="cb8-17" data-line-number="17"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        <span class="dt">ZZy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        <span class="dt">SSy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"></a>
<a class="sourceLine" id="cb8-21" data-line-number="21"><span class="ot">getNatty ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> n</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">getNatty (<span class="dt">NatSing</span><span class="ot"> n ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n) <span class="fu">=</span> <span class="kw">case</span> n <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">  <span class="dv">0</span> <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">Z</span>) <span class="dt">ZZy</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  _ <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">S</span> m) (<span class="dt">SSy</span> (<span class="dt">NatSing</span> (pred n)))</a>
<a class="sourceLine" id="cb8-25" data-line-number="25"></a>
<a class="sourceLine" id="cb8-26" data-line-number="26">pattern <span class="dt">Zy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">Z</span>) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">pattern <span class="dt">Zy</span> <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">ZZy</span>) <span class="kw">where</span> <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28"></a>
<a class="sourceLine" id="cb8-29" data-line-number="29">pattern <span class="dt">Sy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">S</span> m) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">pattern <span class="dt">Sy</span> x <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">SSy</span> x) <span class="kw">where</span> <span class="dt">Sy</span> (<span class="dt">NatSing</span> x) <span class="fu">=</span> <span class="dt">NatSing</span> (succ x)</a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="ot">{-# COMPLETE Zy, Sy #-}</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32"></a>
<a class="sourceLine" id="cb8-33" data-line-number="33"><span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-34" data-line-number="34">        <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb8-35" data-line-number="35">        <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb8-36" data-line-number="36"></a>
<a class="sourceLine" id="cb8-37" data-line-number="37"><span class="co">-- | Efficient addition, with type-level proof.</span></a>
<a class="sourceLine" id="cb8-38" data-line-number="38"><span class="ot">add ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">add <span class="fu">=</span> (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>)</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">              <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)) (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb8-41" data-line-number="41"></a>
<a class="sourceLine" id="cb8-42" data-line-number="42"><span class="co">-- | Proof on efficient representation.</span></a>
<a class="sourceLine" id="cb8-43" data-line-number="43"><span class="ot">addZeroRight ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb8-44" data-line-number="44">addZeroRight <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb8-45" data-line-number="45">addZeroRight (<span class="dt">Sy</span> n) <span class="fu">=</span> gcastWith (addZeroRight n) <span class="dt">Refl</span></a></code></pre></div>
<p>(unfortunately, incomplete pattern warnings don’t work here)</p>
<h1 id="hide-your-implementations">Hide Your Implementations</h1>
<p>So you’ve got a tree type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Tip</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Bin</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div>
<p>And you’ve spent some time writing a (reasonably difficult) function on the tree:</p>
<details>
<p><summary> Complicated function on the tree </summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">showTree ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">showTree <span class="dt">Tip</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">showTree (<span class="dt">Bin</span> x&#39; ls&#39; rs&#39;) <span class="fu">=</span> go <span class="dt">True</span> id xlen&#39; ls&#39;</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">                          <span class="fu">$</span> showString xshw&#39;</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                          <span class="fu">$</span> endc ls&#39; rs&#39;</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">                          <span class="fu">$</span> showChar <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">                          <span class="fu">$</span> go <span class="dt">False</span> id xlen&#39; rs&#39; <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    xshw&#39; <span class="fu">=</span> show x&#39;</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    xlen&#39; <span class="fu">=</span> length xshw&#39;</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    go _ _ _ <span class="dt">Tip</span> <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    go up k i (<span class="dt">Bin</span> x ls rs) <span class="fu">=</span> branch <span class="dt">True</span> ls</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">                            <span class="fu">.</span> k</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">                            <span class="fu">.</span> pad i</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">                            <span class="fu">.</span> showChar (bool <span class="ch">&#39;└&#39;</span> <span class="ch">&#39;┌&#39;</span> up)</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">                            <span class="fu">.</span> showString xshw</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">                            <span class="fu">.</span> endc ls rs</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">                            <span class="fu">.</span> showChar <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">                            <span class="fu">.</span> branch <span class="dt">False</span> rs</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">        xshw <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">        xlen <span class="fu">=</span> length xshw</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">        branch d</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">          <span class="fu">|</span> d <span class="fu">==</span> up <span class="fu">=</span> go d (k <span class="fu">.</span> pad i) (xlen <span class="fu">+</span> <span class="dv">1</span>) </a>
<a class="sourceLine" id="cb10-26" data-line-number="26">          <span class="fu">|</span> otherwise <span class="fu">=</span> go d (k <span class="fu">.</span> pad i <span class="fu">.</span> showChar <span class="ch">&#39;│&#39;</span>) xlen </a>
<a class="sourceLine" id="cb10-27" data-line-number="27"></a>
<a class="sourceLine" id="cb10-28" data-line-number="28">    endc <span class="dt">Tip</span>    <span class="dt">Tip</span>    <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb10-29" data-line-number="29">    endc <span class="dt">Bin</span> {} <span class="dt">Tip</span>    <span class="fu">=</span> showChar <span class="ch">&#39;┘&#39;</span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30">    endc <span class="dt">Tip</span>    <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;┐&#39;</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31">    endc <span class="dt">Bin</span> {} <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;┤&#39;</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32"></a>
<a class="sourceLine" id="cb10-33" data-line-number="33">    pad <span class="fu">=</span> (<span class="fu">++</span>) <span class="fu">.</span> flip replicate <span class="ch">&#39; &#39;</span></a></code></pre></div>
</details>
<p>But, for some reason or another, you need to add a field to your <code class="sourceCode haskell"><span class="dt">Bin</span></code> constructor, to store the size of the subtree (for instance). Does this function have to change? No! Simply change the tree definition as so:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Tip</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Bin&#39;</span> <span class="dt">Int</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">pattern <span class="dt">Bin</span> x ls rs <span class="ot">&lt;-</span> <span class="dt">Bin&#39;</span> n x ls rs</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="ot">{-# COMPLETE Tip, Bin #-}</span></a></code></pre></div>
<p>And all the old code works!</p>
<p>This gets to the core of pattern synonyms: it’s another tool which we can use to separate implementation from API.</p>
<h1 id="better-smart-constructors">Better Smart Constructors</h1>
<p>Say you’ve got a data type that has certain constraints on what values it can hold. You’re not writing a paper for ICFP, so expressing those constraints as a beautiful type isn’t required: you just want to only export the constructor and accessors, and write some tests to make sure that those functions always obey the constraints.</p>
<p>But once you do this you’ve lost something: pattern-matching. Let’s get it back with pattern synonyms!</p>
<p>As our simple example, our constraint is going to be “A list where the values are always ordered”:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> {<span class="ot"> getList ::</span> [a] }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">cons x (<span class="dt">List</span> xs) <span class="fu">=</span> <span class="dt">List</span> (insert x xs)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (<span class="dt">List</span> (x<span class="fu">:</span>xs))</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">pattern <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">List</span> []</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="ot">{-# COMPLETE Nil, (:-) #-}</span></a></code></pre></div>
]]></description>
    <pubDate>Thu, 12 Apr 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Countdown</title>
    <link>http://doisinkidney.com/posts/2018-03-20-countdown.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>There’s a popular UK TV show called <a href="https://en.wikipedia.org/wiki/Countdown_(game_show)">Countdown</a> with a round where contestants have to get as close to some target number as possible by constructing an arithmetic expression from six random numbers.</p>
<p>You don’t have to use all of the numbers, and you’re allowed use four operations: addition, subtraction, multiplication, and division. Additionally, each stage of the calculation must result in a positive integer.</p>
<p>Here’s an example. Try get to the target 586:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>,</mo><mn>25</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">100,25,1,5,3,10</annotation></semantics></math></p>
<p>On the show, contestants get 30 seconds to think of an answer.</p>
<details>
<summary> Solution </summary> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn><mo>+</mo><mn>100</mn><mo>*</mo><mn>5</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10 + 100 * 5 + 1</annotation></semantics></math>
</details>
<p>Solving it in Haskell was first explored in depth in <span class="citation" data-cites="hutton_countdown_2002">Hutton (<a href="#ref-hutton_countdown_2002">2002</a>)</span>. There, a basic “generate-and-test” implementation was provided and proven correct.</p>
<p>As an optimization problem, there are several factors which will influence the choice of algorithm:</p>
<ol type="1">
<li>There’s no obvious heuristic for constructing subexpressions in order to get to a final result. In other words, if we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>*</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 * 10</annotation></semantics></math>, there’s no easy way to tell which is “closer” to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>586</mn><annotation encoding="application/x-tex">586</annotation></semantics></math>. The latter is closer numerically, but the former is what we ended up using in the solution.</li>
<li>Because certain subexpressions aren’t allowed, we’ll be able to prune the search space as we go.</li>
<li>Ideally, we’d only want to calculate each possible subexpression once, making it a pretty standard dynamic programming problem.</li>
</ol>
<p>I’ll be focusing on the third point in this post, but we can add the second point in at the end. First, however, let’s write a naive implementation.</p>
<h2 id="generating-all-expressions">Generating all Expressions</h2>
<p>I can’t think of a simpler way to solve the problem than generate-and-test, so we’ll work from there. Testing is easy (<code class="sourceCode haskell">(target <span class="fu">==</span>) <span class="fu">.</span> eval</code>), so we’ll focus on generation. The core function we’ll use for this is usually called “unmerges”:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">unmerges [x,y] <span class="fu">=</span> [([x],[y])]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">unmerges (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    ([x],xs) <span class="fu">:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    concat</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">        [ [(x<span class="fu">:</span>ys,zs),(ys,x<span class="fu">:</span>zs)]</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">        <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs ]</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">unmerges _ <span class="fu">=</span> []</a></code></pre></div>
<p>It generates all possible 2-partitions of a list, ignoring order:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> unmerges <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">[(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;bc&quot;</span>),(<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;c&quot;</span>),(<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ac&quot;</span>)]</a></code></pre></div>
<p>I haven’t looked much into how to optimize this function or make it nicer, as we’ll be swapping it out later.</p>
<p>Next, we need to make the recursive calls:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">allExprs ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">allExprs _ [x] <span class="fu">=</span> [x]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">allExprs c xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    [ e</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    , y <span class="ot">&lt;-</span> allExprs c ys</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    , z <span class="ot">&lt;-</span> allExprs c zs</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    , e <span class="ot">&lt;-</span> c y z ]</a></code></pre></div>
<p>Finally, using the <a href="https://hackage.haskell.org/package/simple-reflect">simple-reflect</a> library, we can take a look at the output:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y,x<span class="fu">*</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">[<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>,<span class="dv">1</span> <span class="fu">*</span> <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">[<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>),<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>,<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>)]</a></code></pre></div>
<p>Even at this early stage, we can actually already write a rudimentary solution:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">countdown ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">countdown xs targ <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    filter</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">        ((<span class="fu">==</span>) targ <span class="fu">.</span> toInteger)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">        (allExprs</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">             (\x y <span class="ot">-&gt;</span> [x,y,x<span class="fu">+</span>y,x<span class="fu">*</span>y])</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">             (map fromInteger xs))</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> mapM_ print (countdown [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>] <span class="dv">586</span>)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-17" data-line-number="17"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-21" data-line-number="21"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-22" data-line-number="22"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-24" data-line-number="24"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))</a></code></pre></div>
<p>As you can see from the output, there’s a lot of repetition. We’ll need to do some memoization to speed it up.</p>
<h2 id="pure-memoization">Pure Memoization</h2>
<p>The normal way most programmers think about “memoization” is something like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1">memo_dict <span class="op">=</span> {<span class="dv">0</span>:<span class="dv">0</span>,<span class="dv">1</span>:<span class="dv">1</span>}</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">def</span> fib(n):</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="cf">if</span> n <span class="kw">in</span> memo_dict:</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="cf">return</span> memo_dict[n]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">        res <span class="op">=</span> fib(n<span class="dv">-1</span>) <span class="op">+</span> fib(n<span class="dv">-2</span>)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        memo_dict[n] <span class="op">=</span> res</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="cf">return</span> res</a></code></pre></div>
<p>In other words, it’s a fundamentally stateful process. We need to mutate some mapping when we haven’t seen the argument before.</p>
<p>Using laziness, though, we can emulate the same behavior purely. Instead of mutating the mapping on function calls, we fill the whole thing at the beginning, and then index into it. As long as the mapping is lazy, it’ll only evaluate the function calls when they’re needed. We could use lists as our mapping to the natural numbers:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> map fib [<span class="dv">2</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">fib n <span class="fu">=</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">2</span>)</a></code></pre></div>
<p>The benefit here is that we avoid the extra work of redundant calls. However, we pay for the speedup in three ways:</p>
<ol class="example" type="1">
<li>Space: we need to take up memory space storing the cached solutions.</li>
<li>Indexing: while we no longer have to pay for the expensive recursive calls, we <em>do</em> now have to pay for indexing into the data structure. In this example, we’re paying linear time to index into the list.</li>
<li>Generality: the memoization is tied directly to the argument type to the function. We need to be able to use the argument to our memoized function as an index into some data structure. While a lot of argument types admit some type of indexing (whether they’re <code class="sourceCode haskell"><span class="dt">Hashable</span></code>, <code class="sourceCode haskell"><span class="dt">Ord</span></code>, etc.), some don’t, and we can’t memoize those using this technique.</li>
</ol>
<p>We’re going to look at a technique that allow us to somewhat mitigate 2 and 3 above, using something called a <em>nexus</em>.</p>
<h2 id="nexuses">Nexuses</h2>
<p>The standard technique of memoization is focused on the arguments to the function, creating a concrete representation of them in memory to map to the results. Using nexuses, as described in <span class="citation" data-cites="bird_functional_2003">Bird and Hinze (<a href="#ref-bird_functional_2003">2003</a>)</span>, we’ll instead focus on the function itself, creating a concrete representation of its call graph in memory. Here’s the call graph of Fibonacci:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">                                            ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">                                   ┌fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">                                   │        └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">                          ┌fib(<span class="dv">3</span>)<span class="fu">=</span>2┤</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">                          │        └fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                 ┌fib(<span class="dv">4</span>)<span class="fu">=</span>3┤</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                 │        │        ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                 │        └fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">                 │                 └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">        ┌fib(<span class="dv">5</span>)<span class="fu">=</span>5┤</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        │        │                 ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        │        │        ┌fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        │        │        │        └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        │        └fib(<span class="dv">3</span>)<span class="fu">=</span>2┤</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        │                 └fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">fib(<span class="dv">6</span>)<span class="fu">=</span>8┤</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        │                          ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        │                 ┌fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        │                 │        └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">        │        ┌fib(<span class="dv">3</span>)<span class="fu">=</span>2┤</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">        │        │        └fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">        └fib(<span class="dv">4</span>)<span class="fu">=</span>3┤</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">                 │        ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">                 └fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">                          └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a></code></pre></div>
<p>Turning <em>that</em> into a concrete datatype wouldn’t do us much good: it still has the massively redundant computations in it. However, we can recognize that entire subtrees are duplicates of each other: in those cases, instead of creating both subtrees, we could just create one and have each parent point to it<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">        ┌fib(<span class="dv">5</span>)<span class="fu">=</span>5┬────────┬fib(<span class="dv">3</span>)<span class="fu">=</span>2┬────────┬fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">fib(<span class="dv">6</span>)<span class="fu">=</span>8┤        │        │        │        │</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">        └────────┴fib(<span class="dv">4</span>)<span class="fu">=</span>3┴────────┴fib(<span class="dv">2</span>)<span class="fu">=</span>1┴fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a></code></pre></div>
<p>This is a nexus. In Haskell, it’s not observably different from the other form, except that it takes up significantly less space. It’s also much quicker to construct.</p>
<p>If we use it to memoize <code class="sourceCode haskell">fib</code>, we’ll no longer be indexing on the argument: we’ll instead follow the relevant branch in the tree to the subcomputation, which is just chasing a pointer. It also means the argument doesn’t have to be constrained to any specific type. Here’s how you’d do it:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    {<span class="ot"> val   ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    ,<span class="ot"> left  ::</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    ,<span class="ot"> right ::</span> <span class="dt">Tree</span>}</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">fib ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">fib <span class="fu">=</span> val <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    go <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    go <span class="dv">1</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">1</span> (<span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>) <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    go n <span class="fu">=</span> node t (left t) <span class="kw">where</span> t <span class="fu">=</span> go (n<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    node l r <span class="fu">=</span> <span class="dt">Node</span> (val l <span class="fu">+</span> val r) l r</a></code></pre></div>
<p>So this approach sounds amazing, right? No constraints on the argument type, no need to pay for indexing: why doesn’t everyone use it everywhere? The main reason is that figuring out a nexus for the call-graph is <em>hard</em>. In fact, finding an optimal one is NP-hard in general <span class="citation" data-cites="steffen_table_2006">(Steffen and Giegerich <a href="#ref-steffen_table_2006">2006</a>)</span>.</p>
<p>The second problem is that it’s difficult to abstract out. The standard technique of memoization relies on building a mapping from keys to values: about as bread-and-butter as it gets in programming. Even more, we already know how to say “values of this type can be used efficiently as keys in some mapping”: for Data.Map it’s <code class="sourceCode haskell"><span class="dt">Ord</span></code>, for Data.HashMap it’s <code class="sourceCode haskell"><span class="dt">Hashable</span></code>. All of this together means we can build a nice library for memoization which exports the two following functions:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">memoHash ::</span> <span class="dt">Hashable</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">memoOrd ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</a></code></pre></div>
<p>Building a nexus, however, is not bread-and-butter. On top of that, it’s difficult to say something like “recursive functions of this structure can be constructed using a nexus”. What’s the typeclass for that? In comparison to the signatures above, the constraint will need to be on the <em>arrows</em>, not the <code class="sourceCode haskell">a</code>. Even talking about the structure of recursive functions is regarded as somewhat of an advanced subject: that said, the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> package allows us to do so, and even has facilities for constructing something <em>like</em> nexuses with histomorphisms <span class="citation" data-cites="tobin_time_2016">(Tobin <a href="#ref-tobin_time_2016">2016</a>)</span>. I’m still looking to see if there’s a library out there that <em>does</em> manage to abstract nexuses in an ergonomic way, so I’d love to hear if there was one (or if there’s some more generalized form which accomplishes the same).</p>
<h2 id="memoizing-countdown">Memoizing Countdown</h2>
<p>That’s enough preamble. The nexus we want to construct for countdown is <em>not</em> going to memoize as much as possible: in particular, we’re only going to memoize the shape of the trees, not the operators used. This will massively reduce the memory overhead, and still give a decent speedup <span class="citation" data-cites="bird_countdown:_2005">(Bird and Mu <a href="#ref-bird_countdown:_2005">2005</a>, 11 “building a skeleton tree first”)</span>.</p>
<p>With that in mind, the ideal nexus looks something like this:</p>
<p><img src="/images/boolean-lattice.svg" /></p>
<p>We can represent the tree in Haskell as a rose tree:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    {<span class="ot"> root   ::</span> a</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</a></code></pre></div>
<p>Constructing the nexus itself isn’t actually the most interesting part of this solution: <em>consuming</em> it is. We need to be able to go from the structure above into a list that’s the equivalent of <code class="sourceCode haskell">unmerges</code>. Doing a breadth-first traversal of the diagram above (without the top element) will give us:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi><mo>,</mo><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd, ab, ac, bc, ad, bd, cd, a, b, c, d</annotation></semantics></math></p>
<p>If you split that list in half, and zip it with its reverse, you’ll get the output of <code class="sourceCode haskell">unmerges</code>.</p>
<p>However, the breadth-first traversal of the diagram isn’t the same thing as the breadth-first traversal of the rose tree. The latter will traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd</annotation></semantics></math>, and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">ab,ac,bc</annotation></semantics></math>), and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ab,ad,bd</annotation></semantics></math>): and here’s our problem. We traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math> twice, because we can’t know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> are pointing to the same value. What we have to do is first prune the tree, removing duplicates, and then perform a breadth-first traversal on that.</p>
<h3 id="pruning">Pruning</h3>
<p>Luckily, the duplicates follow a pattern, allowing us to remove them without having to do any equality checking. In each row, the first node has no duplicates in its children, the second’s first child is a duplicate, the third’s first and second children are duplicates, and so on. You should be able to see this in the diagram above. Adapting a little from the paper, we get an algorithm like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">para ::</span> (a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">para f b <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    go [] <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    go (x<span class="fu">:</span>xs) <span class="fu">=</span> f x xs (go xs)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ot">prune ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">prune ts <span class="fu">=</span> pruneAt ts <span class="dv">0</span> </a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    pruneAt <span class="fu">=</span> para f (const [])</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    f (<span class="dt">Node</span> x []) t _ _ <span class="fu">=</span> <span class="dt">Node</span> x [] <span class="fu">:</span> t</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    f (<span class="dt">Node</span> x us) _ a k <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">        <span class="dt">Node</span> x (pruneAt (drop k us) k) <span class="fu">:</span> a (k <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<h3 id="breadth-first-traversal">Breadth-First Traversal</h3>
<p>I went through this in a <a href="/posts/2018-03-17-rose-trees-breadth-first.html">previous post</a>, so this is the end solution:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">breadthFirst ts <span class="fu">=</span> foldr f b ts []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs<span class="fu">:</span>bw)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    b q <span class="fu">=</span> foldl (foldr f) b q []</a></code></pre></div>
<p>With the appropriate incantations, this is actually the fastest implementation I’ve found.</p>
<h3 id="fusing">Fusing</h3>
<p>We can actually inline both of the above functions, fusing them together:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">spanNexus ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">spanNexus ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    f (<span class="dt">Node</span> x us) fw k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k<span class="fu">+</span><span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []</a></code></pre></div>
<h3 id="halving-convolving-and-folding">Halving, Convolving, and Folding</h3>
<p>So, now we can go from the tree to our list of splits. Next step is to convert that list into the output of unmerges, by zipping the reverse of the first half with the second. We can use an algorithm described in <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> to do the zipping and reversing:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">fold xs n <span class="fu">=</span> go xs n (const [])</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    go xs <span class="dv">0</span>     k <span class="fu">=</span> k xs</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    go (x<span class="fu">:</span>xs) n k <span class="fu">=</span> go xs (n<span class="fu">-</span><span class="dv">2</span>) (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> k ys)</a></code></pre></div>
<p>And we can inline the function which collapses those results into one:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fold xs n <span class="fu">=</span> go xs n (const [])</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    go <span class="dv">0</span> xss k <span class="fu">=</span> k xss</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go n (xs<span class="fu">:</span>xss) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">        go (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">                                      <span class="fu">|</span> x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">                                      , y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">                                      , z <span class="ot">&lt;-</span> cmb x y</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">                                      ] <span class="fu">++</span> k yss)</a></code></pre></div>
<p>And that’s all we need!</p>
<details>
<p><summary> Full Code </summary></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Tree</span> <span class="kw">as</span> <span class="dt">Rose</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Int</span> a</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">Node</span> [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">Functor</span>)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="ot">enumerateTrees ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">enumerateTrees _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">enumerateTrees cmb xs <span class="fu">=</span> (extract <span class="fu">.</span> steps <span class="fu">.</span> initial) xs</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    step <span class="fu">=</span> map nodes <span class="fu">.</span> group</a>
<a class="sourceLine" id="cb20-13" data-line-number="13"></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    steps [x] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    steps xs <span class="fu">=</span> steps (step xs)</a>
<a class="sourceLine" id="cb20-16" data-line-number="16"></a>
<a class="sourceLine" id="cb20-17" data-line-number="17">    initial <span class="fu">=</span> map (<span class="dt">Leaf</span> <span class="dv">1</span> <span class="fu">.</span> flip <span class="dt">Rose.Node</span> [] <span class="fu">.</span> pure)</a>
<a class="sourceLine" id="cb20-18" data-line-number="18"></a>
<a class="sourceLine" id="cb20-19" data-line-number="19">    extract (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> Rose.rootLabel x</a>
<a class="sourceLine" id="cb20-20" data-line-number="20">    extract (<span class="dt">Node</span> [x]) <span class="fu">=</span> extract x</a>
<a class="sourceLine" id="cb20-21" data-line-number="21"></a>
<a class="sourceLine" id="cb20-22" data-line-number="22">    group [_] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-23" data-line-number="23">    group (<span class="dt">Leaf</span> _ x<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> [<span class="dt">Leaf</span> <span class="dv">2</span> [x, y] <span class="fu">|</span> <span class="dt">Leaf</span> _ y <span class="ot">&lt;-</span> vs] <span class="fu">:</span> group vs</a>
<a class="sourceLine" id="cb20-24" data-line-number="24">    group (<span class="dt">Node</span>   u<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb (group u) vs) <span class="fu">:</span> group vs</a>
<a class="sourceLine" id="cb20-25" data-line-number="25"></a>
<a class="sourceLine" id="cb20-26" data-line-number="26">    comb (<span class="dt">Leaf</span> n xs) (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> <span class="dt">Leaf</span> (n <span class="fu">+</span> <span class="dv">1</span>) (xs <span class="fu">++</span> [x])</a>
<a class="sourceLine" id="cb20-27" data-line-number="27">    comb (<span class="dt">Node</span> us) (<span class="dt">Node</span> vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb us vs)</a>
<a class="sourceLine" id="cb20-28" data-line-number="28"></a>
<a class="sourceLine" id="cb20-29" data-line-number="29">    forest ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []</a>
<a class="sourceLine" id="cb20-30" data-line-number="30">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-31" data-line-number="31">        f (<span class="dt">Rose.Node</span> x []) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) bw</a>
<a class="sourceLine" id="cb20-32" data-line-number="32">        f (<span class="dt">Rose.Node</span> x us) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb20-33" data-line-number="33"></a>
<a class="sourceLine" id="cb20-34" data-line-number="34">        b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-35" data-line-number="35">        b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []</a>
<a class="sourceLine" id="cb20-36" data-line-number="36"></a>
<a class="sourceLine" id="cb20-37" data-line-number="37">    nodes (<span class="dt">Leaf</span> n x) <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dv">1</span> (node n x)</a>
<a class="sourceLine" id="cb20-38" data-line-number="38">    nodes (<span class="dt">Node</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (map nodes xs)</a>
<a class="sourceLine" id="cb20-39" data-line-number="39"></a>
<a class="sourceLine" id="cb20-40" data-line-number="40">    node n ts <span class="fu">=</span> <span class="dt">Rose.Node</span> (walk (<span class="dv">2</span> <span class="fu">^</span> n <span class="fu">-</span> <span class="dv">2</span>) (forest ts) (const [])) ts</a>
<a class="sourceLine" id="cb20-41" data-line-number="41">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-42" data-line-number="42">        walk <span class="dv">0</span> xss k <span class="fu">=</span> k xss</a>
<a class="sourceLine" id="cb20-43" data-line-number="43">        walk n (xs<span class="fu">:</span>xss) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-44" data-line-number="44">            walk (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z</a>
<a class="sourceLine" id="cb20-45" data-line-number="45">                                         <span class="fu">|</span> x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb20-46" data-line-number="46">                                         , y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb20-47" data-line-number="47">                                         , z <span class="ot">&lt;-</span> cmb x y</a>
<a class="sourceLine" id="cb20-48" data-line-number="48">                                         ] <span class="fu">++</span> k yss)</a></code></pre></div>
</details>
<h2 id="using-it-for-countdown">Using it for Countdown</h2>
<p>The first thing to do for the Countdown solution is to figure out a representation for expressions. The one from simple-reflect is perfect for displaying the result, but we should memoize its calculation.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  {<span class="ot"> expr   ::</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  ,<span class="ot"> result ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  }</a></code></pre></div>
<p>Then, some helpers for building:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Op</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Dif</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="fu">|</span> <span class="dt">Div</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">binOp f g x y <span class="fu">=</span> <span class="dt">Memoed</span> ((f <span class="ot">`on`</span> expr) x y) ((g <span class="ot">`on`</span> result) x y)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="ot">apply ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">apply <span class="dt">Add</span> x y <span class="fu">=</span> binOp (<span class="fu">+</span>) (<span class="fu">+</span>) x y</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">apply <span class="dt">Dif</span> x y</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  <span class="fu">|</span> result y <span class="fu">&lt;</span> result x <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) x y</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">  <span class="fu">|</span> otherwise <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) y x</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">apply <span class="dt">Mul</span> x y <span class="fu">=</span> binOp (<span class="fu">*</span>) (<span class="fu">*</span>) x y</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">apply <span class="dt">Div</span> x y <span class="fu">=</span> binOp div div x y</a></code></pre></div>
<p>Finally, the full algorithm:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">enumerateExprs ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Memoed</span>]</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">enumerateExprs <span class="fu">=</span> enumerateTrees cmb <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="dt">Memoed</span> (fromIntegral x) x)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    cmb x y <span class="fu">=</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">        nubs <span class="fu">$</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">        x <span class="fu">:</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">        y <span class="fu">:</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8">        [ apply op x y</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">        <span class="fu">|</span> op <span class="ot">&lt;-</span> [<span class="dt">Add</span>, <span class="dt">Dif</span>, <span class="dt">Mul</span>, <span class="dt">Div</span>]</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">        , legal op (result x) (result y) ]</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    legal <span class="dt">Add</span> _ _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">    legal <span class="dt">Dif</span> x y <span class="fu">=</span> x <span class="fu">/=</span> y</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    legal <span class="dt">Mul</span> _ _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    legal <span class="dt">Div</span> x y <span class="fu">=</span> x <span class="ot">`mod`</span> y <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">    nubs xs <span class="fu">=</span> foldr f (const []) xs IntSet.empty</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17">        f e a s</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">          <span class="fu">|</span> IntSet.member (result e) s <span class="fu">=</span> a s</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">          <span class="fu">|</span> otherwise <span class="fu">=</span> e <span class="fu">:</span> a (IntSet.insert (result e) s)</a>
<a class="sourceLine" id="cb23-20" data-line-number="20"></a>
<a class="sourceLine" id="cb23-21" data-line-number="21"><span class="ot">countdown ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">countdown targ <span class="fu">=</span> map expr <span class="fu">.</span> filter ((<span class="fu">==</span>) targ <span class="fu">.</span> result) <span class="fu">.</span> enumerateExprs</a>
<a class="sourceLine" id="cb23-23" data-line-number="23"></a>
<a class="sourceLine" id="cb23-24" data-line-number="24"><span class="fu">&gt;&gt;&gt;</span> (mapM_ print <span class="fu">.</span> reduction <span class="fu">.</span> head) (countdown <span class="dv">586</span> [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>])</a>
<a class="sourceLine" id="cb23-25" data-line-number="25"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-26" data-line-number="26"><span class="dv">75</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-27" data-line-number="27"><span class="dv">76</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-28" data-line-number="28"><span class="dv">76</span> <span class="fu">+</span> (<span class="dv">500</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-29" data-line-number="29"><span class="dv">76</span> <span class="fu">+</span> <span class="dv">510</span></a>
<a class="sourceLine" id="cb23-30" data-line-number="30"><span class="dv">586</span></a></code></pre></div>
<p>There are some optimizations going on here, taken mainly from <span class="citation" data-cites="bird_countdown:_2005">Bird and Mu (<a href="#ref-bird_countdown:_2005">2005</a>)</span>:</p>
<ol type="1">
<li>We filter out illegal operations, as described originally.</li>
<li>We filter out any expressions that have the same value.</li>
</ol>
<h2 id="testing-the-implementation">Testing the Implementation</h2>
<p>So we’ve followed the paper, written the code: time to test. The specification of the function is relatively simple: calculate all applications of the commutative operator to some input, <em>without</em> recalculating subtrees.</p>
<p>We’ll need a free structure for the “commutative operator”:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="kw">deriving</span> (<span class="dt">Foldable</span>,<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>)</a></code></pre></div>
<p>Here’s the problem: it’s not commutative! We can remedy it by only exporting a constructor that creates the tree in a commutative way, and we can make it a pattern synonym so it looks normal:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveFoldable  #-}</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="kw">module</span> <span class="dt">Commutative</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  (<span class="dt">Tree</span>(<span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  ,pattern (<span class="fu">:*:</span>))</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Foldable</span>)</a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">pattern<span class="ot"> (:*:) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">pattern xs <span class="fu">:*:</span> ys <span class="ot">&lt;-</span> xs <span class="fu">:^:</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  xs <span class="fu">:*:</span> ys</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">      <span class="fu">|</span> xs <span class="fu">&lt;=</span> ys <span class="fu">=</span> xs <span class="fu">:^:</span> ys</a>
<a class="sourceLine" id="cb25-18" data-line-number="18">      <span class="fu">|</span> otherwise <span class="fu">=</span> ys <span class="fu">:^:</span> xs</a>
<a class="sourceLine" id="cb25-19" data-line-number="19"></a>
<a class="sourceLine" id="cb25-20" data-line-number="20"><span class="ot">{-# COMPLETE Leaf, (:*:) #-}</span></a></code></pre></div>
<p>Now we need to check if all applications are actually tested. First, to generate all trees:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">allTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">allTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">allTrees xs <span class="fu">=</span> Set.unions (map (uncurry f) (unmerges xs))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    f ls rs <span class="fu">=</span> Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> (Set.toList <span class="fu">.</span> allTrees)) ls rs)</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"><span class="ot">allSubTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">allSubTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">allSubTrees xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">    Set.unions (map (uncurry f <span class="fu">.</span> (allSubTrees <span class="fu">***</span> allSubTrees)) (unmerges xs))</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-12" data-line-number="12">    f ls rs <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">        Set.unions</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">            [ls, rs, Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> Set.toList) ls rs)]</a></code></pre></div>
<p>Then, to test:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">prop_exhaustiveSearch ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">prop_exhaustiveSearch n <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">             expect <span class="fu">=</span> allSubTrees src</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">             actual <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">                 Set.fromList</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">                     (enumerateTrees</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">                          (\xs ys <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9">                                [xs, ys, xs <span class="fu">:*:</span> ys])</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">                          (map <span class="dt">Leaf</span> src))</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">         <span class="kw">in</span> expect <span class="fu">==</span> actual</a>
<a class="sourceLine" id="cb27-12" data-line-number="12"></a>
<a class="sourceLine" id="cb27-13" data-line-number="13"><span class="ot">prop_exhaustiveSearchFull ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-14" data-line-number="14">prop_exhaustiveSearchFull n <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-15" data-line-number="15">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]</a>
<a class="sourceLine" id="cb27-16" data-line-number="16">             expect <span class="fu">=</span> Map.fromSet (const <span class="dv">1</span>) (allTrees src)</a>
<a class="sourceLine" id="cb27-17" data-line-number="17">             actual <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-18" data-line-number="18">                 freqs</a>
<a class="sourceLine" id="cb27-19" data-line-number="19">                     (enumerateTrees</a>
<a class="sourceLine" id="cb27-20" data-line-number="20">                          (\xs ys <span class="ot">-&gt;</span> [xs <span class="fu">:*:</span> ys])</a>
<a class="sourceLine" id="cb27-21" data-line-number="21">                          (map <span class="dt">Leaf</span> src))</a>
<a class="sourceLine" id="cb27-22" data-line-number="22">         <span class="kw">in</span> expect <span class="fu">==</span> actual</a></code></pre></div>
<p>Testing for repeated calls is more tricky. Remember, the memoization is supposed to be unobservable: in order to see it, we’re going to have to use some unsafe operations.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">traceSubsequences</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="ot">    ::</span> ((<span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>]) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="ot">-&gt;</span> (<span class="dt">Map</span> (<span class="dt">Tree</span> <span class="dt">Int</span>) <span class="dt">Int</span>, [<span class="dt">Tree</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">traceSubsequences enm ints <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    runST <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-7" data-line-number="7">    <span class="kw">do</span> ref <span class="ot">&lt;-</span> newSTRef Map.empty</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">       <span class="kw">let</span> res <span class="fu">=</span> enm (combine ref) (map (conv ref) ints)</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">       traverse_ (foldr seq (pure ())) res</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">       intm <span class="ot">&lt;-</span> readSTRef ref</a>
<a class="sourceLine" id="cb28-11" data-line-number="11">       pure (intm, res)</a>
<a class="sourceLine" id="cb28-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-13" data-line-number="13">    combine ref xs ys <span class="fu">=</span> unsafeRunST ([xs <span class="fu">:*:</span> ys] <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (xs <span class="fu">:*:</span> ys)))</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">    <span class="ot">{-# NOINLINE combine #-}</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">    conv ref x <span class="fu">=</span> unsafeRunST (<span class="dt">Leaf</span> x <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (<span class="dt">Leaf</span> x)))</a>
<a class="sourceLine" id="cb28-16" data-line-number="16">    <span class="ot">{-# NOINLINE conv #-}</span></a>
<a class="sourceLine" id="cb28-17" data-line-number="17">    unsafeRunST cmp <span class="fu">=</span> unsafePerformIO (unsafeSTToIO cmp)</a>
<a class="sourceLine" id="cb28-18" data-line-number="18"></a>
<a class="sourceLine" id="cb28-19" data-line-number="19"><span class="ot">prop_noRepeatedCalls ::</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb28-20" data-line-number="20">prop_noRepeatedCalls <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-21" data-line-number="21">    property <span class="fu">$</span> sized <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-22" data-line-number="22">    \n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-23" data-line-number="23">         pure <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-24" data-line-number="24">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> n]</a>
<a class="sourceLine" id="cb28-25" data-line-number="25">             (tint,tres) <span class="fu">=</span> fmap freqs (traceSubsequences enumerateTrees src)</a>
<a class="sourceLine" id="cb28-26" data-line-number="26">             (fint,fres) <span class="fu">=</span> fmap freqs (traceSubsequences dummyEnumerate src)</a>
<a class="sourceLine" id="cb28-27" data-line-number="27">         <span class="kw">in</span> counterexample</a>
<a class="sourceLine" id="cb28-28" data-line-number="28">                (mapCompare (freqs (allSubTrees src)) tint)</a>
<a class="sourceLine" id="cb28-29" data-line-number="29">                (all (<span class="dv">1</span> <span class="fu">==</span>) tint) <span class="fu">.&amp;&amp;.</span></a>
<a class="sourceLine" id="cb28-30" data-line-number="30">            counterexample (mapCompare tres fres) (tres <span class="fu">==</span> fres) <span class="fu">.&amp;&amp;.</span></a>
<a class="sourceLine" id="cb28-31" data-line-number="31">            (n <span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">==&gt;</span> tint <span class="fu">/=</span> fint)</a></code></pre></div>
<p>Here, <code class="sourceCode haskell">dummyEnumerate</code> is some method which performs the same task, but <em>doesn’t</em> construct a nexus, so we can ensure that our tests really do catch faulty implementations.</p>
<div id="refs" class="references">
<div id="ref-bird_functional_2003">
<p>Bird, Richard, and Ralf Hinze. 2003. “Functional Pearl Trouble Shared is Trouble Halved.” In <em>Proceedings of the 2003 ACM SIGPLAN Workshop on Haskell</em>, 1–6. Haskell ’03. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/871895.871896">10.1145/871895.871896</a>. <a href="http://doi.acm.org/10.1145/871895.871896" class="uri">http://doi.acm.org/10.1145/871895.871896</a>.</p>
</div>
<div id="ref-bird_countdown:_2005">
<p>Bird, Richard, and Shin-Cheng Mu. 2005. “Countdown: A case study in origami programming.” <em>Journal of Functional Programming</em> 15 (05) (August): 679. doi:<a href="https://doi.org/10.1017/S0956796805005642">10.1017/S0956796805005642</a>. <a href="http://www.journals.cambridge.org/abstract_S0956796805005642" class="uri">http://www.journals.cambridge.org/abstract_S0956796805005642</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. “There and Back Again.” <em>BRICS Report Series</em> 12 (3). doi:<a href="https://doi.org/10.7146/brics.v12i3.21869">10.7146/brics.v12i3.21869</a>. <a href="https://tidsskrift.dk/brics/article/view/21869" class="uri">https://tidsskrift.dk/brics/article/view/21869</a>.</p>
</div>
<div id="ref-hutton_countdown_2002">
<p>Hutton, Graham. 2002. “The Countdown Problem.” <em>J. Funct. Program.</em> 12 (6) (November): 609–616. doi:<a href="https://doi.org/10.1017/S0956796801004300">10.1017/S0956796801004300</a>. <a href="http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf" class="uri">http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf</a>.</p>
</div>
<div id="ref-steffen_table_2006">
<p>Steffen, Peter, and Robert Giegerich. 2006. “Table Design in Dynamic Programming.” <em>Information and Computation</em> 204 (9) (September): 1325–1345. doi:<a href="https://doi.org/10.1016/j.ic.2006.02.006">10.1016/j.ic.2006.02.006</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-tobin_time_2016">
<p>Tobin, Jared. 2016. “Time Traveling Recursion Schemes.” <em>jtobin.io</em>. <a href="https://jtobin.io/time-traveling-recursion" class="uri">https://jtobin.io/time-traveling-recursion</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If you think that structure looks more like a funny linked list than a tree, that’s because it is. Instead of talking about “left” and “right” branches, we could talk about the first and second elements in a list: in fact, this is exactly what’s happening in the famous <code class="sourceCode haskell">zipWith</code> Fibonacci implementation (in reverse).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</a></code></pre></div>
<p>Or, in my favourite version:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fib n <span class="fu">=</span> fix ((<span class="fu">:</span>) <span class="dv">0</span> <span class="fu">.</span> scanl (<span class="fu">+</span>) <span class="dv">1</span>) <span class="fu">!!</span> n</a></code></pre></div>
<a href="#fnref1" class="footnote-back">↩</a></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 20 Mar 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-03-20-countdown.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Rose Trees, Breadth-First</title>
    <link>http://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 17, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Breadth-First%20Traversals.html">3-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Trees.html">Trees</a>
    
</div>

<p>In contrast to the more common binary trees, in a rose tree every node can have any number of children.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    {<span class="ot"> root   ::</span> a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</a></code></pre></div>
<p>One of the important manipulations of this data structure, which forms the basis for several other algorithms, is a breadth-first traversal. I’d like to go through a couple of techniques for implementing it, and how more generally you can often get away with using much simpler data structures if you really pinpoint the API you need from them.</p>
<p>As a general technique, <span class="citation" data-cites="okasaki_breadth-first_2000">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span> advises that a queue be used:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">breadthFirst tr <span class="fu">=</span> go (singleton tr)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    go q <span class="fu">=</span> <span class="kw">case</span> pop q <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      <span class="dt">Just</span> (<span class="dt">Node</span> x xs,qs) <span class="ot">-&gt;</span> x <span class="fu">:</span> go (qs <span class="ot">`append`</span> xs)</a></code></pre></div>
<p>There are three functions left undefined there: <code class="sourceCode haskell">singleton</code>, <code class="sourceCode haskell">pop</code>, and <code class="sourceCode haskell">append</code>. They represent the API of our as-of-yet unimplemented queue, and their complexity will dictate the complexity of the overall algorithm. As a (bad) first choice, we could use simple lists, with the functions defined thus:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">singleton x <span class="fu">=</span> [x]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">pop (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x,xs)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">pop [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">append <span class="fu">=</span> (<span class="fu">++</span>)</a></code></pre></div>
<p>Those repeated appends are bad news. The queue needs to be able to support popping from one side and appending from the other, which is something lists absolutely <em>cannot</em> do well.</p>
<p>We could swap in a more general queue implementation, possibly using Data.Sequence, or a pair of lists. But these are more complex and general than we need, so let’s try and pare down the requirements a little more.</p>
<p>First, we don’t need a pop: the go function can be expressed as a fold instead. Second, we don’t need <em>every</em> append to be immediately stuck into the queue, we can batch them, first appending to a structure that’s efficient for appends, and then converting that to a structure which is efficient for folds. In code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">breadthFirst ts <span class="fu">=</span> foldr f b ts []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>We’re consing instead of appending, but the consumption is being done in the correct direction anyway, because of the <code class="sourceCode haskell">foldl</code>.</p>
<h2 id="levels">Levels</h2>
<p>So next step: to get the <code class="sourceCode haskell">levels</code> function from Data.Tree. Instead of doing a breadth-first traversal, it returns the nodes at each <em>level</em> of the tree. Conceptually, every time we did the reverse above (called <code class="sourceCode haskell">foldl</code>), we will do a cons as well:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">levels ts <span class="fu">=</span> foldl f b ts [] []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<h2 id="unfolding">Unfolding</h2>
<p>The original reason I started work on these problems was <a href="https://github.com/haskell/containers/issues/124">this</a> issue in containers. It concerns the <a href="https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#v:unfoldTreeM_BF"><code>unfoldTreeM_BF</code></a> function. An early go at rewriting it, inspired by levels above, looks like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (const id)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    b [] k <span class="fu">=</span> pure (k [] [])</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    b qs k <span class="fu">=</span> foldl (foldr t) b qs [] (\x <span class="ot">-&gt;</span> k [] <span class="fu">.</span> foldr (uncurry run) id x)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    t a fw bw k <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        (x,cs) <span class="ot">&lt;-</span> f a</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="kw">let</span> <span class="fu">!</span>n <span class="fu">=</span> length cs</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        fw (cs <span class="fu">:</span> bw) (k <span class="fu">.</span> (<span class="fu">:</span>) (x, n))</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    run x n xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">      <span class="kw">case</span> splitAt n ys <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">          (cs,zs) <span class="ot">-&gt;</span> <span class="dt">Node</span> x cs <span class="fu">:</span> xs zs</a></code></pre></div>
<p>It basically performs the same this as the levels function, but builds the tree back up in the end using the <code class="sourceCode haskell">run</code> function. In order to do that, we store the length of each subforest on line 9, so that each node knows how much to take from each level.</p>
<p>A possible optimization is to stop taking the length. Anything in list processing that takes a length screams “wrong” to me (although it’s not always true!) so I often try to find a way to avoid it. The first option would be to keep the <code class="sourceCode haskell">cs</code> on line 8 around, and use <em>it</em> as an indicator for the length. That keeps it around longer than strictly necessary, though. The other option is to add a third level: for <code class="sourceCode haskell">breadthFirst</code> above, we had one level; for <code class="sourceCode haskell">levels</code>, we added another, to indicate the structure of the nodes and their subtrees; here, we can add a third, to maintain that structure when building back up:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (\ls <span class="ot">-&gt;</span> concat <span class="fu">.</span> ls)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    b [] k <span class="fu">=</span> pure (k id [])</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    b qs k <span class="fu">=</span> foldl g b qs [] (\ls <span class="ot">-&gt;</span> k id <span class="fu">.</span> ls)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    g a xs qs k <span class="fu">=</span> foldr t (\ls ys <span class="ot">-&gt;</span> a ys (k <span class="fu">.</span> run ls)) xs [] qs</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    t a fw xs bw <span class="fu">=</span> f a <span class="fu">&gt;&gt;=</span> \(x,cs) <span class="ot">-&gt;</span> fw (x<span class="fu">:</span>xs) (cs<span class="fu">:</span>bw)</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    run x xs <span class="fu">=</span> uncurry (<span class="fu">:</span>) <span class="fu">.</span> foldl go ((,) [] <span class="fu">.</span> xs) x</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">        go ys y (z<span class="fu">:</span>zs) <span class="fu">=</span> (<span class="dt">Node</span> y z <span class="fu">:</span> ys&#39;, zs&#39;)</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">            (ys&#39;,zs&#39;) <span class="fu">=</span> ys zs</a></code></pre></div>
<p>This unfortunately <em>slows down</em> the code.</p>
<div id="refs" class="references">
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. “Breadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.” In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131–136. ICFP ’00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>. <a href="https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf" class="uri">https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 17 Mar 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Single-Pass Huffman Coding</title>
    <link>http://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/folds.html">folds</a>
    
</div>

<p>While working on something else, I figured out a nice Haskell implementation of Huffman coding, and I thought I’d share it here. I’ll go through a few techniques for transforming a multi-pass algorithm into a single-pass one first, and then I’ll show how to use them for Huffman. If you just want to skip to the code, it’s provided at the end.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>The algorithm isn’t single-pass in the sense of <a href="https://www2.cs.duke.edu/csed/curious/compression/adaptivehuff.html">Adaptive Huffman Coding</a>: it still uses the normal Huffman algorithm, but the input is transformed in the same traversal that builds the tree to transform it.</p>
<h2 id="circular-programming">Circular Programming</h2>
<p>There are several techniques for turning multi-pass algorithms into single-pass ones in functional languages. Perhaps the most famous is circular programming: using <em>laziness</em> to eliminate a pass. <span class="citation" data-cites="bird_using_1984">Bird (<a href="#ref-bird_using_1984">1984</a>)</span> used this to great effect in solving the repmin problem:</p>
<blockquote>
<p>Given a tree of integers, replace every integer with the minimum integer in the tree, in one pass.</p>
</blockquote>
<p>For an imperative programmer, the problem is relatively easy: first, write the code to find the minimum value in the tree in the standard way, using a loop and a “smallest so far” accumulator. Then, inside the loop, after updating the accumulator, set the value of the leaf to be a <em>reference</em> to the accumulator.</p>
<p>At first, that solution may seem necessarily impure: we’re using global, mutable state to update many things at once. However, as the paper shows, we can claw back purity using laziness:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">repMin ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">repMin xs <span class="fu">=</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  (m, ys) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (x, <span class="dt">Leaf</span> m)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (min x y, xs&#39; <span class="fu">:*:</span> ys&#39;)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      (x,xs&#39;) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      (y,ys&#39;) <span class="fu">=</span> go ys</a></code></pre></div>
<h2 id="there-and-back-again">There and Back Again</h2>
<p>Let’s say we don’t have laziness at our disposal: are we hosed? No!<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> explore this very issue, by posing the question:</p>
<blockquote>
<p>Given two lists, xs and ys, can you zip xs with the reverse of ys in one pass?</p>
</blockquote>
<p>The technique used to solve the problem is named “There and Back Again”; it should be clear why from one of the solutions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">convolve xs ys <span class="fu">=</span> walk xs const <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  walk [] k <span class="fu">=</span> k [] ys</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  walk (x<span class="fu">:</span>xs) k <span class="fu">=</span> walk xs (\r (y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> k ((x,y) <span class="fu">:</span> r) ys)</a></code></pre></div>
<p>The traversal of one list builds up the function to consume the other. We could write repmin in the same way:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">repMin <span class="fu">=</span> uncurry (<span class="fu">$</span>) <span class="fu">.</span> go <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (<span class="dt">Leaf</span>, x)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (\m <span class="ot">-&gt;</span> xs&#39; m <span class="fu">:*:</span> ys&#39; m, min xm ym) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    (xs&#39;,xm) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    (ys&#39;,ym) <span class="fu">=</span> go ys</a></code></pre></div>
<h2 id="cayley-representations">Cayley Representations</h2>
<p>If you’re doing a lot of appending to some list-like structure, you probably don’t want to use actual lists: you’ll end up traversing the left-hand-side of the append many more times than necessary. A type you can drop in to use instead is difference lists <span class="citation" data-cites="hughes_novel_1986">(Hughes <a href="#ref-hughes_novel_1986">1986</a>)</span>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">DList</span> a <span class="fu">=</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">rep ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">DList</span> a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">rep <span class="fu">=</span> (<span class="fu">++</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">abs<span class="ot"> ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">abs xs <span class="fu">=</span> xs []</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">append ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">append <span class="fu">=</span> (<span class="fu">.</span>)</a></code></pre></div>
<p><code class="sourceCode haskell">append</code> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> in this representation. In fact, for any monoid with a slow <code class="sourceCode haskell">mappend</code>, you can use the same trick: it’s called the Cayley representation, and available as <code class="sourceCode haskell"><span class="dt">Endo</span></code> in <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:Endo">Data.Monoid</a>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">rep ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">rep x <span class="fu">=</span> <span class="dt">Endo</span> (mappend x)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">abs<span class="ot"> ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">abs (<span class="dt">Endo</span> f) <span class="fu">=</span> f mempty</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  mempty <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  mappend (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="fu">=</span> <span class="dt">Enfo</span> (f <span class="fu">.</span> g)</a></code></pre></div>
<p>You can actually do the same transformation for “monoids” in the categorical sense: applying it to monads, for instance, will give you codensity <span class="citation" data-cites="rivas_notions_2014">(Rivas and Jaskelioff <a href="#ref-rivas_notions_2014">2014</a>)</span>.</p>
<h2 id="traversable">Traversable</h2>
<p>Looking back—just for a second—to the repmin example, we should be able to spot a pattern we can generalize. There’s really nothing tree-specific about it, so why can’t we apply it to lists? Or other structures, for that matter? It turns out we can: the <code class="sourceCode haskell">mapAccumL</code> function is tailor-made to this need:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">repMin ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> t <span class="dt">Integer</span> <span class="ot">-&gt;</span> t <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">repMin xs <span class="fu">=</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  (<span class="fu">~</span>(<span class="dt">Just</span> m), ys) <span class="fu">=</span> mapAccumL f <span class="dt">Nothing</span> xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  f <span class="dt">Nothing</span> x <span class="fu">=</span> (<span class="dt">Just</span> x, m)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  f (<span class="dt">Just</span> y) x <span class="fu">=</span> (<span class="dt">Just</span> (min x y), m)</a></code></pre></div>
<p>The tilde before the <code class="sourceCode haskell"><span class="dt">Just</span></code> ensures this won’t fail on empty input.</p>
<h1 id="huffman-coding">Huffman Coding</h1>
<p>Finally, it’s time for the main event. Huffman coding is a <em>very</em> multi-pass algorithm, usually. The steps look like this:</p>
<ol type="1">
<li>Build a frequency table for each character in the input.</li>
<li>Build a priority queue from that frequency table.</li>
<li>Iteratively pop elements and combine them (into Huffman trees) from the queue until there’s only one left.</li>
<li>That Huffman tree can be used to construct the mapping from items back to their Huffman codes.</li>
<li>Traverse the input again, using the constructed mapping to replace elements with their codes.</li>
</ol>
<p>We can’t <em>skip</em> any of these steps: we can try perform them all at once, though.</p>
<p>Let’s write the multi-pass version first. We’ll need the frequency table:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">frequencies ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">frequencies <span class="fu">=</span> Map.fromListWith (<span class="fu">+</span>) <span class="fu">.</span> map (flip (,) <span class="dv">1</span>)</a></code></pre></div>
<p>And a heap, ordered on the frequencies of its elements (I’m using a skew heap here):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  mempty <span class="fu">=</span> <span class="dt">Nil</span></a></code></pre></div>
<p>Next, we need to build the tree<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. We can use the tree type from above.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">buildTree ::</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (x <span class="fu">:*:</span> y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a></code></pre></div>
<p>Then, a way to convert between the tree and a map:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">toMapping (<span class="dt">Leaf</span> x) <span class="fu">=</span> Map.singleton x []</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">toMapping (xs <span class="fu">:*:</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    Map.union (fmap (<span class="dt">True</span><span class="fu">:</span>) (toMapping xs)) (fmap (<span class="dt">False</span><span class="fu">:</span>) (toMapping ys))</a></code></pre></div>
<p>And finally, putting the whole thing together:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">huffman ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), [[<span class="dt">Bool</span>]])</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">huffman xs <span class="fu">=</span> (tree, map (mapb <span class="fu">Map.!</span>) xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  freq <span class="fu">=</span> frequencies xs</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  mapb <span class="fu">=</span> maybe Map.empty toMapping tree</a></code></pre></div>
<h2 id="removing-the-passes">Removing the passes</h2>
<p>The first thing to fix is the <code class="sourceCode haskell">toMapping</code> function: at every level, it calls <code class="sourceCode haskell">union</code>, a complex and expensive operation. However, <code class="sourceCode haskell">union</code> and <code class="sourceCode haskell">empty</code> form a monoid, so we can use the Cayley representation to reduce the calls to a minimum. Next, we want to get rid of the <code class="sourceCode haskell">fmap</code>s: we can do that by assembling a function to perform the <code class="sourceCode haskell">fmap</code> as we go, as in <code class="sourceCode haskell">convolve</code><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">toMapping tree <span class="fu">=</span> go tree id Map.empty <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  go (<span class="dt">Leaf</span> x) k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  go (xs <span class="fu">:*:</span> ys) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    go xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> go ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a></code></pre></div>
<p>Secondly, we can integrate the <code class="sourceCode haskell">toMapping</code> function with the <code class="sourceCode haskell">buildTree</code> function, removing another pass:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  leaf x k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)</a></code></pre></div>
<p>Finally, to remove the second pass over the list, we can copy repmin, using <code class="sourceCode haskell">mapAccumL</code> to both construct the mapping and apply it to the structure in one go.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  mapb <span class="fu">=</span> maybe Map.empty snd tree</a></code></pre></div>
<p>And that’s it!</p>
<h1 id="generalization">Generalization</h1>
<p>The similarity between the repmin function and the solution above is suggestive: is there a way to <em>encode</em> this idea of making a multi-pass algorithm single-pass? Of course! We can use an applicative:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Circular</span> a b c <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    <span class="dt">Circular</span> <span class="fu">!</span>a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">             (b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    fmap f (<span class="dt">Circular</span> tally run) <span class="fu">=</span> <span class="dt">Circular</span> tally (f <span class="fu">.</span> run)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">         <span class="dt">Applicative</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">    pure x <span class="fu">=</span> <span class="dt">Circular</span> mempty (const x)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    <span class="dt">Circular</span> fl fr <span class="fu">&lt;*&gt;</span> <span class="dt">Circular</span> xl xr <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">        <span class="dt">Circular</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">            (mappend fl xl)</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">            (\r <span class="ot">-&gt;</span> fr r (xr r))</a>
<a class="sourceLine" id="cb16-15" data-line-number="15"></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">liftHuffman</a>
<a class="sourceLine" id="cb16-17" data-line-number="17"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb16-19" data-line-number="19">liftHuffman x <span class="fu">=</span> <span class="dt">Circular</span> (Map.singleton x <span class="dv">1</span>) (<span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb16-20" data-line-number="20"></a>
<a class="sourceLine" id="cb16-21" data-line-number="21">runHuffman</a>
<a class="sourceLine" id="cb16-22" data-line-number="22"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">    <span class="ot">=&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) r <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), r)</a>
<a class="sourceLine" id="cb16-24" data-line-number="24">runHuffman (<span class="dt">Circular</span> smry run) <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-25" data-line-number="25">    maybe (<span class="dt">Nothing</span>, run Map.empty) (<span class="dt">Just</span> <span class="fu">***</span> run) (buildTree smry)</a>
<a class="sourceLine" id="cb16-26" data-line-number="26"></a>
<a class="sourceLine" id="cb16-27" data-line-number="27">huffman</a>
<a class="sourceLine" id="cb16-28" data-line-number="28"><span class="ot">    ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb16-29" data-line-number="29">    <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb16-30" data-line-number="30">huffman <span class="fu">=</span> runHuffman <span class="fu">.</span> traverse liftHuffman</a></code></pre></div>
<p>Thanks to it being an applicative, you can do all the fun lensy things with it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">showBin ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">showBin <span class="fu">=</span> map (bool <span class="ch">&#39;0&#39;</span> <span class="ch">&#39;1&#39;</span>)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> liftBin <span class="fu">=</span> fmap showBin <span class="fu">.</span> liftHuffman</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (snd <span class="fu">.</span> runHuffman <span class="fu">.</span> (each<span class="fu">.</span>traverse) liftBin) (<span class="st">&quot;abb&quot;</span>, <span class="st">&quot;cad&quot;</span>, <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">([<span class="st">&quot;01&quot;</span>,<span class="st">&quot;11&quot;</span>,<span class="st">&quot;11&quot;</span>],[<span class="st">&quot;00&quot;</span>,<span class="st">&quot;01&quot;</span>,<span class="st">&quot;10&quot;</span>],[<span class="st">&quot;00&quot;</span>])</a></code></pre></div>
<p>Bringing us back to the start, it can also let us solve repmin!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">liftRepMin ::</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">liftRepMin x <span class="fu">=</span> <span class="dt">Circular</span> (pure (pure x)) id</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="ot">runRepMin ::</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">runRepMin (<span class="dt">Circular</span> m r) <span class="fu">=</span> r (<span class="kw">case</span> m <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="dt">Option</span> (<span class="dt">Just</span> (<span class="dt">Min</span> x)) <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">repMin ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">repMin <span class="fu">=</span> runRepMin <span class="fu">.</span> traverse liftRepMin</a></code></pre></div>
<h1 id="related">Related</h1>
<p>So the <code class="sourceCode haskell"><span class="dt">Circular</span></code> type is actually just the product of reader and writer, and is closely related to the <a href="https://github.com/treeowl/sort-traversable">sort</a> type.</p>
<p>It’s also related to the <a href="https://www.reddit.com/r/haskell/comments/7qwzn4/an_update_about_the_store_monad_and_state_comonad/"><code class="sourceCode haskell"><span class="dt">Prescient</span></code></a> type, which I noticed after I’d written the above.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bird_more_1997">
<p>Bird, Richard, Geraint Jones, and Oege De Moor. 1997. “More haste‚ less speed: Lazy versus eager evaluation.” <em>Journal of Functional Programming</em> 7 (5) (September): 541–547. doi:<a href="https://doi.org/10.1017/S0956796897002827">10.1017/S0956796897002827</a>. <a href="https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01" class="uri">https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01</a>.</p>
</div>
<div id="ref-bird_using_1984">
<p>Bird, R. S. 1984. “Using Circular Programs to Eliminate Multiple Traversals of Data.” <em>Acta Inf.</em> 21 (3) (October): 239–250. doi:<a href="https://doi.org/10.1007/BF00264249">10.1007/BF00264249</a>. <a href="http://dx.doi.org/10.1007/BF00264249" class="uri">http://dx.doi.org/10.1007/BF00264249</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. “There and Back Again.” <a href="http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf" class="uri">http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf</a>.</p>
</div>
<div id="ref-hughes_novel_1986">
<p>Hughes, R. John Muir. 1986. “A Novel Representation of Lists and Its Application to the Function &quot;Reverse&quot;.” <em>Information Processing Letters</em> 22 (3) (March): 141–144. doi:<a href="https://doi.org/10.1016/0020-0190(86)90059-1">10.1016/0020-0190(86)90059-1</a>. <a href="http://www.sciencedirect.com/science/article/pii/0020019086900591" class="uri">http://www.sciencedirect.com/science/article/pii/0020019086900591</a>.</p>
</div>
<div id="ref-pippenger_pure_1997">
<p>Pippenger, Nicholas. 1997. “Pure Versus Impure Lisp.” <em>ACM Trans. Program. Lang. Syst.</em> 19 (2) (March): 223–238. doi:<a href="https://doi.org/10.1145/244795.244798">10.1145/244795.244798</a>. <a href="http://doi.acm.org/10.1145/244795.244798" class="uri">http://doi.acm.org/10.1145/244795.244798</a>.</p>
</div>
<div id="ref-rivas_notions_2014">
<p>Rivas, Exequiel, and Mauro Jaskelioff. 2014. “Notions of Computation as Monoids.” <em>arXiv:1406.4823 [cs, math]</em> (May). <a href="http://arxiv.org/abs/1406.4823" class="uri">http://arxiv.org/abs/1406.4823</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Huffman coding single-pass implementation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>  (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>  <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Data.Traversable</span> (mapAccumL)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  mempty <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">  leaf x k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb1-28" data-line-number="28">  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)</a>
<a class="sourceLine" id="cb1-30" data-line-number="30"></a>
<a class="sourceLine" id="cb1-31" data-line-number="31"><span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb1-32" data-line-number="32">huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-33" data-line-number="33">  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs</a>
<a class="sourceLine" id="cb1-34" data-line-number="34">  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb1-35" data-line-number="35">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb1-36" data-line-number="36">  mapb <span class="fu">=</span> maybe Map.empty snd tree</a></code></pre></div>
<a href="#fnref1" class="footnote-back">↩</a></li>
<li id="fn2"><p>Well, that’s a little bit of a lie. In terms of asympostics, <span class="citation" data-cites="pippenger_pure_1997">Pippenger (<a href="#ref-pippenger_pure_1997">1997</a>)</span> stated a problem that could be solved in linear time in impure Lisp, but <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Omega(n \log n)</annotation></semantics></math> in pure Lisp. <span class="citation" data-cites="bird_more_1997">Bird, Jones, and Moor (<a href="#ref-bird_more_1997">1997</a>)</span> then produced an algorithm that could solve the problem in linear time, by using laziness. So, in some cases, laziness will give you asymptotics you can’t get without it (if you want to stay pure).<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>There’s actually a nicer version of the <code class="sourceCode haskell">buildTree</code> function which uses <code class="sourceCode haskell"><span class="dt">StateT</span> (<span class="dt">Heap</span> a) <span class="dt">Maybe</span></code>, but it’s equivalent to this one under the hood, and I though might be a little distracting.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Something to notice about this function is that it’s going top-down and bottom-up at the same time. Combining the maps (with <code class="sourceCode haskell">(<span class="fu">.</span>)</code>) is done bottom-up, but building the codes is top-down. This means the codes are built in reverse order! That’s why the accumulating parameter (<code class="sourceCode haskell">k</code>) is a difference list, rather than a normal list. As it happens, if normal lists were used, the function would be slightly more efficient through sharing, but the codes would all be reversed.<a href="#fnref4" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 17 Feb 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Monadic List Functions</title>
    <link>http://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 11, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/applicative.html">applicative</a>
    
</div>

<p>Here’s an old Haskell chestnut:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">[[],[<span class="dv">3</span>],[<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a></code></pre></div>
<p><code class="sourceCode haskell">filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>])</code> gives the power set of some input list. It’s one of the especially magical demonstrations of monads. From a high-level perspective, it makes sense: for each element in the list, we want it to be present in one output, and not present in another. It’s hard to see how it actually <em>works</em>, though. The (old<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>) <a href="https://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#filterM">source</a> for <code class="sourceCode haskell">filterM</code> doesn’t help hugely, either:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">filterM          ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">filterM _ []     <span class="fu">=</span>  return []</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">filterM p (x<span class="fu">:</span>xs) <span class="fu">=</span>  <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">   flg <span class="ot">&lt;-</span> p x</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">   ys  <span class="ot">&lt;-</span> filterM p xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">   return (<span class="kw">if</span> flg <span class="kw">then</span> x<span class="fu">:</span>ys <span class="kw">else</span> ys)</a></code></pre></div>
<p>Again, elegant and beautiful (aside from the three-space indent), but opaque. Despite not really getting how it works, I was encouraged by its simplicity to try my hand at some of the other functions from Data.List.</p>
<h2 id="grouping">Grouping</h2>
<p>Let’s start with the subject of my <a href="2018-01-07-groupBy.html">last post</a>. Here’s the implementation:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">let</span> f x a q</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))</a></code></pre></div>
<p>It translates over pretty readily:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">groupByM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">groupByM p xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  fmap snd (foldr f (const (pure ([], []))) xs (const (pure (<span class="dt">False</span>))))</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    f x a q <span class="fu">=</span> liftA2 st (q x) (a (p x)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">      st b (ys,zs)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="fu">|</span> b <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], (x<span class="fu">:</span>ys)<span class="fu">:</span>zs)</a></code></pre></div>
<p>Let’s try it with a similar example to <code class="sourceCode haskell">filterM</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> groupByM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">[[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]]</a></code></pre></div>
<p>It gives the partitions of the list!</p>
<h2 id="sorting">Sorting</h2>
<p>So these monadic generalisations have been discovered before, several times over. There’s even a <a href="https://hackage.haskell.org/package/monadlist-0.0.2">package</a> with monadic versions of the functions in Data.List. Exploring this idea with a little more formality is the paper “All Sorts of Permutations” <span class="citation" data-cites="christiansen_all_2016">(Christiansen, Danilenko, and Dylus <a href="#ref-christiansen_all_2016">2016</a>)</span>, and accompanying presentation <a href="https://www.youtube.com/watch?v=vV3jqTxJ9Wc">on YouTube</a>. They show that the monadic version of sort produces permutations of the input list, and examine the output from different sorting algorithms. Here’s a couple of their implementations, altered slightly:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">insertM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">insertM _ x [] <span class="fu">=</span> pure [x]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">insertM p x yys<span class="fu">@</span>(y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  lte <span class="ot">&lt;-</span> p x y</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">if</span> lte</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">then</span> pure (x<span class="fu">:</span>yys)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">else</span> fmap (y<span class="fu">:</span>) (insertM p x ys)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">insertSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">insertSortM p <span class="fu">=</span> foldrM (insertM p) []</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="ot">partitionM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m ([a],[a])</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">partitionM p <span class="fu">=</span> foldr f (pure ([],[])) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  f x <span class="fu">=</span> liftA2 ifStmt (p x) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    ifStmt flg (tr,fl)</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">      <span class="fu">|</span> flg <span class="fu">=</span> (x<span class="fu">:</span>tr,fl)</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      <span class="fu">|</span> otherwise <span class="fu">=</span> (tr,x<span class="fu">:</span>fl)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">      </a>
<a class="sourceLine" id="cb6-19" data-line-number="19"><span class="ot">quickSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">quickSortM p [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">quickSortM p (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  (gt,le) <span class="ot">&lt;-</span> partitionM (p x) xs</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  ls <span class="ot">&lt;-</span> quickSortM p le</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  gs <span class="ot">&lt;-</span> quickSortM p gt</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">  pure (ls <span class="fu">++</span> [x] <span class="fu">++</span> gs)</a>
<a class="sourceLine" id="cb6-26" data-line-number="26"></a>
<a class="sourceLine" id="cb6-27" data-line-number="27"><span class="fu">&gt;&gt;&gt;</span> insertSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb6-29" data-line-number="29"></a>
<a class="sourceLine" id="cb6-30" data-line-number="30"><span class="fu">&gt;&gt;&gt;</span> quickSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">[[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a></code></pre></div>
<p>As it should be easy to see, they’re very concise and elegant, and strongly resemble the pure versions of the algorithms.</p>
<h2 id="state">State</h2>
<p>So the examples above are very interesting and cool, but they don’t necessarily have a place in real Haskell code. If you wanted to find the permutations, partitions, or power set of a list you’d probably use a more standard implementation. That’s not to say that these monadic functions have no uses, though: especially when coupled with <code class="sourceCode haskell"><span class="dt">State</span></code> they yield readable and fast implementations for certain tricky functions. <code class="sourceCode haskell">ordNub</code>, for instance:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">ordNub ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">ordNub <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  flip evalState Set.empty <span class="fu">.</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  filterM</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    (\x <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">       flg <span class="ot">&lt;-</span> gets (Set.notMember x)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">       when flg (modify (Set.insert x))</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">       pure flg)</a></code></pre></div>
<p>Alternatively, using a monadic version of <code class="sourceCode haskell">maximumOn</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">maximumOnM ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Ord</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">maximumOnM p <span class="fu">=</span> (fmap <span class="fu">.</span> fmap) snd <span class="fu">.</span> foldl f (pure <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    f a e <span class="fu">=</span> liftA2 g a (p e)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        g <span class="dt">Nothing</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        g b<span class="fu">@</span>(<span class="dt">Just</span> (o, y)) q</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">          <span class="fu">|</span> o <span class="fu">&lt;</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="fu">|</span> otherwise <span class="fu">=</span> b</a></code></pre></div>
<p>You can write a one-pass <code class="sourceCode haskell">mostFrequent</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">mostFrequent ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">mostFrequent <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  flip evalState Map.empty <span class="fu">.</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  maximumOnM</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    (\x <span class="ot">-&gt;</span> maybe <span class="dv">1</span> succ <span class="fu">&lt;$&gt;</span> state (Map.insertLookupWithKey (const (<span class="fu">+</span>)) x <span class="dv">1</span>))</a></code></pre></div>
<h2 id="decision-trees">Decision Trees</h2>
<p>One of the nicest things about the paper was the diagrams of decision trees provided for each sorting algorithm. I couldn’t find a library to do that for me, so I had a go at producing my own. First, we’ll need a data type to represent the tree itself:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">DecTree</span> t a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Pure</span> a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Choice</span> t (<span class="dt">DecTree</span> t a) (<span class="dt">DecTree</span> t a)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>We’ll say the left branch is “true” and the right “false”. Applicative and monad instances are relatively mechanical<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  pure <span class="fu">=</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="dt">Pure</span> f <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fmap f xs</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">Choice</span> c ls rs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&lt;*&gt;</span> xs) (rs <span class="fu">&lt;*&gt;</span> xs)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="dt">Pure</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="dt">Choice</span> c ls rs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&gt;&gt;=</span> f) (rs <span class="fu">&gt;&gt;=</span> f)</a></code></pre></div>
<p>We can now create a comparator function that constructs one of these trees, and remembers the values it was given:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">traceCompare ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">traceCompare x y <span class="fu">=</span> <span class="dt">Choice</span> (x,y) (<span class="dt">Pure</span> <span class="dt">True</span>) (<span class="dt">Pure</span> <span class="dt">False</span>)</a></code></pre></div>
<p>Finally, to draw the tree, I’ll use a function from my <a href="https://github.com/oisdk/binary-tree">binary tree</a> library:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">printDecTree ::</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">printDecTree rel t <span class="fu">=</span> putStr (drawTreeWith id (go t) <span class="st">&quot;&quot;</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  go (<span class="dt">Pure</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (show xs) <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  go (<span class="dt">Choice</span> (x,y) tr fl) <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="dt">Node</span> (show x <span class="fu">++</span> rel <span class="fu">++</span> show y) (go tr) (go fl)</a></code></pre></div>
<p>And we get these really nice diagrams out:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> insertSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">         ┌[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    ┌<span class="dv">1</span><span class="fu">&lt;=</span>2┤</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    │    │    ┌[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    │    └<span class="dv">1</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    │         └[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="dv">2</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    │    ┌[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">    └<span class="dv">1</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">         │    ┌[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">         └<span class="dv">1</span><span class="fu">&lt;=</span>2┤</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">              └[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-14" data-line-number="14"></a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> quickSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"></a>
<a class="sourceLine" id="cb14-17" data-line-number="17">              ┌[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-18" data-line-number="18">         ┌<span class="dv">2</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-19" data-line-number="19">         │    └[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-20" data-line-number="20">    ┌<span class="dv">1</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-21" data-line-number="21">    │    └[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-22" data-line-number="22"><span class="dv">1</span><span class="fu">&lt;=</span>2┤</a>
<a class="sourceLine" id="cb14-23" data-line-number="23">    │    ┌[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-24" data-line-number="24">    └<span class="dv">1</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-25" data-line-number="25">         │    ┌[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-26" data-line-number="26">         └<span class="dv">2</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-27" data-line-number="27">              └[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a></code></pre></div>
<p>We can also try it out with the other monadic list functions:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;=&quot;</span> <span class="fu">.</span> groupByM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">       ┌[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">   ┌<span class="dv">2</span><span class="fu">=</span>3┤</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   │   └[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="dv">1</span><span class="fu">=</span>2┤</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">   │   ┌[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">   └<span class="dv">2</span><span class="fu">=</span>3┤</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">       └[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]]</a></code></pre></div>
<h2 id="applicative">Applicative</h2>
<p>You might notice that none of these “monadic” functions actually require a monad constraint: they’re all applicative. There’s a straightforward implementation that relies only on applicative for most of these functions, with a notable exception: sort. Getting <em>that</em> to work with just applicative is the subject of a future post.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-christiansen_all_2016">
<p>Christiansen, Jan, Nikita Danilenko, and Sandra Dylus. 2016. “All Sorts of Permutations (Functional Pearl).” In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 168–179. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951949">10.1145/2951913.2951949</a>. <a href="http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf" class="uri">http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The definition has since been <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Control.Monad.html#filterM">updated</a> to more modern Haskell: it now uses a fold, and only requires <code class="sourceCode haskell"><span class="dt">Applicative</span></code>.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Part of the reason the instances are so mechanical is that this type strongly resembles the <a href="https://hackage.haskell.org/package/free-5/docs/Control-Monad-Free.html#t:Free">free monad</a>:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="fu">=</span> <span class="dt">Pure</span> a <span class="fu">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))</code></p>
<p>In fact, the example given in the <code class="sourceCode haskell"><span class="dt">MonadFree</span></code> class is the following:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span> <span class="dt">Pair</span> a a</code></p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Pair</span></code></p>
<p>The only difference with the above type and the decision tree is that the decision tree carries a tag with it.</p>
<p>So what’s so interesting about this relationship? Well, <code class="sourceCode haskell"><span class="dt">Pair</span></code> is actually a <a href="https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Rep.html">representable functor</a>. Any representable functor <code class="sourceCode haskell">f a</code> can be converted to (and from) a function <code class="sourceCode haskell">key <span class="ot">-&gt;</span> a</code>, where <code class="sourceCode haskell">key</code> is the specific key for <code class="sourceCode haskell">f</code>. The key for <code class="sourceCode haskell"><span class="dt">Pair</span></code> is <code class="sourceCode haskell"><span class="dt">Bool</span></code>: the result of the function we passed in to the sorting functions!</p>
<p>In general, you can make a “decision tree” for any function of type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> b</code> like so:</p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DecTree</span> a b r <span class="fu">=</span> <span class="dt">Rep</span> f <span class="fu">~</span> b <span class="ot">=&gt;</span> <span class="dt">Free</span> (<span class="dt">Compose</span> ((,) a) f) r</code></p>
<p>But more on that in a later post.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sun, 11 Feb 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>groupBy</title>
    <link>http://doisinkidney.com/posts/2018-01-07-groupBy.html</link>
    <description><![CDATA[<div class="info">
    Posted on January  7, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>Here’s a useful function from <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-List.html#v:groupBy">Data.List</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">groupBy (<span class="fu">==</span>) <span class="st">&quot;aabcdda&quot;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co">-- [&quot;aa&quot;,&quot;b&quot;,&quot;c&quot;,&quot;dd&quot;,&quot;a&quot;]</span></a></code></pre></div>
<p>However, as has been pointed out before<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, <code class="sourceCode haskell">groupBy</code> expects an equivalence relation, and can exhibit surprising behavior when it doesn’t get one. Let’s say, for instance, that we wanted to group numbers that were close together:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">groupClose ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [[<span class="dt">Integer</span>]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">groupClose <span class="fu">=</span> groupBy (\x y <span class="ot">-&gt;</span> abs (x <span class="fu">-</span> y) <span class="fu">&lt;</span> <span class="dv">3</span>)</a></code></pre></div>
<p>What would you expect on the list <code>[1, 2, 3, 4, 5]</code>? All in the same group? Well, what you actually get is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>This is because the implementation of <code class="sourceCode haskell">groupBy</code> only compares to the first element in each group:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">groupBy _  []           <span class="fu">=</span>  []</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">groupBy eq (x<span class="fu">:</span>xs)       <span class="fu">=</span>  (x<span class="fu">:</span>ys) <span class="fu">:</span> groupBy eq zs</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">                           <span class="kw">where</span> (ys,zs) <span class="fu">=</span> span (eq x) xs</a></code></pre></div>
<p>Brandon Simmons gave a <a href="http://brandon.si/code/an-alternative-definition-for-datalistgroupby/">definition</a> of <code class="sourceCode haskell">groupBy</code> that is perhaps more useful, but it used explicit recursion, rather than a fold.</p>
<p>A definition with <code class="sourceCode haskell">foldr</code> turned out to be trickier than I expected. I found some of the laziness properties especially difficult:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> head (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head <span class="fu">.</span> tail) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="dv">2</span></a></code></pre></div>
<p>Here’s the definition I came up with, after some deliberation:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">let</span> f x a q</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ot">{-# INLINE groupBy #-}</span></a></code></pre></div>
<p>Seemingly benign changes to the function will break one or more of the above tests. In particular, the laziness of a “where” binding needs to be taken into account. Here’s an early attempt which failed:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">let</span> f x a q d</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> a (p x) (d <span class="fu">.</span> (<span class="fu">:</span>) x)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> d [] (a (p x) (c <span class="fu">.</span> (<span class="fu">:</span>) x))</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">in</span> foldr f (\_ d <span class="ot">-&gt;</span> d [] n) xs (const <span class="dt">False</span>) (\ _ y <span class="ot">-&gt;</span> y))</a></code></pre></div>
<p>Once done, though, it works as expected:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) <span class="st">&quot;aaabcccdda&quot;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">[<span class="st">&quot;aaa&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ccc&quot;</span>,<span class="st">&quot;dd&quot;</span>,<span class="st">&quot;a&quot;</span>]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) []</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">[]</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">&lt;=</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">2</span>]]</a></code></pre></div>
<p>It’s the fastest version I could find that obeyed the above laziness properties.</p>
<p>The <a href="https://ghc.haskell.org/trac/ghc/ticket/13593">GHC page on the issue</a> unfortunately seems to indicate the implementation won’t be changed. Ah, well. Regardless, I have a <a href="https://github.com/oisdk/groupBy">repository</a> with the implementation above (with extra fusion machinery added) and comparisons to other implementations.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There are several threads on the libraries mailing list on this topic:</p>
<dl>
<dt>2006</dt>
<dd><a href="http://www.haskell.org/pipermail/haskell-cafe/2006-October/019148.html">mapAccumL - find max in-sequence subsequence</a>
</dd>
<dt>2007</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2007-August/008028.html">Data.List.groupBy with non-transitive equality predicate</a> (this is the longest discussion on the topic)
</dd>
<dt>2008</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2008-September/010629.html">Generalize groupBy in a useful way?</a>
</dd>
<dt>2009</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2009-June/011866.html">nubBy seems broken in recent GHCs</a>
</dd>
</dl>
<a href="#fnref1" class="footnote-back">↩</a></li>
</ol>
</section>
]]></description>
    <pubDate>Sun, 07 Jan 2018 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2018-01-07-groupBy.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>

    </channel>
</rss>
