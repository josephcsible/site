<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Donnacha Oisín Kidney's Blog</title>
        <link>http://doisinkidney.com</link>
        <description><![CDATA[Mainly writing about programming]]></description>
        <atom:link href="http://doisinkidney.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 17 Nov 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Semirings</title>
    <link>http://doisinkidney.com/posts/2016-11-17-semirings-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving, TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}</span>
<span class="ot">{-# LANGUAGE PatternSynonyms, ViewPatterns, LambdaCase #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes, FlexibleInstances, FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings, OverloadedLists, MonadComprehensions #-}</span>

<span class="kw">module</span> <span class="dt">Semirings</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import           </span><span class="dt">Data.Map.Strict</span>      (<span class="dt">Map</span>)
<span class="kw">import           </span><span class="dt">Data.Monoid</span>  <span class="kw">hiding</span>  (<span class="dt">Endo</span>(..))
<span class="kw">import           </span><span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)
<span class="kw">import           </span><span class="dt">Control.Applicative</span>
<span class="kw">import           </span><span class="dt">Control.Arrow</span>        (first)
<span class="kw">import           </span><span class="dt">Control.Monad.Cont</span>
<span class="kw">import           </span><span class="dt">Data.Functor.Identity</span>
<span class="kw">import           </span><span class="dt">GHC.Exts</span>
<span class="kw">import           </span><span class="dt">Data.List</span> <span class="kw">hiding</span>     (insert)
<span class="kw">import           </span><span class="dt">Data.Maybe</span>           (mapMaybe)</code></pre></div>
<p>I’ve been playing around a lot with semirings recently. A semiring is anything with addition, multiplication, zero and one. You can represent that in Haskell as:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span>
<span class="ot">  zero ::</span> a
<span class="ot">  one  ::</span> a
  <span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">&lt;.&gt;</span>
<span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
  <span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">&lt;+&gt;</span>
<span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>It’s kind of like a combination of two <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html">monoids</a>. It has the normal monoid laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;+&gt;</span> z
x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;.&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;.&gt;</span> z
x <span class="fu">&lt;+&gt;</span> zero <span class="fu">=</span> zero <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x
x <span class="fu">&lt;.&gt;</span> one  <span class="fu">=</span> one  <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span> x</code></pre></div>
<p>And a few extra:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> x
x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> z)
(x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;.&gt;</span> z <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> z) <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;.&gt;</span> z)
zero <span class="fu">&lt;.&gt;</span> a <span class="fu">=</span> a <span class="fu">&lt;.&gt;</span> zero <span class="fu">=</span> zero</code></pre></div>
<p>I should note that what I’m calling a semiring here is often called a <a href="https://ncatlab.org/nlab/show/rig">rig</a>. I actually prefer the name “rig”: a rig is a ring without <strong>n</strong>egatives (cute!); whereas a <em>semi</em>ring is a rig without neutral elements, which mirrors the definition of a semigroup. The nomenclature in this area is a bit of a mess, though, so I went with the more commonly-used name for the sake of googleability.</p>
<p>At first glance, it looks quite numeric. Indeed, <a href="https://pursuit.purescript.org/packages/purescript-prelude/1.1.0/docs/Data.Semiring">PureScript</a> uses it as the basis for its numeric hierarchy. (In my experience so far, it’s nicer to use than Haskell’s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num"><code class="sourceCode haskell"><span class="dt">Num</span></code></a>)</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dv">0</span>
  one  <span class="fu">=</span> <span class="dv">1</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Double</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dv">0</span>
  one  <span class="fu">=</span> <span class="dv">1</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</code></pre></div>
<p>However, there are far more types which can form a valid <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance than can form a valid <code class="sourceCode haskell"><span class="dt">Num</span></code> instance: the <code class="sourceCode haskell">negate</code> method, for example, excludes types representing the natural numbers:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ChurchNat</span> <span class="fu">=</span> <span class="dt">ChurchNat</span> 
  {<span class="ot"> runNat ::</span> forall a<span class="fu">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a}
 
<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></code></pre></div>
<p>These form perfectly sensible semirings, though:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">ChurchNat</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dt">ChurchNat</span> (const id)
  one <span class="fu">=</span> <span class="dt">ChurchNat</span> (<span class="fu">$</span>)
  <span class="dt">ChurchNat</span> n <span class="fu">&lt;+&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (\f <span class="ot">-&gt;</span> n f <span class="fu">.</span> m f)
  <span class="dt">ChurchNat</span> n <span class="fu">&lt;.&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (n <span class="fu">.</span> m)

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Nat</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dt">Zero</span>
  one <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Zero</span>
  <span class="dt">Zero</span> <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x
  <span class="dt">Succ</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> <span class="dt">Succ</span> (x <span class="fu">&lt;+&gt;</span> y)
  <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> <span class="dt">Zero</span>
  <span class="dt">Succ</span> <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span>x
  <span class="dt">Succ</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> y)</code></pre></div>
<p>The other missing method is <code class="sourceCode haskell">fromInteger</code>, which means decidedly non-numeric types are allowed:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dt">False</span>
  one  <span class="fu">=</span> <span class="dt">True</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">||</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</code></pre></div>
<p>We can provide a more general definition of the <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Product"><code class="sourceCode haskell"><span class="dt">Product</span></code></a> newtypes from <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#g:3">Data.Monoid</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Add</span> a <span class="fu">=</span> <span class="dt">Add</span>
  {<span class="ot"> getAdd ::</span> a
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)

<span class="kw">newtype</span> <span class="dt">Mul</span> a <span class="fu">=</span> <span class="dt">Mul</span>
  {<span class="ot"> getMul ::</span> a
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Add</span> <span class="kw">where</span>
  fmap f (<span class="dt">Add</span> x) <span class="fu">=</span> <span class="dt">Add</span> (f x)

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Add</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Add</span>
  <span class="dt">Add</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Add</span> x <span class="fu">=</span> <span class="dt">Add</span> (f x)</code></pre></div>
<p>I’m using <code class="sourceCode haskell"><span class="dt">Add</span></code> and <code class="sourceCode haskell"><span class="dt">Mul</span></code> here to avoid name clashing.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Add</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Add</span> zero
  <span class="dt">Add</span> x <span class="ot">`mappend`</span> <span class="dt">Add</span> y <span class="fu">=</span> <span class="dt">Add</span> (x <span class="fu">&lt;+&gt;</span> y)

<span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Mul</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Mul</span> one
  <span class="dt">Mul</span> x <span class="ot">`mappend`</span> <span class="dt">Mul</span> y <span class="fu">=</span> <span class="dt">Mul</span> (x <span class="fu">&lt;.&gt;</span> y)
  
<span class="ot">add ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a
add <span class="fu">=</span> getAdd <span class="fu">.</span> foldMap <span class="dt">Add</span>

<span class="ot">mul ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a
mul <span class="fu">=</span> getMul <span class="fu">.</span> foldMap <span class="dt">Mul</span></code></pre></div>
<p><code class="sourceCode haskell">add</code> and <code class="sourceCode haskell">mul</code> are equivalent to <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:sum"><code class="sourceCode haskell">sum</code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:product"><code class="sourceCode haskell">product</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">add xs <span class="fu">==</span> sum (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">mul xs <span class="fu">==</span> product (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</code></pre></div>
<p>But they now work with a wider array of types: non-negative numbers, as we’ve seen, but specialised to <code class="sourceCode haskell"><span class="dt">Bool</span></code> we get the familiar <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Any"><code class="sourceCode haskell"><span class="dt">Any</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:All"><code class="sourceCode haskell"><span class="dt">All</span></code></a> newtypes (and their corresponding folds).</p>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">add xs <span class="fu">==</span> or (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">mul xs <span class="fu">==</span> and (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</code></pre></div>
<p>So far, nothing amazing. We avoid a little bit of code duplication, that’s all.</p>
<h2 id="a-semiring-map">A Semiring Map</h2>
<p>In older versions of Python, <a href="https://www.python.org/dev/peps/pep-0218/">there was no native set type</a>. In its place, dictionaries were used, where the values would be booleans. In a similar fashion, before the <a href="https://docs.python.org/2/library/collections.html#collections.Counter">Counter</a> type was added in 2.7, the traditional way of representing a multiset was using a dictionary where the values were integers.</p>
<p>Using semirings, both of these data structures can have the same type:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">GeneralMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span>
  {<span class="ot"> getMap ::</span> <span class="dt">Map</span> a b
  } <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</code></pre></div>
<p>If operations are defined in terms of the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class, the same code will work on a set <em>and</em> a multiset:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
insert x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith (<span class="fu">&lt;+&gt;</span>) x one <span class="fu">.</span> getMap

<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
delete x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.delete x <span class="fu">.</span> getMap</code></pre></div>
<p>How to get back the dictionary-like behaviour, then? Well, operations like <code class="sourceCode haskell">lookup</code> and <code class="sourceCode haskell">assoc</code> are better suited to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> constraint, rather than <code class="sourceCode haskell"><span class="dt">Semiring</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> b
lookup x <span class="fu">=</span> fold <span class="fu">.</span> Map.lookup x <span class="fu">.</span> getMap

<span class="ot">assoc ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b)) 
      <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)
assoc k v <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith mappend k (pure v) <span class="fu">.</span> getMap</code></pre></div>
<p><code class="sourceCode haskell">lookup</code> is a function which should work on sets and multisets: however <code class="sourceCode haskell"><span class="dt">Bool</span></code> and <code class="sourceCode haskell"><span class="dt">Integer</span></code> don’t have <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instances. To fix this, we can use the <code class="sourceCode haskell"><span class="dt">Add</span></code> newtype from earlier. The interface for each of these data structures can now be expressed like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Set</span>      a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Bool</span>)
<span class="kw">type</span> <span class="dt">MultiSet</span> a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Integer</span>)
<span class="kw">type</span> <span class="dt">Map</span>      a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">First</span> b)
<span class="kw">type</span> <span class="dt">MultiMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a [b]</code></pre></div>
<p>And each of the functions on the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> specialises like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Set</span>
<span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a
lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Bool</span>
<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a

<span class="co">-- MultiSet</span>
<span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a
lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Integer</span>
<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a

<span class="co">-- Map</span>
<span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b
lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b
<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b

<span class="co">-- MultiMap</span>
<span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b
lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> [b]
<span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</code></pre></div>
<p>This was actually where I first came across semirings: I was trying to avoid code duplication for a trie implementation. I wanted to get the Boom Hierarchy <span class="citation">(<a href="#ref-boom_further_1981">1981</a>)</span> (plus maps) from the same underlying implementation.</p>
<p>It works <em>okay</em>. On the one hand, it’s nice that you don’t have to wrap the map type itself to get the different behaviour. There’s only one <code class="sourceCode haskell">delete</code> function, which works on sets, maps, multisets, etc. I don’t need to import the <code class="sourceCode haskell"><span class="dt">TrieSet</span></code> module qualified, to differentiate between the <em>four</em> <code class="sourceCode haskell">delete</code> functions I’ve written.</p>
<p>On the other hand, the <code class="sourceCode haskell"><span class="dt">Add</span></code> wrapper is a pain: having <code class="sourceCode haskell">lookup</code> return the wrapped values is ugly, and the <code class="sourceCode haskell"><span class="dt">Applicative</span></code> constraint is unwieldy (we only use it for <code class="sourceCode haskell">pure</code>). Both of those problems could be solved by using something like the <a href="https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html#t:Newtype"><code class="sourceCode haskell"><span class="dt">Newtype</span></code></a> or <a href="https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Wrapped.html#t:Wrapped"><code class="sourceCode haskell"><span class="dt">Wrapped</span></code></a> class, which provide facilities for wrapping and unwrapping, but that might be overkill.</p>
<p>While <code class="sourceCode haskell"><span class="dt">Monoid</span></code> and <code class="sourceCode haskell"><span class="dt">Semiring</span></code> can take you pretty far, even to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">fromList ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
fromList <span class="fu">=</span> foldr insert (<span class="dt">GeneralMap</span> Map.empty)

<span class="ot">fromAssocs ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b), <span class="dt">Foldable</span> t) 
           <span class="ot">=&gt;</span> t (a, b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)
fromAssocs <span class="fu">=</span> foldr (uncurry assoc) (<span class="dt">GeneralMap</span> Map.empty)

<span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">GeneralMap</span> a b) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">GeneralMap</span> Map.empty
  mappend (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span> 
    <span class="dt">GeneralMap</span> (Map.unionWith mappend x y)

<span class="ot">singleton ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
singleton x <span class="fu">=</span> <span class="dt">GeneralMap</span> (Map.singleton x one)</code></pre></div>
<p>They seem to fall down around functions like <code class="sourceCode haskell">intersection</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">intersection ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b)
             <span class="ot">=&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b
intersection (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span>
  <span class="dt">GeneralMap</span> (Map.intersectionWith (<span class="fu">&lt;.&gt;</span>) x y)</code></pre></div>
<p>It works for sets, but it doesn’t make sense for multisets, and it doesn’t work for maps.</p>
<p>I couldn’t find a semiring for the map-like types which would give me a sensible intersection. I’m probably after a different algebraic structure.</p>
<h2 id="a-probability-semiring">A Probability Semiring</h2>
<p>While looking for a semiring to represent a valid intersection, I came across the probability semiring. It’s just the normal semiring over the rationals, with a lower bound of 0, and an upper of 1.</p>
<p>It’s useful in some cool ways: you can combine it with a list to get the probability monad <span class="citation">(Erwig and Kollmansberger <a href="#ref-erwig_functional_2006">2006</a>)</span>. There’s an example in PureScript’s <a href="https://pursuit.purescript.org/packages/purescript-distributions/">Distributions</a> package.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> [(a,s)] }</code></pre></div>
<p>There are some drawbacks to this representation, performance-wise. In particular, there’s a combinatorial explosion on every monadic bind. One of the strategies to reduce this explosion is to use a map:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> <span class="dt">Map</span> a s }</code></pre></div>
<p>Because this doesn’t allow duplicate keys, it will flatten the association list on every bind. Unfortunately, the performance gain doesn’t always materialize, and in some cases there’s a performance <em>loss</em> <span class="citation">(Larsen <a href="#ref-larsen_memory_2011">2011</a>)</span>. Also, the <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint on the keys prevents it from conforming to <code class="sourceCode haskell"><span class="dt">Monad</span></code> (at least not without <a href="http://okmij.org/ftp/Haskell/set-monad.html">difficulty</a>).</p>
<p>Interestingly, this type is exactly the same as the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> from before. This is a theme I kept running into, actually: the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> type represents not just maps, multimaps, sets, multisets, but also a whole host of other data structures.</p>
<h2 id="cont">Cont</h2>
<p>Edward Kmett had an interesting blog post about “Free Modules and Functional Linear Functionals” <span class="citation">(<a href="#ref-kmett_modules_2011">2011</a><a href="#ref-kmett_modules_2011">b</a>)</span>. In it, he talked about this type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">$*</span>
<span class="kw">newtype</span> <span class="dt">Linear</span> r a <span class="fu">=</span> <span class="dt">Linear</span> {<span class="ot"> ($*) ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html#t:Cont"><code class="sourceCode haskell"><span class="dt">Cont</span></code></a>, the continuation monad. It can encode the probability monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">fromProbs ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> [(a,s)] <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
fromProbs xs <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span>
  foldr (\(x,s) a <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (fmap (s<span class="fu">&lt;.&gt;</span>) (k x)) a) (pure zero) xs

<span class="ot">probOfT ::</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a <span class="ot">-&gt;</span> m r
probOfT e c <span class="fu">=</span> runContT c (\x <span class="ot">-&gt;</span> <span class="kw">if</span> e x <span class="kw">then</span> pure one <span class="kw">else</span> pure zero)

<span class="ot">probOf ::</span> <span class="dt">Semiring</span> r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> r
probOf e <span class="fu">=</span> runIdentity <span class="fu">.</span> probOfT e

<span class="ot">uniform ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="dt">Double</span> m a
uniform xs <span class="fu">=</span>
  <span class="kw">let</span> s <span class="fu">=</span> <span class="fl">1.0</span> <span class="fu">/</span> fromIntegral (length xs)
  <span class="kw">in</span> fromProbs (map (flip (,) s) xs)</code></pre></div>
<p>Multiplication isn’t paid for on every bind, making this (potentially) a more efficient implementation than both the map and the association list.</p>
<p>You can actually make the whole thing a semiring:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span>
  one  <span class="fu">=</span> <span class="dt">ContT</span> (const (pure one))
  zero <span class="fu">=</span> <span class="dt">ContT</span> (const (pure zero))
  f <span class="fu">&lt;+&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (runContT f k) (runContT g k))
  f <span class="fu">&lt;.&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;.&gt;</span>) (runContT f k) (runContT g k))</code></pre></div>
<p>Which gives you a lovely <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span>
  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>)
  empty <span class="fu">=</span> zero</code></pre></div>
<p>This sheds some light on what was going on with the unsatisfactory <code class="sourceCode haskell">intersection</code> function on <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code>: it’s actually <em>multiplication</em>. If you wanted to stretch the analogy and make <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, you could use the empty map for <code class="sourceCode haskell">zero</code>, <code class="sourceCode haskell">mappend</code> for <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, but you’d run into trouble for <code class="sourceCode haskell">one</code>. <code class="sourceCode haskell">one</code> is the map where every possible key has a value of one. In other words, you’d have to enumerate over every possible value for the keys. Interestingly, there’s kind of the inverse problem for Cont: while it has an easy <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance, in order to <em>inspect</em> the values you have to enumerate over all the possible keys.</p>
<p>I now have a name for the probability monad / general map / Cont thing: a <em>covector</em>.</p>
<p>I think that the transformer version of Cont has a valid interpretation, also. If I ever understand <span class="citation">Hirschowitz and Maggesi (<a href="#ref-hirschowitz_modules_2010">2010</a>)</span> I’ll put it into a later follow-up post.</p>
<h2 id="conditional-choice">Conditional choice</h2>
<p>As a short digression, you can beef up the <code class="sourceCode haskell"><span class="fu">&lt;|&gt;</span></code> operator a little, with something like <a href="http://zenzike.com/posts/2011-08-01-the-conditional-choice-operator">the conditional choice operator</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BiWeighted</span> s <span class="fu">=</span> s <span class="fu">:|:</span> s
<span class="kw">infixl</span> <span class="dv">8</span> <span class="fu">:|:</span>

<span class="ot">(|&gt;) ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Semiring</span> s)
     <span class="ot">=&gt;</span> <span class="dt">BiWeighted</span> s
     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
((lp <span class="fu">:|:</span> rp) <span class="fu">|&gt;</span> r) l <span class="fu">=</span>
  (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) lp l <span class="fu">&lt;|&gt;</span> (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) rp r
<span class="co">--</span>
<span class="ot">(&lt;|) ::</span> <span class="dt">ContT</span> s m a
     <span class="ot">-&gt;</span> (<span class="dt">ContT</span> s m a <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a)
     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a
l <span class="fu">&lt;|</span> r <span class="fu">=</span> r l

<span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">&lt;|</span>
<span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">|&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">probOf (<span class="ch">&#39;a&#39;</span><span class="fu">==</span>) (uniform <span class="st">&quot;a&quot;</span> <span class="fu">&lt;|</span> <span class="fl">0.4</span> <span class="fu">:|:</span> <span class="fl">0.6</span> <span class="fu">|&gt;</span> uniform <span class="st">&quot;b&quot;</span>)
<span class="fl">0.4</span></code></pre></div>
<h2 id="unleak">UnLeak</h2>
<p>If you fiddle around with the probability monad, you can break it apart in interesting ways. For instance, extracting the <code class="sourceCode haskell"><span class="dt">WriterT</span></code> monad transformer gives you:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Double</span>) []</code></pre></div>
<p>Eric Kidd describes it as <code class="sourceCode haskell"><span class="dt">PerhapsT</span></code>: a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> with attached probability in his <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/">excellent blog post</a> <span class="citation">(and his paper in <a href="#ref-kidd_build_2007">2007</a>)</span>.</p>
<p>Straight away, we can optimise this representation by transforming the <a href="https://mail.haskell.org/pipermail/libraries/2013-March/019528.html">leaky</a> <code class="sourceCode haskell"><span class="dt">WriterT</span></code> into a state monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">WeightedT</span> s m a <span class="fu">=</span> <span class="dt">WeightedT</span> 
  {<span class="ot"> getWeightedT ::</span> s <span class="ot">-&gt;</span> m (a, s)
  } <span class="kw">deriving</span> <span class="dt">Functor</span>
  
<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> pure (x,s)
  <span class="dt">WeightedT</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">WeightedT</span> xs <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
    (f, p) <span class="ot">&lt;-</span> fs s
    (x, t) <span class="ot">&lt;-</span> xs p
    pure (f x, t)
  
<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span>
  <span class="dt">WeightedT</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
    (x, p) <span class="ot">&lt;-</span> x s
    getWeightedT (f x) p</code></pre></div>
<p>I’m not sure yet, but I think this might have something to do with the isomorphism between <code class="sourceCode haskell"><span class="dt">Cont</span> ((<span class="ot">-&gt;</span>) s)</code> and <code>State s</code> <span class="citation">(Kmett <a href="#ref-kmett_free_2011">2011</a><a href="#ref-kmett_free_2011">a</a>)</span>.</p>
<p>You can even make it look like a normal (non-transformer) writer with some pattern synonyms:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Weighted</span> s <span class="fu">=</span> <span class="dt">WeightedT</span> s <span class="dt">Identity</span>

pattern <span class="dt">Weighted</span> w <span class="ot">&lt;-</span> (runIdentity <span class="fu">.</span> flip getWeightedT zero <span class="ot">-&gt;</span> w) <span class="kw">where</span>
  <span class="dt">Weighted</span> (x,w) <span class="fu">=</span> <span class="dt">WeightedT</span> (\s <span class="ot">-&gt;</span> <span class="dt">Identity</span> (x, s <span class="fu">&lt;.&gt;</span> w) )</code></pre></div>
<p>And you can pretend that you’ve just got a normal tuple:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">half ::</span> a <span class="ot">-&gt;</span> <span class="dt">Weighted</span> <span class="dt">Double</span> a
half x <span class="fu">=</span> <span class="dt">Weighted</span> (x, <span class="fl">0.5</span>)

<span class="ot">runWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> (a, s)
runWeighted (<span class="dt">Weighted</span> w) <span class="fu">=</span> w

<span class="ot">evalWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> a
evalWeighted (<span class="dt">Weighted</span> (x,_)) <span class="fu">=</span> x

<span class="ot">execWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> s
execWeighted (<span class="dt">Weighted</span> (_,s)) <span class="fu">=</span> s</code></pre></div>
<h2 id="free">Free</h2>
<p>Looking back at Cont, it is reminiscent of a particular encoding of the free monoid from <span class="citation">Doel (<a href="#ref-doel_free_2015">2015</a>)</span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FreeMonoid</span> a <span class="fu">=</span> <span class="dt">FreeMonoid</span>
  { forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> m }</code></pre></div>
<p>So possibly covectors represent the free semiring, in some way.</p>
<p>Another encoding which looks free-ish is one of the efficient implementations of the probability monad from <span class="citation">Larsen (<a href="#ref-larsen_memory_2011">2011</a>)</span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Dist</span> a <span class="kw">where</span>
  <span class="dt">Certainly</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="co">-- only possible value</span>
  <span class="dt">Choice</span><span class="ot"> ::</span> <span class="dt">Probability</span> <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a
  <span class="dt">Fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> b
  <span class="dt">Join</span><span class="ot"> ::</span> <span class="dt">Dist</span> (<span class="dt">Dist</span> a) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</code></pre></div>
<p>This looks an awful lot like a weighted <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html">free alternative</a>. Is it a free semiring, then?</p>
<p>Maybe. There’s a parallel between the relationship between monoids and semirings and applicatives and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Alternative"><code class="sourceCode haskell"><span class="dt">Alternative</span></code></a>s <span class="citation">(Rivas, Jaskelioff, and Schrijvers <a href="#ref-rivas_monoids_2015">2015</a>)</span>. In a way, where monads are monoids in the category of endofunctors, alternatives are <em>semirings</em> in the category of endofunctors.</p>
<p>This parallel probably isn’t what I first thought it was. First of all, the above paper uses near-semirings, not semirings. A near-semiring is a semiring where the requirements for left distribution of multiplication over addition and commutative addition are dropped. Secondly, the class which most mirrors near-semirings is <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:MonadPlus"><code class="sourceCode haskell"><span class="dt">MonadPlus</span></code></a>, not alternative. (alternative doesn’t have annihilation) Thirdly, right distribution of multiplication over addition <em>isn’t</em> required <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code>: it’s a further law required on top of the existing laws. Fourthly, most types in the Haskell ecosystem today which conform to <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code> <em>don’t</em> conform to this extra law: in fact, those that do seem to be lists of some kind or another.</p>
<p>A further class is probably needed on top of the two already there, with the extra laws <span class="citation">(called <code class="sourceCode haskell"><span class="dt">Nondet</span></code> in Fischer <a href="#ref-fischer_reinventing_2009">2009</a>)</span>.</p>
<p>An actual free near-semiring looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f x <span class="fu">=</span> <span class="dt">Free</span> {<span class="ot"> unFree ::</span> [<span class="dt">FFree</span> f x] }
<span class="kw">data</span> <span class="dt">FFree</span> f x <span class="fu">=</span> <span class="dt">Pure</span> x <span class="fu">|</span> <span class="dt">Con</span> (f (<span class="dt">Free</span> f x))</code></pre></div>
<p>Specialised to the <code class="sourceCode haskell"><span class="dt">Identity</span></code> monad, that becomes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Forest</span> a <span class="fu">=</span> <span class="dt">Forest</span> {<span class="ot"> unForest ::</span> [<span class="dt">Tree</span> x] }
<span class="kw">data</span> <span class="dt">Tree</span> x <span class="fu">=</span> <span class="dt">Leaf</span> x <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Forest</span> x)</code></pre></div>
<p>De-specialised to the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free.html">free monad transformer</a>, it becomes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FreeT</span> f m a <span class="fu">=</span> <span class="dt">FreeT</span>
  {<span class="ot"> runFreeT ::</span> m (<span class="dt">FreeF</span> f a (<span class="dt">FreeT</span> f m a)) }

<span class="kw">data</span> <span class="dt">FreeF</span> f a b
  <span class="fu">=</span> <span class="dt">Pure</span> a
  <span class="fu">|</span> <span class="dt">Free</span> (f b)

<span class="kw">type</span> <span class="dt">FreeNearSemiring</span> f <span class="fu">=</span> <span class="dt">FreeT</span> f []</code></pre></div>
<p>These definitions all lend themselves to combinatorial search <span class="citation">(Spivey <a href="#ref-spivey_algebras_2009">2009</a>, <span class="citation">Fischer (<a href="#ref-fischer_reinventing_2009">2009</a>)</span>, <span class="citation">Piponi (<a href="#ref-piponi_monad_2009">2009</a>)</span>)</span>, with one extra operation needed: <code class="sourceCode haskell">wrap</code>.</p>
<h2 id="odds">Odds</h2>
<p>Does the <a href="/posts/2016-09-27-odds-lhs.html">odds monad</a> fit in to any of this?</p>
<p>While <code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</code> is a valid definition of the traditional probability monad, it’s <em>not</em> the same as the odds monad. If you take the odds monad, and parameterize it over the weight of the tail, you get this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> m a <span class="fu">=</span> <span class="dt">Certain</span> a <span class="fu">|</span> <span class="dt">Choice</span> (m (a, <span class="dt">Odds</span> a))</code></pre></div>
<p>Which looks remarkably like <a href="http://www.haskellforall.com/2016/07/list-transformer-beginner-friendly-listt.html"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ListT</span> m a <span class="fu">=</span> <span class="dt">ListT</span> {<span class="ot"> next ::</span> m (<span class="dt">Step</span> m a) }
<span class="kw">data</span> <span class="dt">Step</span> m a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">ListT</span> m a) <span class="fu">|</span> <span class="dt">Nil</span></code></pre></div>
<p>That suggests a relationship between probability and odds:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span>  <span class="dt">Rational</span>) [] <span class="fu">=</span> <span class="dt">Probability</span>
<span class="dt">ListT</span>   (<span class="dt">Weighted</span> <span class="dt">Rational</span>)    <span class="fu">=</span> <span class="dt">Odds</span></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">ListT</span></code> isn’t a perfect match, though: it allows empty lists. To correct this, you could use the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html">Cofree Comonad</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> (f (<span class="dt">Cofree</span> f a))</code></pre></div>
<p>Subbing in <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for <code class="sourceCode haskell">f</code>, you get a non-empty list. A <em>weighted</em> <code class="sourceCode haskell"><span class="dt">Maybe</span></code> is basically <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/"><code class="sourceCode haskell"><span class="dt">PerhapsT</span></code></a>, as was mentioned earlier.</p>
<h2 id="generalizing-semirings">Generalizing Semirings</h2>
<p>Types in haskell also form a semiring.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (,)
one <span class="fu">=</span> ()

(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="dt">Either</span>
zero <span class="fu">=</span> <span class="dt">Void</span></code></pre></div>
<p>There’s a subset of semirings which are <a href="https://en.wikipedia.org/wiki/Semiring#Star_semirings">star semirings</a>. They have an operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>*</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a* = 1 + aa* = 1 + a*a</annotation></semantics></math></p>
<p>Or, as a class:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> a <span class="kw">where</span>
<span class="ot">  star ::</span> a <span class="ot">-&gt;</span> a
  star x <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> plus x
<span class="ot">  plus ::</span> a <span class="ot">-&gt;</span> a
  plus x <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> star x</code></pre></div>
<p>Using this on types, you get:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">star a <span class="fu">=</span> <span class="dt">Either</span> () (a, star a)</code></pre></div>
<p>Which is just a standard list! Some pseudo-haskell on alternatives will give you:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">star ::</span> (<span class="dt">Alternative</span> f, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a
star x <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> star x) <span class="fu">&lt;+&gt;</span> pure mempty <span class="kw">where</span>
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="fu">&lt;|&gt;</span></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#v:many"><code class="sourceCode haskell">many</code></a>. (although note that this breaks all the laws)</p>
<p>The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> for rationals is defined as <span class="citation">(Droste and Kuich <a href="#ref-droste_semirings_2009">2009</a>, p8)</span>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>a</mi></mrow></mfrac></mtd><mtd><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd><mn>0</mn><mo>≤</mo><mi>a</mi><mo>&lt;</mo><mn>1</mn><mo>,</mo></mtd></mtr><mtr><mtd><mi>∞</mi></mtd><mtd><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd><mi>a</mi><mo>≥</mo><mn>1</mn><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">a* = \begin{cases}
  \frac{1}{1 - a} &amp; \quad \text{if  } &amp; 0 \leq a \lt 1, \\
  \infty          &amp; \quad \text{if  } &amp; a \geq 1.
\end{cases}</annotation></semantics></math></p>
<p>So, combining the probability with the type-level business, the star of <code>Writer s a</code> is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Either</span> (<span class="dv">1</span>, a) (a, s <span class="fu">/</span> (<span class="dv">1</span> <span class="fu">-</span> s), star (<span class="dt">Writer</span> s a))</code></pre></div>
<p>Or, to put it another way: the odds monad!</p>
<h2 id="endo">Endo</h2>
<p>An <a href="https://ncatlab.org/nlab/show/endomorphism">endomorphism</a> is a morphism from an object to itself. A less general definition (and the one <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Endo">most often used</a> in Haskell) is a function of the type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="fu">=</span> <span class="dt">Endo</span> {<span class="ot"> appEndo ::</span> a <span class="ot">-&gt;</span> a }</code></pre></div>
<p>It forms a monoid under composition:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Endo</span> id
  mappend (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</code></pre></div>
<p>If the underlying type is itself a commutative monoid, it also forms near-semiring:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span>
  <span class="dt">Endo</span> f <span class="fu">&lt;+&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&lt;&gt;</span> g x)
  zero <span class="fu">=</span> <span class="dt">Endo</span> (const mempty)
  one <span class="fu">=</span> <span class="dt">Endo</span> id
  <span class="dt">Endo</span> f <span class="fu">&lt;.&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)
  
<span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span>
  star (<span class="dt">Endo</span> f) <span class="fu">=</span> <span class="dt">Endo</span> converge <span class="kw">where</span>
    converge x <span class="fu">=</span> x <span class="fu">&lt;&gt;</span> (<span class="kw">if</span> y <span class="fu">==</span> mempty <span class="kw">then</span> y <span class="kw">else</span> converge y) <span class="kw">where</span>
      y <span class="fu">=</span> f x</code></pre></div>
<p>Here’s something interesting: there’s a similarity here to the semiring for church numerals. In fact, as far as I can tell, the functions are <em>exactly</em> the same when applied to endomorphisms of endomorphisms. To the extent that you could define church numerals with something as simple as this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ChurchEndoNat</span> <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">Endo</span> (<span class="dt">Endo</span> a)</code></pre></div>
<p>And it works!</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">two,<span class="ot"> three ::</span> <span class="dt">ChurchEndoNat</span>
two <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> one
three <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> two

<span class="ot">unChurch ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">ChurchEndoNat</span> <span class="ot">-&gt;</span> a
unChurch f <span class="fu">=</span> appEndo (appEndo f (<span class="dt">Endo</span> (<span class="dv">1</span><span class="fu">+</span>))) <span class="dv">0</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">unChurch (two <span class="fu">&lt;.&gt;</span> three)
<span class="dv">6</span></code></pre></div>
<h2 id="regex">Regex</h2>
<p>One of the most important applications (and a source of much of the notation) is regular expressions. In fact, the free semiring looks like a haskell datatype for regular expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FreeStar</span> a
 <span class="fu">=</span> <span class="dt">Gen</span> a
 <span class="fu">|</span> <span class="dt">Zer</span>
 <span class="fu">|</span> <span class="dt">One</span>
 <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;+&gt;</span> <span class="dt">FreeStar</span> a
 <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;.&gt;</span> <span class="dt">FreeStar</span> a
 <span class="fu">|</span> <span class="dt">Star</span> (<span class="dt">FreeStar</span> a)

<span class="kw">instance</span> <span class="dt">Semiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span>
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;+&gt;</span>)
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;.&gt;</span>)
  zero <span class="fu">=</span> <span class="dt">Zer</span>
  one <span class="fu">=</span> <span class="dt">One</span>
  
<span class="kw">instance</span> <span class="dt">StarSemiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span>
  star <span class="fu">=</span> <span class="dt">Star</span>
  
<span class="ot">interpret ::</span> <span class="dt">StarSemiring</span> s <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> a <span class="ot">-&gt;</span> s
interpret f <span class="fu">=</span> \<span class="kw">case</span>
  <span class="dt">Gen</span> x <span class="ot">-&gt;</span> f x
  <span class="dt">Zer</span> <span class="ot">-&gt;</span> zero
  <span class="dt">One</span> <span class="ot">-&gt;</span> one
  l <span class="fu">:&lt;+&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;+&gt;</span> interpret f r
  l <span class="fu">:&lt;.&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;.&gt;</span> interpret f r
  <span class="dt">Star</span> x <span class="ot">-&gt;</span> star (interpret f x)</code></pre></div>
<p>Then, interpreting the regex is as simple as writing an interpreter (with some help from <code class="sourceCode haskell"><span class="dt">Endo</span></code>):</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">asRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
asRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo (interpret f fs) <span class="fu">.</span> pure <span class="kw">where</span>
  f p <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span>
    (x<span class="fu">:</span>xs) <span class="fu">|</span> p x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs
    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

<span class="ot">char&#39; ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
char&#39; c <span class="fu">=</span> <span class="dt">Gen</span> (c<span class="fu">==</span>)</code></pre></div>
<p>Actually, you don’t need the free version at all!</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">runRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> [[a]] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
runRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo fs <span class="fu">.</span> pure

<span class="ot">char ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> [[a]]
char c <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span>
  (x<span class="fu">:</span>xs) <span class="fu">|</span> c <span class="fu">==</span> x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs
  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>  </code></pre></div>
<p>With some <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedStrings</span></code> magic, you get a pretty nice interface:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Endo</span> [<span class="dt">String</span>]) <span class="kw">where</span>
  fromString <span class="fu">=</span> mul <span class="fu">.</span> map char <span class="fu">.</span> reverse
  
<span class="ot">(&lt;^&gt;) ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
(<span class="fu">&lt;^&gt;</span>) <span class="fu">=</span> flip (<span class="fu">&lt;.&gt;</span>)

<span class="ot">greet ::</span> <span class="dt">Endo</span> [<span class="dt">String</span>]
greet <span class="fu">=</span> <span class="st">&quot;H&quot;</span> <span class="fu">&lt;^&gt;</span> (<span class="st">&quot;a&quot;</span> <span class="fu">&lt;+&gt;</span> <span class="st">&quot;e&quot;</span>) <span class="fu">&lt;^&gt;</span> <span class="st">&quot;llo&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">runRegex greet <span class="st">&quot;Hello&quot;</span>
<span class="dt">True</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">runRegex greet <span class="st">&quot;Hallo&quot;</span>
<span class="dt">True</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">runRegex greet <span class="st">&quot;Halo&quot;</span>
<span class="dt">False</span></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>Of course, that’s about as slow as it gets when it comes to regexes. A faster representation is a <a href="https://swtch.com/~rsc/regexp/regexp1.html">nondeterministic finite automaton</a>. One such implementation in haskell is <a href="https://github.com/Gabriel439/slides/blob/master/regex/regex.md">Gabriel Gonzalez’s</a>.</p>
<p>The regex type in that example can be immediately made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> and <code class="sourceCode haskell"><span class="dt">StarSemiring</span></code>. However, it might be more interesting to translate the <em>implementation</em> into using semirings. The type of a regex looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span>

{<span class="ot"> _startingStates         ::</span> <span class="dt">Set</span> <span class="dt">State</span>
,<span class="ot"> _transitionFunction     ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span>
,<span class="ot"> _acceptingStates        ::</span> <span class="dt">Set</span> <span class="dt">State</span> }</code></pre></div>
<p>The set data structure jumps out as an opportunity to sub in arbitrary semirings.Swapping in the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> is reasonably easy:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="kw">data</span> <span class="dt">Regex</span> i s <span class="fu">=</span> <span class="dt">Regex</span>
  {<span class="ot"> _numberOfStates     ::</span> <span class="dt">Int</span> 
  ,<span class="ot"> _startingStates     ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s
  ,<span class="ot"> _transitionFunction ::</span> i <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s
  ,<span class="ot"> _acceptingStates    ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s }

<span class="ot">isEnd ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Regex</span> i s <span class="ot">-&gt;</span> s
isEnd (<span class="dt">Regex</span> _ as _ bs) <span class="fu">=</span> add (intersection as bs)

<span class="ot">match ::</span> <span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
match r <span class="fu">=</span> getAdd <span class="fu">.</span> isEnd <span class="fu">.</span> foldl&#39; run r <span class="kw">where</span>
  run (<span class="dt">Regex</span> n (<span class="dt">GeneralMap</span> as) f bs) i <span class="fu">=</span> <span class="dt">Regex</span> n as&#39; f bs
    <span class="kw">where</span> as&#39; <span class="fu">=</span> mconcat [ fmap (v<span class="fu">&lt;.&gt;</span>) (f i k)  <span class="fu">|</span> (k,v) <span class="ot">&lt;-</span> Map.assocs as ]


<span class="ot">satisfy ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> s)
satisfy predicate <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">2</span> as f bs
  <span class="kw">where</span>
    as <span class="fu">=</span> singleton <span class="dv">0</span>
    bs <span class="fu">=</span> singleton <span class="dv">1</span>

    f i <span class="dv">0</span> <span class="fu">=</span> assoc <span class="dv">1</span> (predicate i) mempty
    f _ _ <span class="fu">=</span> mempty

<span class="ot">once ::</span> <span class="dt">Eq</span> i <span class="ot">=&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> <span class="dt">Bool</span>)
once x <span class="fu">=</span> satisfy (<span class="fu">==</span> x)

<span class="ot">shift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s
shift n <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.fromAscList <span class="fu">.</span> (map<span class="fu">.</span>first) (<span class="fu">+</span> n) <span class="fu">.</span> Map.toAscList <span class="fu">.</span> getMap

<span class="kw">instance</span> (<span class="dt">Semiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span>

  one <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">1</span> (singleton <span class="dv">0</span>) (\_ _ <span class="ot">-&gt;</span> mempty) (singleton <span class="dv">0</span>)
  zero <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">0</span> mempty (\_ _ <span class="ot">-&gt;</span> mempty) mempty

  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;+&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs
    <span class="kw">where</span>
      n  <span class="fu">=</span> nL <span class="fu">+</span> nR
      as <span class="fu">=</span> mappend asL (shift nL asR)
      bs <span class="fu">=</span> mappend bsL (shift nL bsR)
      f i s <span class="fu">|</span> s <span class="fu">&lt;</span> nL    <span class="fu">=</span> fL i s
            <span class="fu">|</span> otherwise <span class="fu">=</span> shift nL (fR i (s <span class="fu">-</span> nL))

  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;.&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs <span class="kw">where</span>

    n <span class="fu">=</span> nL <span class="fu">+</span> nR

    as <span class="fu">=</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection asL bsL)
         <span class="kw">in</span> mappend asL (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))

    f i s <span class="fu">=</span>
        <span class="kw">if</span> s <span class="fu">&lt;</span> nL
        <span class="kw">then</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection r bsL)
             <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))
        <span class="kw">else</span> shift nL (fR i (s <span class="fu">-</span> nL))
      <span class="kw">where</span>
        r <span class="fu">=</span> fL i s
    bs <span class="fu">=</span> shift nL bsR

<span class="kw">instance</span> (<span class="dt">StarSemiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span>
  star (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f&#39; as
    <span class="kw">where</span>
      f&#39; i s <span class="fu">=</span>
          <span class="kw">let</span> r <span class="fu">=</span> f i s
              ss <span class="fu">=</span> add (intersection r bs)
          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)

  plus (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f&#39; bs
    <span class="kw">where</span>
      f&#39; i s <span class="fu">=</span>
          <span class="kw">let</span> r <span class="fu">=</span> f i s
              ss <span class="fu">=</span> add (intersection r bs)
          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)


<span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>)) <span class="kw">where</span>
  fromString <span class="fu">=</span> mul <span class="fu">.</span> map once</code></pre></div>
<p>This begins to show some of the real power of using semirings and covectors. We have a normal regular expression implementation when we use the covector over bools. Use the probability semiring, and you’ve got probabilistic parsing.</p>
<p>Swap in the <a href="https://ncatlab.org/nlab/show/max-plus+algebra">tropical semiring</a>: a semiring over the reals where addition is the max function, and multiplication is addition of reals. Now you’ve got a depth-first parser.</p>
<p>That’s how you might swap in different interpretations. How about swapping in different <em>implementations</em>? Well, there might be some use to swapping in the <a href="https://en.wikipedia.org/wiki/CYK_algorithm">CYK algorithm</a>, or the Gauss-Jordan-Floyd-Warshall-McNaughton-Yamada algorithm <span class="citation">(O’Connor <a href="#ref-oconnor_very_2011">2011</a>)</span>.</p>
<p>Alternatively, you can swap in the underlying data structure. Instead of a map, if you use an integer (each bit being a value, the keys being the bit position), you have a super-fast implementation (and the final implementation used in the original example). Finally, you could use a different representation of the state transfer function: a matrix.</p>
<h2 id="square-matrices">Square Matrices</h2>
<p>A square matrix can be understood as a map from pairs of indices to values. This lets us use it to represent the state transfer function. Take, for instance, a regular expression with three possible states. Its state transfer function might look like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">{</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd><mi>∅</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">transfer = \begin{cases}
1 \quad &amp; \{ 2, 3 \} \\
2 \quad &amp; \{ 1 \} \\
3 \quad &amp; \emptyset
\end{cases}</annotation></semantics></math></p>
<p>It has the type of:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">State</span></code> is an integer. You can represent the set as a vector, where each position is a key, and each value is whether or not that key is present:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd><mtable><mtr><mtd><mo stretchy="false" form="prefix">(</mo><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable></mtd></mtr><mtr><mtd><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd><mtable><mtr><mtd><mo stretchy="false" form="prefix">(</mo><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable></mtd></mtr><mtr><mtd><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd><mtable><mtr><mtd><mo stretchy="false" form="prefix">(</mo><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">transfer = \begin{cases}
1 \quad &amp; \begin{array} ( 0 &amp; 1 &amp; 1 ) \end{array} \\
2 \quad &amp; \begin{array} ( 1 &amp; 0 &amp; 0 ) \end{array} \\
3 \quad &amp; \begin{array} ( 0 &amp; 0 &amp; 0 ) \end{array}
\end{cases}</annotation></semantics></math></p>
<p>Then, the matrix representation is obvious:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">transfer = \left( \begin{array}{ccc}
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \end{array} \right)</annotation></semantics></math></p>
<p>This is the semiring of square matrices. It is, of course, yet <em>another</em> covector. The “keys” are the transfers: <code class="sourceCode haskell"><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dv">2</span></code> or <code class="sourceCode haskell"><span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dv">3</span></code>, represented by the indices of the matrix. The “values” are whether or not that transfer is permitted.</p>
<p>The algorithms for the usual semiring operations on matrices like this are well-known and well-optimized. I haven’t yet benchmarked them in Haskell using the matrix libraries, so I don’t know how they compare to the other approaches. In the meantime, there’s an elegant list-based implementation in <span class="citation">Dolan (<a href="#ref-dolan_fun_2013">2013</a>)</span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Matrix</span> a <span class="fu">=</span> <span class="dt">Scalar</span> a
              <span class="fu">|</span> <span class="dt">Matrix</span> [[a]]
              
<span class="ot">mjoin ::</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a) <span class="ot">-&gt;</span> <span class="dt">Matrix</span> a
mjoin (<span class="dt">Matrix</span> ws, <span class="dt">Matrix</span> xs, <span class="dt">Matrix</span> ys, <span class="dt">Matrix</span> zs) <span class="fu">=</span>
  <span class="dt">Matrix</span> ((zipWith (<span class="fu">++</span>) ws xs) <span class="fu">++</span> (zipWith (<span class="fu">++</span>) ys zs))
  
<span class="ot">msplit ::</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a)
msplit (<span class="dt">Matrix</span> (row<span class="fu">:</span>rows)) <span class="fu">=</span> 
  (<span class="dt">Matrix</span> [[first]], <span class="dt">Matrix</span> [top]
  ,<span class="dt">Matrix</span> left,      <span class="dt">Matrix</span> rest )
  <span class="kw">where</span>
    (first<span class="fu">:</span>top) <span class="fu">=</span> row
    (left,rest) <span class="fu">=</span> unzip (map (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> ([x],xs)) rows)
    
<span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span>
  zero <span class="fu">=</span> <span class="dt">Scalar</span> zero
  one <span class="fu">=</span> <span class="dt">Scalar</span> one
  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;+&gt;</span> y)
  <span class="dt">Matrix</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span>
    <span class="dt">Matrix</span> (zipWith (zipWith (<span class="fu">&lt;+&gt;</span>)) x y)
  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> m <span class="fu">=</span> m <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> x
  <span class="dt">Matrix</span> [[x]] <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> [[x <span class="fu">&lt;+&gt;</span> y]]
  x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> mjoin (first <span class="fu">&lt;+&gt;</span> y, top, left, rest <span class="fu">&lt;+&gt;</span> y)
    <span class="kw">where</span> (first, top, left, rest) <span class="fu">=</span> msplit x
  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;.&gt;</span> y)
  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (x<span class="fu">&lt;.&gt;</span>) y)
  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (<span class="fu">&lt;.&gt;</span>y) x)
  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> 
    <span class="dt">Matrix</span> [ [ foldl1 (<span class="fu">&lt;+&gt;</span>) (zipWith (<span class="fu">&lt;.&gt;</span>) row col) <span class="fu">|</span> col <span class="ot">&lt;-</span> cols ] 
           <span class="fu">|</span> row <span class="ot">&lt;-</span> x ] <span class="kw">where</span> cols <span class="fu">=</span> transpose y

<span class="kw">instance</span> <span class="dt">StarSemiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span>
  star (<span class="dt">Matrix</span> [[x]]) <span class="fu">=</span> <span class="dt">Matrix</span> [[star x]]
  star m <span class="fu">=</span> mjoin (first&#39; <span class="fu">&lt;+&gt;</span> top&#39; <span class="fu">&lt;.&gt;</span> rest&#39; <span class="fu">&lt;.&gt;</span> left&#39;
                 ,top&#39; <span class="fu">&lt;.&gt;</span> rest&#39;, rest&#39; <span class="fu">&lt;.&gt;</span> left&#39;, rest&#39;)
    <span class="kw">where</span>
      (first, top, left, rest) <span class="fu">=</span> msplit m
      first&#39; <span class="fu">=</span> star first
      top&#39; <span class="fu">=</span> first&#39; <span class="fu">&lt;.&gt;</span> top
      left&#39; <span class="fu">=</span> left <span class="fu">&lt;.&gt;</span> first&#39;
      rest&#39; <span class="fu">=</span> star (rest <span class="fu">&lt;+&gt;</span> left&#39; <span class="fu">&lt;.&gt;</span> top)</code></pre></div>
<h2 id="permutation-parsing">Permutation parsing</h2>
<p>A lot of the use from semirings comes from “attaching” them to other values. Attaching a semiring to effects (in the form of an applicative) can give you <em>repetition</em> of those effects. The excellent <a href="http://hackage.haskell.org/package/ReplicateEffects">ReplicateEffects</a> library explores this concept in depth.</p>
<p>It’s based on this type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Replicate</span> a b
  <span class="fu">=</span> <span class="dt">Nil</span>
  <span class="fu">|</span> <span class="dt">Cons</span> (<span class="dt">Maybe</span> b) (<span class="dt">Replicate</span> a (a <span class="ot">-&gt;</span> b))</code></pre></div>
<p>This type can be made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> (and <code class="sourceCode haskell"><span class="dt">Starsemiring</span></code>, etc) trivially.</p>
<p>In the simplest case, it has the same behaviour as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#v:replicateM"><code class="sourceCode haskell">replicateM</code></a>. Even the more complex combinators, like <code class="sourceCode haskell">atLeast</code>, can be built on <code class="sourceCode haskell"><span class="dt">Alternative</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">atLeast ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]
atLeast m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span>
  go <span class="dv">0</span> <span class="fu">=</span> many f
  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>))
  
<span class="ot">atMost ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]
atMost m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span>
  go <span class="dv">0</span> <span class="fu">=</span> pure []
  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>)) <span class="fu">&lt;|&gt;</span> pure []</code></pre></div>
<p>There are two main benefits over using the standard alternative implementation. First, you can choose greedy or lazy evaluation of the effects <em>after</em> the replication is built.</p>
<p>Secondly, the <em>order</em> of the effects doesn’t have to be specified. This allows you to execute permutations of the effects, in a permutation parser, for instance. The permutation is totally decoupled from the declaration of the repetition (it’s in a totally separate library, in fact: <a href="http://hackage.haskell.org/package/PermuteEffects">PermuteEffects</a>). Its construction is reminiscent of the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html#t:AltF">free alternative</a>.</p>
<p>Having the replicate type conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> is all well and good: what I’m interested in is seeing if its implementation is another semiring-based object in disguise. I’ll revisit this in a later post.</p>
<h2 id="algebraic-search">Algebraic Search</h2>
<p>List comprehension notation is one of my all-time favourite bits of syntactic sugar. It seems almost <em>too</em> declarative to have a reasonable implementation strategy. The vast majority of the time, it actually works in a sensible way. There are exceptions, though. Take a reasonable definition of a list of Pythagorean triples:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</code></pre></div>
<p>This expression will diverge without yielding a single triple. It will search through every possible value for <code class="sourceCode haskell">z</code> before incrementing either <code class="sourceCode haskell">x</code> or <code class="sourceCode haskell">y</code>. Since there are infinite values for <code class="sourceCode haskell">z</code>, it will never find a triple. In other words, vanilla list comprehensions in Haskell perform depth-first search.</p>
<p>In order to express other kinds of search (either breadth-first or depth-bounded), different monads are needed. These monads are explored in <span class="citation">Fischer (<a href="#ref-fischer_reinventing_2009">2009</a>)</span> and <span class="citation">Spivey (<a href="#ref-spivey_algebras_2009">2009</a>)</span>.</p>
<p>You can actually use the <em>exact</em> same notation as above with arbitrary alternative monads using <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XMonadComprehensions</span></code> and <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedLists</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">trips ::</span> ( <span class="dt">Alternative</span> m
         , <span class="dt">Monad</span> m
         , <span class="dt">IsList</span> (m <span class="dt">Integer</span>)
         , <span class="dt">Enum</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>))
         , <span class="dt">Num</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>)))
      <span class="ot">=&gt;</span> m (<span class="dt">Integer</span>,<span class="dt">Integer</span>,<span class="dt">Integer</span>)
trips <span class="fu">=</span> [ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</code></pre></div>
<p>So then, here’s the challenge: swap in different <code class="sourceCode haskell">m</code>s via a type annotation, and prevent <code class="sourceCode haskell">trips</code> from diverging before getting any triples.</p>
<p>As one example, here’s some code adapted from <span class="citation">Fischer (<a href="#ref-fischer_reinventing_2009">2009</a>)</span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Monoid</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">ContT</span> (const (pure mempty))
  mappend (<span class="dt">ContT</span> f) (<span class="dt">ContT</span> g) <span class="fu">=</span> <span class="dt">ContT</span> (\x <span class="ot">-&gt;</span> liftA2 mappend (f x) (g x))
  
<span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> 
  {<span class="ot"> runList ::</span> forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Cont</span> m a } <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">List</span> <span class="kw">where</span> foldMap <span class="fu">=</span> flip (runCont<span class="fu">.</span>runList)
  
<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">List</span> a) <span class="kw">where</span> show <span class="fu">=</span> show <span class="fu">.</span> foldr (<span class="fu">:</span>) []

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  mappend (<span class="dt">List</span> x) (<span class="dt">List</span> y) <span class="fu">=</span> <span class="dt">List</span> (mappend x y)
  mempty <span class="fu">=</span> <span class="dt">List</span> mempty
  
<span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  zero <span class="fu">=</span> mempty
  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> mappend
  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend
  one <span class="fu">=</span> pure mempty

<span class="ot">bfs ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> [a]
bfs <span class="fu">=</span> toList <span class="fu">.</span> fold <span class="fu">.</span> levels <span class="fu">.</span> anyOf

<span class="kw">newtype</span> <span class="dt">Levels</span> a <span class="fu">=</span> <span class="dt">Levels</span> {<span class="ot"> levels ::</span> [<span class="dt">List</span> a] } <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]
  <span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs <span class="fu">=</span> <span class="dt">Levels</span> [ f <span class="fu">&lt;*&gt;</span> x <span class="fu">|</span> f <span class="ot">&lt;-</span> fs, x <span class="ot">&lt;-</span> xs ]
  
<span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Levels</span> <span class="kw">where</span>
  empty <span class="fu">=</span> <span class="dt">Levels</span> []
  <span class="dt">Levels</span> x <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> y <span class="fu">=</span> <span class="dt">Levels</span> (mempty <span class="fu">:</span> merge x y)

<span class="kw">instance</span> <span class="dt">IsList</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">List</span> a) <span class="fu">=</span> a
  fromList <span class="fu">=</span> anyOf
  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []
  
<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">List</span> <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">List</span> (pure x)
  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap

<span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">List</span> <span class="kw">where</span>
  empty <span class="fu">=</span> mempty
  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> mappend

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">List</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldMap f x

<span class="ot">anyOf ::</span> (<span class="dt">Alternative</span> m, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a
anyOf <span class="fu">=</span> getAlt <span class="fu">.</span> foldMap (<span class="dt">Alt</span> <span class="fu">.</span> pure)

<span class="ot">merge ::</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a]
merge []      ys    <span class="fu">=</span> ys
merge xs      []    <span class="fu">=</span> xs
merge (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> mappend x y <span class="fu">:</span> merge xs ys</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">take <span class="dv">3</span> (bfs trips)
[(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>)]</code></pre></div>
<p>The only relevance to semirings is the merge function. The semiring over lists is the semiring over polynomials:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span>
  one <span class="fu">=</span> [one]
  zero <span class="fu">=</span> []
  [] <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> ys
  xs <span class="fu">&lt;+&gt;</span> [] <span class="fu">=</span> xs
  (x<span class="fu">:</span>xs) <span class="fu">&lt;+&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">:</span> (xs <span class="fu">&lt;+&gt;</span> ys)
  [] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []
  _ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []
  (x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span>
    (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">:</span> (map (x <span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> map (<span class="fu">&lt;.&gt;</span> y) xs <span class="fu">&lt;+&gt;</span> (xs <span class="fu">&lt;.&gt;</span> ys))</code></pre></div>
<p>The <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> is the same as the <code class="sourceCode haskell">merge</code> function. I think the <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> might be a more valid definition of the <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> function, also.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]
  <span class="dt">Levels</span> [] <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span> <span class="dt">Levels</span> []
  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> [] <span class="fu">=</span> <span class="dt">Levels</span> []
  <span class="dt">Levels</span> (f<span class="fu">:</span>fs) <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Levels</span> <span class="fu">$</span>
    (f <span class="fu">&lt;*&gt;</span> x) <span class="fu">:</span> levels (<span class="dt">Levels</span> (fmap (f <span class="fu">&lt;*&gt;</span>) xs) 
             <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> (fmap (<span class="fu">&lt;*&gt;</span> x) fs)
             <span class="fu">&lt;|&gt;</span> (<span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs))</code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>I’ve only scratched the surface of this abstraction. There are several other interesting semirings: polynomials, logs, Viterbi, Łukasiewicz, languages, multisets, bidirectional parsers, etc. Hopefully I’ll eventually be able to put this stuff into a library or something. In the meantime, I definitely will write some posts on the application to context-free parsing, bidirectional parsing (I just read <span class="citation">Breitner (<a href="#ref-breitner_showcasing_2016">2016</a>)</span>) and search.</p>
<h2 id="references" class="unnumbered">References</h2>
<div id="refs" class="references">
<div id="ref-boom_further_1981">
<p>Boom, H. J. 1981. “Further thoughts on abstracto.” <em>Working Paper ELC-9, IFIP WG 2.1</em>. <a href="http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf" class="uri">http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf</a>.</p>
</div>
<div id="ref-breitner_showcasing_2016">
<p>Breitner, Joachim. 2016. “Showcasing applicative. Joachim breitner’s blog.” <a href="http://www.joachim-breitner.de/blog/710-Showcasing_Applicative" class="uri">http://www.joachim-breitner.de/blog/710-Showcasing_Applicative</a>.</p>
</div>
<div id="ref-doel_free_2015">
<p>Doel, Dan. 2015. “Free monoids in haskell. The comonad.Reader.” <a href="http://comonad.com/reader/2015/free-monoids-in-haskell/" class="uri">http://comonad.com/reader/2015/free-monoids-in-haskell/</a>.</p>
</div>
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. “Fun with semirings: A functional pearl on the abuse of linear algebra.” In, 48:101. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500613">10.1145/2500365.2500613</a>. <a href="https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf" class="uri">https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf</a>.</p>
</div>
<div id="ref-droste_semirings_2009">
<p>Droste, Manfred, and Werner Kuich. 2009. “Semirings and formal power series.” In <em>Handbook of weighted automata</em>, ed by. Manfred Droste, Werner Kuich, and Heiko Vogler, 1:3–28. Monographs in theoretical computer science. an EATCS series. Berlin, Heidelberg: Springer Berlin Heidelberg. <a href="http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf">http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf</a>.</p>
</div>
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. <a href="http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a" class="uri">http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a</a>.</p>
</div>
<div id="ref-fischer_reinventing_2009">
<p>Fischer, Sebastian. 2009. “Reinventing haskell backtracking.” In <em>Informatik 2009, im fokus das leben (ATPS’09)</em>. GI Edition. <a href="http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf" class="uri">http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf</a>.</p>
</div>
<div id="ref-hirschowitz_modules_2010">
<p>Hirschowitz, André, and Marco Maggesi. 2010. “Modules over monads and initial semantics.” <em>Information and Computation</em> 208 (5). Special issue: 14th workshop on logic, language, information and computation (WoLLIC 2007) (May 1): 545–564. doi:<a href="https://doi.org/10.1016/j.ic.2009.07.003">10.1016/j.ic.2009.07.003</a>. <a href="https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf" class="uri">https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.” <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-kmett_free_2011">
<p>Kmett, Edward. 2011a. “Free monads for less (part 2 of 3): Yoneda. The comonad.Reader.” <a href="http://comonad.com/reader/2011/free-monads-for-less-2/" class="uri">http://comonad.com/reader/2011/free-monads-for-less-2/</a>.</p>
</div>
<div id="ref-kmett_modules_2011">
<p>———. 2011b. “Modules and functional linear functionals. The comonad.Reader.” <a href="http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/" class="uri">http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory efficient implementation of probability monads.” <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf" class="uri">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-oconnor_very_2011">
<p>O’Connor, Russell. 2011. “A very general method of computing shortest paths. Russell o’Connor’s blog.” <a href="http://r6.ca/blog/20110808T035622Z.html" class="uri">http://r6.ca/blog/20110808T035622Z.html</a>.</p>
</div>
<div id="ref-piponi_monad_2009">
<p>Piponi, Dan. 2009. “A monad for combinatorial search with heuristics. A neighborhood of infinity.” <a href="http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html" class="uri">http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. “From monoids to near-semirings: The essence of MonadPlus and alternative.” In <em>Proceedings of the 17th international symposium on principles and practice of declarative programming</em>, 196–207. ACM. doi:<a href="https://doi.org/10.1145/2790449.2790514">10.1145/2790449.2790514</a>. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf" class="uri">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. “Algebras for combinatorial search.” <em>Journal of Functional Programming</em> 19 (3): 469–487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>. <a href="http://www.journals.cambridge.org/abstract_S0956796809007321" class="uri">http://www.journals.cambridge.org/abstract_S0956796809007321</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Thu, 17 Nov 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-11-17-semirings-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Probability Trees</title>
    <link>http://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 30, 2016
</div>
<div class="info">
    
        Part 3 of a <a href="/series/probability.html">3-part series on probability</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span>
<span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span>

<span class="kw">module</span> <span class="dt">ProbTree</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Data.Ratio</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span></code></pre></div>
<p>Previously, I tried to figure out how to make the probability monad more “listy”. I read a little more about the topic <span class="citation">(especially Erwig and Kollmansberger <a href="#ref-erwig_functional_2006">2006</a>; and Kidd <a href="#ref-kidd_build_2007">2007</a>)</span>.</p>
<p>I then thought about what a probability monad would look like if it was based on other data structures. I feel like the standard version really wants to be:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ProperProb</span> a <span class="fu">=</span> <span class="dt">ProperProb</span>
  {<span class="ot"> yes ::</span> <span class="dt">Map</span> a (<span class="dt">Product</span> <span class="dt">Rational</span>) }</code></pre></div>
<p>But of course a monad instance isn’t allowed.</p>
<p>Similar to a map, though, is a binary tree:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span>
                  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)</code></pre></div>
<p>And it feels better for probability - <em>flatter</em>, somehow. Transmuting it into a probability-thing:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certain</span> a
            <span class="fu">|</span> <span class="dt">Choice</span> (<span class="dt">Odds</span> a) <span class="dt">Rational</span> (<span class="dt">Odds</span> a)
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</code></pre></div>
<p>That looks good to me. A choice between two different branches feels more natural than a choice between a head and a tail.</p>
<p>The fold is similar to before, with an unfold for good measure:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b
foldOdds f b <span class="fu">=</span> r <span class="kw">where</span>
  r (<span class="dt">Certain</span> x) <span class="fu">=</span> b x
  r (<span class="dt">Choice</span> xs p ys) <span class="fu">=</span> f (r xs) p (r ys)
  
<span class="ot">unfoldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Either</span> a (b,<span class="dt">Rational</span>,b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
unfoldOdds f <span class="fu">=</span> r <span class="kw">where</span>
  r b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span>
    <span class="dt">Left</span> a <span class="ot">-&gt;</span> <span class="dt">Certain</span> a
    <span class="dt">Right</span> (x,p,y) <span class="ot">-&gt;</span> <span class="dt">Choice</span> (r x) p (r y)
  
<span class="ot">fi ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
fi <span class="dt">True</span>  t _ <span class="fu">=</span> t
fi <span class="dt">False</span> _ f <span class="fu">=</span> f</code></pre></div>
<p>I changed the pattern synonym a little:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">
<span class="ot">unRatio ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> (a,a)
unRatio <span class="fu">=</span> numerator   <span class="fu">&amp;&amp;&amp;</span> denominator 
      <span class="fu">&gt;&gt;&gt;</span> fromInteger <span class="fu">***</span> fromInteger

pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (unRatio <span class="ot">-&gt;</span> (n,d))</code></pre></div>
<p>Then, the <code class="sourceCode haskell">probOf</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOf e <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> fi (e <span class="fu">==</span> x) <span class="dv">1</span> <span class="dv">0</span>
  f x (n<span class="fu">:%</span>d) y <span class="fu">=</span> (x <span class="fu">*</span> n <span class="fu">+</span> y <span class="fu">*</span> d) <span class="fu">/</span> (n <span class="fu">+</span> d)</code></pre></div>
<p>This version doesn’t have the option for short-circuiting on the first value it finds.</p>
<p>For generating from lists, you can try to evenly divide the list among each branch.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">fromListOdds ::</span> (([b], <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromListOdds fr e <span class="fu">=</span> r <span class="kw">where</span>
  r [] <span class="fu">=</span> <span class="dt">Nothing</span>
  r xs <span class="fu">=</span> <span class="dt">Just</span> (unfoldOdds f (xs, length xs))
  f ([x],_) <span class="fu">=</span> <span class="dt">Left</span> (e x)
  f (xs ,n) <span class="fu">=</span> <span class="dt">Right</span> ((ys,l), fr (ys,l) <span class="fu">%</span> fr (zs,r), (zs,r)) <span class="kw">where</span>
    l <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span>
    r <span class="fu">=</span> n <span class="fu">-</span> l
    (ys,zs) <span class="fu">=</span> splitAt l xs

<span class="ot">equalOdds ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
equalOdds <span class="fu">=</span> fromListOdds (fromIntegral <span class="fu">.</span> snd) id

<span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromDistrib <span class="fu">=</span> fromListOdds (sum <span class="fu">.</span> map snd <span class="fu">.</span> fst) fst</code></pre></div>
<p>What’s really nice about this version is the fact that the old <code class="sourceCode haskell">append</code> is just the <code class="sourceCode haskell"><span class="dt">Choice</span></code> constructor, leaving the instances to be really nice:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
flatten <span class="fu">=</span> foldOdds <span class="dt">Choice</span> id

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Certain</span>
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)
  
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</code></pre></div>
<p>Finally, as a bonus, to remove duplicates:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">lcd ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
lcd <span class="fu">=</span> foldl&#39; (\a e <span class="ot">-&gt;</span> lcm a (denominator e)) <span class="dv">1</span>

<span class="ot">toDistrib ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> [(a,<span class="dt">Integer</span>)]
toDistrib <span class="fu">=</span> factorOut <span class="fu">.</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> [(x,<span class="dv">1</span>)]
  f l p r <span class="fu">=</span> (map<span class="fu">.</span>fmap) (n<span class="fu">%</span>t<span class="fu">*</span>) l <span class="fu">++</span> (map<span class="fu">.</span>fmap) (d<span class="fu">%</span>t<span class="fu">*</span>) r <span class="kw">where</span>
    n <span class="fu">=</span> numerator p
    d <span class="fu">=</span> denominator p
    t <span class="fu">=</span> n <span class="fu">+</span> d
  factorOut xs <span class="fu">=</span> (map<span class="fu">.</span>fmap) (numerator <span class="fu">.</span> (lcd&#39;<span class="fu">*</span>)) xs <span class="kw">where</span>
    lcd&#39; <span class="fu">=</span> fromIntegral <span class="fu">.</span> lcd <span class="fu">.</span> map snd <span class="fu">$</span> xs

<span class="ot">counts ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> n) <span class="ot">=&gt;</span> [(a,n)] <span class="ot">-&gt;</span> [(a,n)]
counts <span class="fu">=</span> 
  Map.assocs <span class="fu">.</span> 
  Map.fromListWith (<span class="fu">+</span>)
      
<span class="ot">compress ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
compress xs <span class="fu">=</span> <span class="kw">let</span> <span class="dt">Just</span> ys <span class="fu">=</span> (fromDistrib <span class="fu">.</span> counts <span class="fu">.</span> toDistrib) xs <span class="kw">in</span> ys</code></pre></div>
<p>After reading yet more on this, I found that the main issue with the monad is its performance. Two articles in particular: <span class="citation">Larsen (<a href="#ref-larsen_memory_2011">2011</a>)</span>, and <span class="citation">Scibior, Ghahramani, and Gordon (<a href="#ref-scibior_practical_2015">2015</a>)</span>, refer to a GADT implementation of the monad which maximises laziness.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. <a href="http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf">http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.” <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory efficient implementation of probability monads.” <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf" class="uri">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-scibior_practical_2015">
<p>Scibior, A., Z. Ghahramani, and A. D. Gordon. 2015. “Practical probabilistic programming with monads.” In <em>2015 ACM SIGPLAN symposium on haskell</em>, 50:165–176. ACM. <a href="http://mlg.eng.cam.ac.uk/pub/pdf/SciGhaGor15.pdf" class="uri">http://mlg.eng.cam.ac.uk/pub/pdf/SciGhaGor15.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 30 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Different Probability Monad</title>
    <link>http://doisinkidney.com/posts/2016-09-27-odds-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 27, 2016
</div>
<div class="info">
    
        Part 2 of a <a href="/series/probability.html">3-part series on probability</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>One of the more unusual monads is the “probability monad”:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span>
<span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span>
<span class="ot">{-# language BangPatterns #-}</span>

<span class="kw">module</span> <span class="dt">Prob</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Data.Ratio</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Probability</span> a <span class="fu">=</span> <span class="dt">Probability</span>
  {<span class="ot"> runProb ::</span> [(a,<span class="dt">Rational</span>)] }
  
<span class="kw">data</span> <span class="dt">Coin</span> <span class="fu">=</span> <span class="dt">Heads</span> <span class="fu">|</span> <span class="dt">Tails</span>

<span class="ot">toss ::</span> <span class="dt">Probability</span> <span class="dt">Coin</span>
toss <span class="fu">=</span> <span class="dt">Probability</span> [(<span class="dt">Heads</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>), (<span class="dt">Tails</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>)]</code></pre></div>
<p>Although it’s a little inefficient, it’s an elegant representation. I’ve written about it before <a href="2015-08-03-monty-hall.html">here</a>.</p>
<p>It has some notable deficiencies, though. For instance: the user has to constantly check that all the probabilities add up to one. Its list can be empty, which doesn’t make sense. Also, individual outcomes can appear more than once in the same list.</p>
<p>A first go a fixing the problem might look something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Distrib</span> a <span class="fu">=</span> <span class="dt">Distrib</span>
  {<span class="ot"> runDist ::</span> [(a,<span class="dt">Rational</span>)] }

<span class="ot">tossProb ::</span> <span class="dt">Distrib</span> <span class="dt">Coin</span>
tossProb <span class="fu">=</span> <span class="dt">Distrib</span> [(<span class="dt">Heads</span>, <span class="dv">1</span>), (<span class="dt">Tails</span>, <span class="dv">1</span>)]</code></pre></div>
<p>The type is the same as before: it’s the semantics which have changed. The second field of the tuples no longer have to add up to one. The list can still be empty, though, and now finding the probability of, say, the head, looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probHead ::</span> <span class="dt">Distrib</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probHead (<span class="dt">Distrib</span> xs<span class="fu">@</span>((_,p)<span class="fu">:</span>_)) <span class="fu">=</span> p <span class="fu">/</span> sum [ q <span class="fu">|</span> (_,q) <span class="ot">&lt;-</span> xs ]</code></pre></div>
<p>Infinite lists aren’t possible, either.</p>
<p>One other way to look at the problem is to mimic the structure of cons-lists. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certainly</span> a
            <span class="fu">|</span> <span class="dt">Odds</span> a <span class="dt">Rational</span> (<span class="dt">Odds</span> a)
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Here, the <code class="sourceCode haskell"><span class="dt">Odds</span></code> constructor (analogous to <code class="sourceCode haskell">(<span class="fu">:</span>)</code>) contains the betting-style odds of the head element vs. <em>the rest of the list</em>. The coin from before is represented by:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">tossOdds ::</span> <span class="dt">Odds</span> <span class="dt">Coin</span>
tossOdds <span class="fu">=</span> <span class="dt">Odds</span> <span class="dt">Heads</span> (<span class="dv">1</span> <span class="fu">%</span> <span class="dv">1</span>) (<span class="dt">Certainly</span> <span class="dt">Tails</span>)</code></pre></div>
<p>This representation has tons of nice properties. First, let’s use some pattern-synonym magic for rationals:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">pattern<span class="ot"> (:%) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span>
pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (numerator <span class="fu">&amp;&amp;&amp;</span> denominator <span class="ot">-&gt;</span> (n,d)) <span class="kw">where</span>
  n <span class="fu">:%</span> d <span class="fu">=</span> n <span class="fu">%</span> d</code></pre></div>
<p>Then, finding the probability of the head element is this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probHeadOdds ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probHeadOdds (<span class="dt">Certainly</span> _) <span class="fu">=</span> <span class="dv">1</span>
probHeadOdds (<span class="dt">Odds</span> _ (n <span class="fu">:%</span> d) _) <span class="fu">=</span> n <span class="fu">:%</span> (n <span class="fu">+</span> d)</code></pre></div>
<p>The representation can handle infinite lists no problem:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">probHeadOdds (<span class="dt">Odds</span> <span class="ch">&#39;a&#39;</span> (<span class="dv">1</span> <span class="fu">:%</span> <span class="dv">1</span>) undefined)
<span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span></code></pre></div>
<p>Taking the tail preserves semantics, also. To do some more involved manipulation, a fold helper is handy:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldOdds ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b
foldOdds f b <span class="fu">=</span> r <span class="kw">where</span>
  r (<span class="dt">Certainly</span> x) <span class="fu">=</span> b x
  r (<span class="dt">Odds</span> x p xs) <span class="fu">=</span> f x p (r xs)</code></pre></div>
<p>You can use this function to find the probability of a given item:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOfEvent ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOfEvent e <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> <span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
  f x n r <span class="fu">=</span> (<span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>This assumes that each item only occurs once. A function which combines multiple events might look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOf p <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
  f x n r <span class="fu">=</span> (<span class="kw">if</span> p x <span class="kw">then</span> r <span class="fu">+</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>Some utility functions to create <code class="sourceCode haskell"><span class="dt">Odds</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">equalOdds ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
equalOdds xs <span class="fu">=</span> <span class="kw">case</span> length xs <span class="kw">of</span>
  <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
  n <span class="ot">-&gt;</span> <span class="dt">Just</span> (foldr f undefined xs (n <span class="fu">-</span> <span class="dv">1</span>)) <span class="kw">where</span>
    f y a <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Certainly</span> y
    f y a n <span class="fu">=</span> <span class="dt">Odds</span> y (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (a (n <span class="fu">-</span> <span class="dv">1</span>))

<span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromDistrib [] <span class="fu">=</span> <span class="dt">Nothing</span>
fromDistrib xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> f (tot<span class="fu">*</span>lst) xs <span class="kw">where</span>
  (tot,lst) <span class="fu">=</span> foldl&#39; (\(<span class="fu">!</span>t,_) e <span class="ot">-&gt;</span> (t<span class="fu">+</span>e,e)) (<span class="dv">0</span>,undefined) (map snd xs)
  f _ [(x,_)] <span class="fu">=</span> <span class="dt">Certainly</span> x
  f n ((x,p)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Odds</span> x (mp <span class="fu">%</span> np) (f np xs) <span class="kw">where</span>
    mp <span class="fu">=</span> p <span class="fu">*</span> lst
    np <span class="fu">=</span> n <span class="fu">-</span> mp
                  
<span class="ot">probOfEach ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOfEach x xs <span class="fu">=</span> probOf (x<span class="fu">==</span>) xs

<span class="ot">propOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Rational</span>
propOf _ [] <span class="fu">=</span> <span class="dt">Nothing</span>
propOf x xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">.</span> uncurry (<span class="fu">%</span>) <span class="fu">$</span>
  foldl&#39; (\(<span class="fu">!</span>n,<span class="fu">!</span>m) e <span class="ot">-&gt;</span> (<span class="kw">if</span> x <span class="fu">==</span> e <span class="kw">then</span> n<span class="fu">+</span><span class="dv">1</span> <span class="kw">else</span> n, m<span class="fu">+</span><span class="dv">1</span>)) (<span class="dv">0</span>,<span class="dv">0</span>) xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">propOf x xs <span class="fu">==</span> fmap (probOfEach x) (equalOdds xs)</code></pre></div>
<p>And finally, the instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">append ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
append <span class="fu">=</span> foldOdds f <span class="dt">Odds</span> <span class="kw">where</span>
  f e r a p ys <span class="fu">=</span> <span class="dt">Odds</span> e ip (a op ys) <span class="kw">where</span>
    ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)
    op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
flatten <span class="fu">=</span> foldOdds append id

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Certainly</span>
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)
  
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</code></pre></div>
]]></description>
    <pubDate>Tue, 27 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-27-odds-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Revisiting a Trie in Haskell</title>
    <link>http://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 26, 2016
</div>
<div class="info">
    
        Part 2 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="conforming-to-foldable">Conforming to Foldable</h1>
<p>When I ended the last post, I had a nice <code class="sourceCode haskell"><span class="dt">Trie</span></code> datatype, with plenty of functions, but I couldn’t get it to conform to the standard Haskell classes. The problem was to do with the type variables in the Trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language GADTs, FlexibleInstances, TypeFamilies #-}</span>
<span class="ot">{-# language DeriveFoldable, DeriveFunctor, DeriveTraversable #-}</span>
<span class="ot">{-# language FunctionalDependencies, FlexibleInstances #-}</span>

<span class="kw">module</span> <span class="dt">Tries</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">IsList</span>(..))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OldTrie</span> a <span class="fu">=</span> <span class="dt">OldTrie</span>
  {<span class="ot"> otEndHere  ::</span> <span class="dt">Bool</span>
  ,<span class="ot"> otChildren ::</span> <span class="dt">Map</span> a (<span class="dt">OldTrie</span> a) }</code></pre></div>
<p>Although the type variable is <code class="sourceCode haskell">a</code>, the trie really contains <em>lists</em> of <code class="sourceCode haskell">a</code>s. At least, that’s what’s reflected in functions like <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">member</code>, etc.:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">member ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f otEndHere <span class="kw">where</span>
  f e a <span class="fu">=</span> maybe <span class="dt">False</span> a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> otChildren
  
<span class="ot">otInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a
otInsert <span class="fu">=</span> foldr f b <span class="kw">where</span>
  b (<span class="dt">OldTrie</span> _ c) <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">True</span> c
  f e a (<span class="dt">OldTrie</span> n c) <span class="fu">=</span> <span class="dt">OldTrie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)
  
<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">OldTrie</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">False</span> mempty
  <span class="dt">OldTrie</span> v c <span class="ot">`mappend`</span> <span class="dt">OldTrie</span> t d <span class="fu">=</span> 
    <span class="dt">OldTrie</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</code></pre></div>
<p>Realistically, the type which the trie contains is more like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Trie</span> (f a)</code></pre></div>
<p>That signature strongly hints at GADTs, as was indicated by <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">this stackoverflow answer</a>. The particular GADT which is applicable here is this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TrieSet</span> a <span class="kw">where</span> <span class="dt">TrieSet</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">tsEndHere ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
tsEndHere (<span class="dt">TrieSet</span> e _) <span class="fu">=</span> e

<span class="ot">tsChildren ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a])
tsChildren (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> c

<span class="ot">tsInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]
tsInsert <span class="fu">=</span> foldr f b <span class="kw">where</span>
<span class="ot">  b ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]
<span class="ot">  f ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (<span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]

  b (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">True</span> c
  f e a (<span class="dt">TrieSet</span> n c) <span class="fu">=</span> <span class="dt">TrieSet</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)
  
<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">False</span> Map.empty
  <span class="dt">TrieSet</span> v c <span class="ot">`mappend`</span> <span class="dt">TrieSet</span> t d <span class="fu">=</span> 
    <span class="dt">TrieSet</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</code></pre></div>
<p>Why lists and not a general <code class="sourceCode haskell"><span class="dt">Foldable</span></code>? Well, for the particular use I had in mind (conforming to the <code class="sourceCode haskell"><span class="dt">Foldable</span></code> typeclass), I need <code class="sourceCode haskell">(<span class="fu">:</span>)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">TrieSet</span> <span class="kw">where</span>
  foldr f b (<span class="dt">TrieSet</span> e c) <span class="fu">=</span> <span class="kw">if</span> e <span class="kw">then</span> f [] r <span class="kw">else</span> r <span class="kw">where</span>
    r <span class="fu">=</span> Map.foldrWithKey (flip <span class="fu">.</span> g <span class="fu">.</span> (<span class="fu">:</span>)) b c
    g k <span class="fu">=</span> foldr (f <span class="fu">.</span> k)</code></pre></div>
<p>With some more helper functions, the interface becomes pretty nice:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  showsPrec d t <span class="fu">=</span> 
    showParen 
      (d <span class="fu">&gt;</span> <span class="dv">10</span>)
      (showString <span class="st">&quot;fromList &quot;</span> <span class="fu">.</span> shows (foldr (<span class="fu">:</span>) [] t))

<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">TrieSet</span> [a]) <span class="fu">=</span> [a]
  fromList <span class="fu">=</span> foldr tsInsert mempty
  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</code></pre></div>
<p>The trie has the side-effect of lexicographically sorting what it’s given:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XGADTs</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">fromList [<span class="st">&quot;ced&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ced&quot;</span>, <span class="st">&quot;cb&quot;</span>, <span class="st">&quot;ab&quot;</span>]<span class="ot"> ::</span> <span class="dt">TrieSet</span> <span class="dt">String</span>
fromList [<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;abc&quot;</span>,<span class="st">&quot;cb&quot;</span>,<span class="st">&quot;ced&quot;</span>]</code></pre></div>
<h1 id="further-generalizing">Further Generalizing</h1>
<p>Most implementations of tries that I’ve seen are map-like data structures, rather than set-like. In other words, instead of holding a <code class="sourceCode haskell"><span class="dt">Bool</span></code> at the value position, it holds a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> something.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Trie</span> a b <span class="fu">=</span> <span class="dt">Trie</span>
  {<span class="ot"> endHere  ::</span> b
  ,<span class="ot"> children ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a b) 
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</code></pre></div>
<p>This is a much more straightforward datatype. <code class="sourceCode haskell"><span class="dt">Foldable</span></code> can even be automatically derived.</p>
<p>However, I haven’t made the <code class="sourceCode haskell">endHere</code> field a <code class="sourceCode haskell"><span class="dt">Maybe</span> a</code>. I want to be able to write something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieSet</span> [a] <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Bool</span>
<span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Maybe</span> b)</code></pre></div>
<p>And have it automatically choose the implementation of the functions I need<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>To do that, though, I’ll need to write the base functions, agnostic of the type of <code>b</code>. I <em>can</em> rely on something like <code class="sourceCode haskell"><span class="dt">Monoid</span></code>, though:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Trie</span> mempty Map.empty
  mappend (<span class="dt">Trie</span> v k) (<span class="dt">Trie</span> t l) <span class="fu">=</span> 
    <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) k l)</code></pre></div>
<p>In fact, quite a lot of functions naturally lend themselves to this fold + monoid style:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> b
lookup <span class="fu">=</span> foldr f endHere <span class="kw">where</span>
  f e a <span class="fu">=</span> foldMap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> children

<span class="ot">insert&#39; ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b
insert&#39; xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> 
    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c) </code></pre></div>
<p>A monoid is needed for the values, though, and neither <code class="sourceCode haskell"><span class="dt">Bool</span></code> nor <code class="sourceCode haskell"><span class="ot">∀</span> a<span class="fu">.</span> <span class="dt">Maybe</span> a</code> conform to <code class="sourceCode haskell"><span class="dt">Monoid</span></code>. Looking back to the implementation of the trie-set, the <code class="sourceCode haskell">(<span class="fu">||</span>)</code> function has been replaced by <code class="sourceCode haskell">mappend</code>. There <em>is</em> a newtype wrapper in <code class="sourceCode haskell"><span class="dt">Data.Monoid</span></code> which has exactly this behaviour, though: <code class="sourceCode haskell"><span class="dt">Any</span></code>.</p>
<p>Using that, the type signatures specialize to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieSet</span> a <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Any</span>
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">Any</span>
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Any</span> <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</code></pre></div>
<p>Similarly, for <code class="sourceCode haskell"><span class="dt">Maybe</span></code>, there’s both <code class="sourceCode haskell"><span class="dt">First</span></code> and <code class="sourceCode haskell"><span class="dt">Last</span></code>. They have the behaviour:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span class="dt">First</span> (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">First</span> (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">First</span> (<span class="dt">Just</span> x)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span class="dt">Last</span>  (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y)</code></pre></div>
<p>I think it makes more sense for a value inserted into a map to overwrite whatever was there before. Since the newer value is on the left in the <code class="sourceCode haskell">mappend</code>, then, <code class="sourceCode haskell"><span class="dt">First</span></code> makes most sense.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">First</span> b)
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">First</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</code></pre></div>
<p>There are some other ways that you can interpret the monoid. For instance, subbing in <code class="sourceCode haskell"><span class="dt">Sum</span> <span class="dt">Int</span></code> gives you a bag-like trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieBag</span> a <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Sum</span> <span class="dt">Int</span>)
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span>
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a</code></pre></div>
<p>This is a set which can store multiple copies of each member. Turned the other way around, a map which stores many values for each key looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieBin</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a [b]
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> [b]
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</code></pre></div>
<p>This method so far isn’t really satisfying, though. Really, the <code class="sourceCode haskell">insert</code> signatures should look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</code></pre></div>
<p>Modifying insert slightly, you can get exactly that:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Applicative</span> c, <span class="dt">Monoid</span> (c b)) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b) <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b)
insert xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (pure v <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</code></pre></div>
<p><code class="sourceCode haskell">pure</code> from <code class="sourceCode haskell"><span class="dt">Applicative</span></code> is needed for the “embedding”.</p>
<p>Similarly, the “inserting” for the set-like types isn’t really right. The value argument is out of place. This should be the signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a
<span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a</code></pre></div>
<p>In particular, while we have an “empty” thing (0, False) for monoids, we need a “one” thing (1, True) for this function. A semiring<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> gives this exact method:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> a <span class="kw">where</span>
<span class="ot">  one ::</span> a
<span class="ot">  mul ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
  
<span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Sum</span> a) <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dv">1</span>
  mul <span class="fu">=</span> (<span class="fu">*</span>)

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Any</span> <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dt">Any</span> <span class="dt">True</span>
  <span class="dt">Any</span> x <span class="ot">`mul`</span> <span class="dt">Any</span> y <span class="fu">=</span> <span class="dt">Any</span> (x <span class="fu">&amp;&amp;</span> y)</code></pre></div>
<p>This class is kind of like a combination of both monoid wrappers for both <code class="sourceCode haskell"><span class="dt">Int</span></code> and <code class="sourceCode haskell"><span class="dt">Bool</span></code>. You could take advantage of that:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">
<span class="kw">class</span> (<span class="dt">Monoid</span> add, <span class="dt">Monoid</span> mult)
  <span class="ot">=&gt;</span> <span class="dt">SemiringIso</span> a add mult <span class="fu">|</span> a <span class="ot">-&gt;</span> add, a <span class="ot">-&gt;</span> mult <span class="kw">where</span>
<span class="ot">    toAdd    ::</span> a <span class="ot">-&gt;</span> add
<span class="ot">    fromAdd  ::</span> add <span class="ot">-&gt;</span> a
<span class="ot">    toMult   ::</span> a <span class="ot">-&gt;</span> mult
<span class="ot">    fromMult ::</span> mult <span class="ot">-&gt;</span> a
  
(<span class="fu">&lt;+&gt;</span>),<span class="ot"> (&lt;.&gt;) ::</span> <span class="dt">SemiringIso</span> a add mult <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> fromAdd  (toAdd  x <span class="fu">&lt;&gt;</span> toAdd  y)
x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> fromMult (toMult x <span class="fu">&lt;&gt;</span> toMult y)

<span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Int</span> (<span class="dt">Sum</span> <span class="dt">Int</span>) (<span class="dt">Product</span> <span class="dt">Int</span>) <span class="kw">where</span>
  toAdd    <span class="fu">=</span> <span class="dt">Sum</span>
  fromAdd  <span class="fu">=</span> getSum
  toMult   <span class="fu">=</span> <span class="dt">Product</span>
  fromMult <span class="fu">=</span> getProduct

<span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Bool</span> <span class="dt">Any</span> <span class="dt">All</span> <span class="kw">where</span>
  toAdd    <span class="fu">=</span> <span class="dt">Any</span>
  fromAdd  <span class="fu">=</span> getAny
  toMult   <span class="fu">=</span> <span class="dt">All</span>
  fromMult <span class="fu">=</span> getAll</code></pre></div>
<p>But it seems like overkill.</p>
<p>Anyway, assuming that we have the functions from <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, here’s the <code>add</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) 
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b
add xs <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (one <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> 
    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</code></pre></div>
<p>Now, expressions can be built up without specifying the specific monoid implementation, and the whole behaviour can be changed with a type signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">Trie</span> a b) <span class="fu">=</span> [a]
  fromList <span class="fu">=</span> foldr add mempty
  toList <span class="fu">=</span> undefined
<span class="ot">ans ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">ans <span class="fu">=</span> lookup <span class="st">&quot;abc&quot;</span> (fromList [<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ghi&quot;</span>])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span class="ot">ans ::</span> <span class="dt">Sum</span> <span class="dt">Int</span>
<span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">2</span>}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span class="ot">ans ::</span> <span class="dt">Any</span>
<span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}</code></pre></div>
<p>Slightly fuller implementations of all of these are available <a href="https://github.com/oisdk/hstrie">here</a>.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Kind of like <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">program inference in lieu of type inference</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>This isn’t really a very good definition of semiring. While Haskell doesn’t have this class in base, <a href="https://github.com/purescript/purescript-prelude/blob/master/src/Data/Semiring.purs">Purescript has it in their prelude.</a><a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></description>
    <pubDate>Mon, 26 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Lenses are Static Selectors</title>
    <link>http://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 16, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>So I don’t really know what <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html">KVC</a> is, or much about <code class="sourceCode scala">performSelector</code> functions. <a href="http://inessential.com/2016/05/20/updating_local_objects_with_server_objec">This</a> blogpost, from Brent Simmons, let me know a little bit about why I would want to use them.</p>
<p>It centred around removing code repetition of this type:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {
  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span>
}

<span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {
  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span> <span class="co">// There was an (intentional)</span>
}                                    <span class="co">// bug here in the original post</span></code></pre></div>
<p>To clean up the code, Brent used selector methods. At first, I was a little uncomfortable with the solution. As far as I could tell, the basis of a lot of this machinery used functions with types like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">get</span>(fromSelector: String) -&gt; AnyObject?
func <span class="fu">set</span>(forSelector: String) -&gt; ()</code></pre></div>
<p>Which <em>seems</em> to be extremely dynamic. Stringly-typed and all that. Except that there are two different things going on here. One is the dynamic stuff; the ability to get rid of types when you need to. The other, though, has <em>nothing</em> to do with types. The other idea is being able to pass around something which can access the property (or method) of an object. Let’s look at the code that was being repeated:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {
  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span>
}

<span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {
  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span>
}</code></pre></div>
<p>The logical, obvious thing to do here is try refactor out the common elements. In fact, the only things that <em>differ</em> between the two actions above are the <code class="sourceCode scala">foo</code> and <code class="sourceCode scala">bar</code>. It would be great to be able to write a function like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">checkThenUpdate</span>(selector) {
  <span class="kw">if</span> localObject.<span class="fu">selector</span> != serverObject.<span class="fu">selector</span> {
    localObject.<span class="fu">selector</span> = serverObject.<span class="fu">selector</span>
  }
}</code></pre></div>
<p>And then maybe a single line like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">[foo, bar, baz].<span class="fu">forEach</span>(checkThenUpdate)</code></pre></div>
<p>That’s pretty obviously better. It’s just good programming: when faced with repetition, find the repeated part, and abstract it out. Is it more <em>dynamic</em> than the repetition, though? I don’t think so. All you have to figure out is an appropriate type for the selector, and you can keep all of your static checking. To me, it seems a lot like a <a href="https://hackage.haskell.org/package/lens">lens</a>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Lens&lt;Whole, Part&gt; {
  let get: Whole -&gt; Part
  let set: (Whole, Part) -&gt; Whole
}</code></pre></div>
<p>(This is a lens similar to the ones used in the <a href="http://hackage.haskell.org/package/data-lens">data-lens</a> library, in contrast to van Laarhoven lenses, or LensFamilies. LensFamilies are used in the <a href="https://hackage.haskell.org/package/lens">lens</a> package, and they allow you to change the type of the <code class="sourceCode scala">Part</code>. They’re also just normal functions, rather than a separate type, so you can manipulate them in a pretty standard way. Swift’s type system isn’t able to model those lenses, though, unfortunately.) It has two things: a getter and a setter. The getter is pretty obvious: it takes the object, and returns the property. The setter is a little more confusing. It’s taking an object, and the new property you want to stick in to the object, and returns the object with that property updated. For instance, if we were to make a <code class="sourceCode scala">Person</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct LocalPerson {
  <span class="kw">var</span> age: Int
  <span class="kw">var</span> name: String
}</code></pre></div>
<p>We could then have a lens for the <code class="sourceCode scala">name</code> field like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let localName: Lens&lt;LocalPerson,String&gt; = <span class="fu">Lens</span>(
  get: { p in p.<span class="fu">name</span> },
  set: { (oldPerson,newName) in
    <span class="kw">var</span> newPerson = oldPerson
    newPerson.<span class="fu">name</span> = newName
    <span class="kw">return</span> newPerson
  }
)</code></pre></div>
<p>And you’d use it like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let caoimhe = <span class="fu">LocalPerson</span>(age: <span class="dv">46</span>, name: <span class="st">&quot;caoimhe&quot;</span>)
localName.<span class="fu">get</span>(caoimhe) <span class="co">// 46</span>
localName.<span class="fu">set</span>(caoimhe, <span class="st">&quot;breifne&quot;</span>) <span class="co">// LocalPerson(age: 46, name: &quot;breifne&quot;)</span></code></pre></div>
<p>Straight away, we’re able to do (something) like the <code class="sourceCode scala">checkThenUpdate</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func checkThenUpdate
  &lt;A: Equatable&gt;
  (localLens: Lens&lt;LocalPerson,A&gt;, serverLens: Lens&lt;ServerPerson,A&gt;) {
  let serverProp = serverLens.<span class="fu">get</span>(serverObject)
  <span class="kw">if</span> localLens.<span class="fu">get</span>(localObject) != serverProp {
    localObject = localLens.<span class="fu">set</span>(localObject,serverProp)
  }
}</code></pre></div>
<p>And it could be called pretty tersely:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">checkThenUpdate</span>(localName, serverLens: serverName)</code></pre></div>
<p>The biggest problem with this approach, obviously, is the boilerplate. In Haskell, that’s solved with Template Haskell, so the lens code is generated for you. (I’d love to see something like that in Swift) There’s a protocol-oriented spin on lenses, also. One of the variants on lenses in Haskell are called “classy-lenses”. That’s where, instead of just generating a lens with the same name as the field it looks into, you generate a typeclass (protocol) for anything with that lens. In Swift, it might work something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Place {
  <span class="kw">var</span> name: String
}

<span class="co">// Instead of just having a lens for the name field, have a whole protocol</span>
<span class="co">// for things with a name field:</span>

protocol HasName {
  associatedtype Name
  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; { get }
  <span class="kw">var</span> name: Name { get set }
}

<span class="co">// Because the mutable property is included in the protocol, you can rely on</span>
<span class="co">// it in extensions:</span>

extension HasName {
  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; {
    <span class="kw">return</span> <span class="fu">Lens</span>(
      get: {$<span class="fl">0.</span>name},
      set: { (w,p) in 
        <span class="kw">var</span> n = w
        n.<span class="fu">name</span> = p
        <span class="kw">return</span> n
      }
    )
  }
  <span class="kw">var</span> name: Name {
    get { <span class="kw">return</span> Self.<span class="fu">name</span>.<span class="fu">get</span>(self) }
    set { self = Self.<span class="fu">name</span>.<span class="fu">set</span>(self,newValue) }
  }
}

<span class="co">// This way, you can provide either the lens or the property, and you get the</span>
<span class="co">// other for free.</span>

extension Place: HasName {}

<span class="co">// Then, you can rely on that protocol, and all of the types:</span>

func checkEqualOnNames
  &lt;A,B where A: HasName, B: HasName, A.<span class="fu">Name</span>: Equatable, A.<span class="fu">Name</span> == B.<span class="fu">Name</span>&gt;
  (x: A, _ y: B) -&gt; Bool {
    <span class="kw">return</span> x.<span class="fu">name</span> == y.<span class="fu">name</span>
}</code></pre></div>
<p>This protocol lets you do a kind of static <code class="sourceCode scala">respondsToSelector</code>, with all of the types intact. Other people have spoken about the other things you can do with lenses in Swift (<a href="https://www.youtube.com/watch?v=ofjehH9f-CU">Brandon Williams - Lenses in Swift</a>), like composing them together, chaining operations, etc. (One other thing they can emulate is <a href="https://gist.github.com/erica/6794d48d917e2084d6ed">method cascading</a>) Unfortunately, in current Swift, the boilerplate makes all of this a little unpleasant. Still, they’re an interesting idea, and they show how a good type system needn’t always get in the way.</p>
]]></description>
    <pubDate>Thu, 16 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Folding Two Things at Once</title>
    <link>http://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>There’s a whole family of Haskell brainteasers surrounding one function: <code class="sourceCode haskell">foldr</code>. The general idea is to convert some function on lists which uses recursion into one that uses <code class="sourceCode haskell">foldr</code>. <code class="sourceCode haskell">map</code>, for instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map f <span class="fu">=</span> foldr (\e a <span class="ot">-&gt;</span> f e <span class="fu">:</span> a) []</code></pre></div>
<p>Some can get a little trickier. <code class="sourceCode haskell">dropWhile</code>, for instance. (See <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">here</a> and <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">here</a> for interesting articles on that one in particular.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dropWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhile p <span class="fu">=</span> fst <span class="fu">.</span> foldr f ([],[]) <span class="kw">where</span>
  f e <span class="fu">~</span>(xs,ys) <span class="fu">=</span> (<span class="kw">if</span> p e <span class="kw">then</span> xs <span class="kw">else</span> zs, zs) <span class="kw">where</span> zs <span class="fu">=</span> e <span class="fu">:</span> ys</code></pre></div>
<h2 id="zip">Zip</h2>
<p>One function which was a little harder to convert than it first seemed was <code class="sourceCode haskell">zip</code>.</p>
<p>Here’s the first (non) solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> foldr f (const []) <span class="kw">where</span>
  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys
  f _ _  [] <span class="fu">=</span> []</code></pre></div>
<p>The problem with the above isn’t that it doesn’t work: it does. The problem is that it’s not <em>really</em> using <code class="sourceCode haskell">foldr</code>. It’s only using it on the first list: there’s still a manual uncons being performed on the second. Ideally, I would want the function to look something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs ys <span class="fu">=</span> foldr f (\_ _ <span class="ot">-&gt;</span> []) xs (foldr g (const []) ys)</code></pre></div>
<p>The best solution I found online only dealt with <code class="sourceCode haskell"><span class="dt">Fold</span></code>s, not <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s. You can read it <a href="http://okmij.org/ftp/Haskell/zip-folds.lhs">here</a>.</p>
<h2 id="recursive-types">Recursive Types</h2>
<p>Reworking the solution online for <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s, the initial intuition is to have the <code class="sourceCode haskell">foldr</code> on the <code class="sourceCode haskell">ys</code> produce a function which takes an element of the <code class="sourceCode haskell">xs</code>, and returns a function which takes an element of the <code class="sourceCode haskell">xs</code>, and so on, finally returning the created list. The <em>problem</em> with that approach is the types involved:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs <span class="fu">=</span> foldr f (const []) xs <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
  g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 r2)
  f e r x <span class="fu">=</span> x e r</code></pre></div>
<p>You get the error:</p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Occurs</span> check<span class="fu">:</span> cannot construct the infinite <span class="kw">type</span><span class="fu">:</span> t0 <span class="fu">~</span> a <span class="ot">-&gt;</span> (t0 <span class="ot">-&gt;</span> [(a, b)]) <span class="ot">-&gt;</span> [(a, b)]</code>.</p>
</blockquote>
<p>Haskell’s typechecker doesn’t allow for infinitely recursive types.</p>
<p>You’ll be familiar with this problem if you’ve ever tried to encode the Y-combinator, or if you’ve fiddled around with the recursion-schemes package. You might also be familiar with the solution: a <code class="sourceCode haskell"><span class="kw">newtype</span></code>, encapsulating the recursion. In this case, the <code class="sourceCode haskell"><span class="kw">newtype</span></code> looks very similar to the signature for <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecFold</span> a b <span class="fu">=</span> 
  <span class="dt">RecFold</span> {<span class="ot"> runRecFold ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecFold</span> a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b }</code></pre></div>
<p>Now you can insert and remove the <code class="sourceCode haskell"><span class="dt">RecFold</span></code> wrapper, helping the typechecker to understand the recursive types as it goes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs <span class="fu">=</span>
  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>As an aside, the performance characteristics of the <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper are totally opaque to me. There may be significant improvements by using <code class="sourceCode haskell">coerce</code> from <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Coerce.html">Data.Coerce</a>, but I haven’t looked into it.</p>
<h2 id="generalised-zips">Generalised Zips</h2>
<p>The immediate temptation from the function above is to generalise it. First to <code class="sourceCode haskell">zipWith</code>, obviously:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]
zipWith c xs <span class="fu">=</span>
  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>What’s maybe a little more interesting, though, would be a <code class="sourceCode haskell">foldr</code> on two lists. Something which folds through both at once, using a supplied combining function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldr2 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g)
       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c)
       <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> c
foldr2 c i xs <span class="fu">=</span>
  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> i) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>Of course, once you can do two, you can do three:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldr3 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g, <span class="dt">Foldable</span> h)
       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> d)
       <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> h c <span class="ot">-&gt;</span> d
foldr3 c i xs ys <span class="fu">=</span>
  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr2 g (\_ _ <span class="ot">-&gt;</span> i) ys <span class="kw">where</span>
    g e2 e3 r2 e1 r1 <span class="fu">=</span> c e1 e2 e3 (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>And so on.</p>
<p>There’s the added benefit that the above functions work on much more than just lists.</p>
<h2 id="catamorphisms">Catamorphisms</h2>
<p>Getting a little formal about the above functions, a <code class="sourceCode haskell">fold</code> can be described as a catamorphism. This is a name for a pattern of breaking down some recursive structure. There’s a bunch of them in the <a href="https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html">recursion-schemes</a> package. The question is, then: can you express the above as a kind of catamorphism? Initially, using the same techniques as before, you can:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecF</span> f a <span class="fu">=</span> <span class="dt">RecF</span> {<span class="ot"> unRecF ::</span> <span class="dt">Base</span> f (<span class="dt">RecF</span> f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a }

<span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)
     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">RecF</span> g c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">RecF</span> g c <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c)
     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c
zipo alg xs ys <span class="fu">=</span> cata (flip unRecF) ys (cata (<span class="dt">RecF</span> <span class="fu">.</span> alg) xs)</code></pre></div>
<p>Then, coming full circle, you get a quite nice encoding of <code class="sourceCode haskell">zip</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> zipo alg <span class="kw">where</span>
  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []
  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []
  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x, y) <span class="fu">:</span> ys xs</code></pre></div>
<p>However, the <code class="sourceCode haskell"><span class="dt">RecF</span></code> is a little ugly. In fact, it’s possible to write the above without any recursive types, using the RankNTypes extension. (It’s possible that you could do the same with <code class="sourceCode haskell">foldr2</code> as well, but I haven’t figured it out yet)</p>
<p>You can actually use a <code class="sourceCode haskell"><span class="kw">newtype</span></code> that’s provided by the recursion-schemes library as-is. It’s <code class="sourceCode haskell"><span class="dt">Mu</span></code>. This is required for an encoding of the Y-combinator. It’s usually presented in this form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Mu</span> a <span class="fu">=</span> <span class="dt">Roll</span> {<span class="ot"> unroll ::</span> <span class="dt">Mu</span> a <span class="ot">-&gt;</span> a }</code></pre></div>
<p>However, in the recursion-schemes package, its definition looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> (forall a<span class="fu">.</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a)</code></pre></div>
<p>No recursion! The <code class="sourceCode haskell">zipo</code> combinator above can be written using <code class="sourceCode haskell"><span class="dt">Mu</span></code> like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)
     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">Mu</span> (<span class="dt">Base</span> g) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">Mu</span> (<span class="dt">Base</span> g)) <span class="ot">-&gt;</span> c)
     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c
zipo alg xs <span class="fu">=</span> cata (\x <span class="ot">-&gt;</span> alg x <span class="fu">.</span> project) xs <span class="fu">.</span> refix</code></pre></div>
<p>And the new version of <code class="sourceCode haskell">zip</code> has a slightly more natural order of arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> zipo alg <span class="kw">where</span>
  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []
  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []
  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</code></pre></div>
<h2 id="zipping-into">Zipping Into</h2>
<p>There’s one more issue, though, that’s slightly tangential. A lot of the time, the attraction of rewriting functions using folds and catamorphisms is that the function becomes more general: it no longer is restricted to lists. For <code class="sourceCode haskell">zip</code>, however, there’s still a pesky list left in the signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> [(a,b)]</code></pre></div>
<p>It would be a little nicer to be able to zip through something <em>preserving</em> the structure of one of the things being zipped through. For no reason in particular, let’s assume we’ll preserve the structure of the first argument. The function will have to account for the second argument running out before the first, though. A <code class="sourceCode haskell"><span class="dt">Maybe</span></code> can account for that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) 
        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) 
        <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f c</code></pre></div>
<p>If the second argument runs out, <code class="sourceCode haskell"><span class="dt">Nothing</span></code> will be passed to the combining function.</p>
<p>It’s clear that this isn’t a <em>fold</em> over the first argument, it’s a <em>traversal</em>. A first go at the function uses the state monad, but restricts the second argument to a list:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c
zipInto c xs ys <span class="fu">=</span> evalState (traverse f xs) ys <span class="kw">where</span>
  f x <span class="fu">=</span> <span class="kw">do</span>
    h <span class="ot">&lt;-</span> gets uncons
    <span class="kw">case</span> h <span class="kw">of</span> 
      <span class="dt">Just</span> (y,t) <span class="ot">-&gt;</span> <span class="kw">do</span> 
        put t
        pure (c x (<span class="dt">Just</span> y))
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> pure (c x <span class="dt">Nothing</span>)</code></pre></div>
<p>That code can be cleaned up a little:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c 
zipInto c <span class="fu">=</span> evalState <span class="fu">.</span> traverse (state <span class="fu">.</span> f <span class="fu">.</span> c) <span class="kw">where</span>
  f x [] <span class="fu">=</span> (x <span class="dt">Nothing</span>, [])
  f x (y<span class="fu">:</span>ys) <span class="fu">=</span> (x (<span class="dt">Just</span> y), ys)</code></pre></div>
<p>But really, the uncons needs to go. Another <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper is needed, and here’s the end result:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecAccu</span> a b <span class="fu">=</span>
  <span class="dt">RecAccu</span> {<span class="ot"> runRecAccu ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecAccu</span> a b, b) }
  
<span class="ot">zipInto ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Foldable</span> f)
        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> t c
zipInto f xs <span class="fu">=</span>
  snd <span class="fu">.</span> flip (mapAccumL runRecAccu) xs <span class="fu">.</span> <span class="dt">RecAccu</span> <span class="fu">.</span> foldr h i <span class="kw">where</span>
    i e <span class="fu">=</span> (<span class="dt">RecAccu</span> i, f e <span class="dt">Nothing</span>)
    h e2 a e1 <span class="fu">=</span> (<span class="dt">RecAccu</span> a, f e1 (<span class="dt">Just</span> e2))</code></pre></div>
]]></description>
    <pubDate>Sun, 17 Apr 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Haskell</title>
    <link>http://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on October  6, 2015
</div>
<div class="info">
    
        Part 1 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h2 id="basic-ops">Basic Ops</h2>
<p>A Trie is one of those data structures that I find myself writing very early on in almost every language I try to learn. It’s elegant and interesting, and easy enough to implement.</p>
<p>I usually write a version that is a set-like data structure, rather than a mapping type, for simplicity’s sake. It stores sequences, in a prefix-tree structure. It has a map (dictionary) where the keys are the first element of every sequence it stores, and the values are the Tries which store the rest of the sequence. It also has a boolean tag, representing whether or not the current Trie is a Trie on which a sequence ends. Here’s what the type looks like in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Trie</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (null)
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> (fold)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Trie</span> a <span class="fu">=</span> <span class="dt">Trie</span> {<span class="ot"> endHere ::</span> <span class="dt">Bool</span>
                   ,<span class="ot"> getTrie ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a)
                   } <span class="kw">deriving</span> (<span class="dt">Eq</span>)</code></pre></div>
<p>Now, inserting into the Trie is easy. You just <code class="sourceCode haskell">uncons</code> on a list, and insert the head into the map, with the value being the tail inserted into whatever existed at that key before:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">empty ::</span> <span class="dt">Trie</span> a
empty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty

<span class="ot">insertRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
insertRec [] (<span class="dt">Trie</span> _ m)     <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">True</span> m
insertRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> e m) <span class="fu">=</span> 
  <span class="dt">Trie</span> e (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> insertRec xs <span class="fu">.</span> fromMaybe empty) x m)</code></pre></div>
<p>Searching is simple, also. For the empty list, you just check if the Trie has its <code class="sourceCode haskell">endHere</code> tag set to <code class="sourceCode haskell"><span class="dt">True</span></code>, otherwise, you uncons, search the map, and query the Trie with the tail if it eas found, or just return <code class="sourceCode haskell"><span class="dt">False</span></code> if it was not:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">memberRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
memberRec [] (<span class="dt">Trie</span> e _)     <span class="fu">=</span> e
memberRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> _ m) <span class="fu">=</span> 
  fromMaybe <span class="dt">False</span> (memberRec xs <span class="fu">&lt;$&gt;</span> Map.lookup x m)</code></pre></div>
<p>Here’s my problem. <em>Both</em> of those functions have the same pattern:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f []     <span class="fu">=</span> <span class="fu">...</span>
f (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p>Any good Haskeller should be <em>begging</em> for a fold at this stage. But it proved a little trickier than I’d imagined. Take <code class="sourceCode haskell">member</code>, for instance. You want to fold over a list, with the base case being the tag on the Trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f base <span class="kw">where</span>
  base <span class="fu">=</span> <span class="fu">???</span>
  f e a <span class="fu">=</span> Map.lookup e <span class="fu">???</span></code></pre></div>
<p>Where do you get the base case from, though? You have to specify it from the beginning, but the variable you’re looking for is nested deeply into the Trie. How can you look into the Trie, without traversing the list, to find the tag, <em>at the beginning of the function?</em></p>
<p>That had been my issue for a while. Every time I cam back to writing a Trie, I would see the pattern, try and write <code class="sourceCode haskell">insert</code> and <code class="sourceCode haskell">member</code> with a fold, and remember again the trouble I had had with it in the past. Recently, though, I saw a different problem, that gave me an idea for a solution.</p>
<h2 id="the-highest-order">The Highest Order</h2>
<blockquote>
<p>Rewrite <code class="sourceCode haskell">dropWhile</code> using <code class="sourceCode haskell">foldr</code></p>
</blockquote>
<p>It’s a (semi) well-known puzzle, that’s maybe a little more difficult than it seems at first. Here, for instance, was my first attempt at it:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhileWrong ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhileWrong p <span class="fu">=</span> foldr f [] <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a
        <span class="fu">|</span> otherwise <span class="fu">=</span> e<span class="fu">:</span>a</code></pre></div>
<p>Yeah. That’s <code class="sourceCode haskell">filter</code>, not <code class="sourceCode haskell">dropWhile</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">dropWhileWrong (<span class="fu">&lt;</span><span class="dv">5</span>) [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">1</span>]
[<span class="dv">6</span>]</code></pre></div>
<p>Here was my final solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhileCount ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhileCount p l <span class="fu">=</span> drop (foldr f <span class="dv">0</span> l) l <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a <span class="fu">+</span> <span class="dv">1</span>
        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<p>After the problem I found <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">this</a> issue of The Monad Reader, which talks about the same problem. In my <code class="sourceCode haskell">drop</code> version, I had been counting the number of items to drop as I went, adding one for every element that passed the test. The corresponding version in the article had been building up <code class="sourceCode haskell">tail</code> functions, using <code class="sourceCode haskell"><span class="fu">.</span></code> to add them together:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhileTail ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhileTail p l <span class="fu">=</span> (foldr f id l) l <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a
        <span class="fu">|</span> otherwise <span class="fu">=</span> id</code></pre></div>
<p>A quick visit to <a href="http://pointfree.io">pointfree.io</a> can generate some monadic pointsfree magic:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhilePf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhilePf p <span class="fu">=</span> join (foldr f id) <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a
        <span class="fu">|</span> otherwise <span class="fu">=</span> id</code></pre></div>
<p>Now, the final version in the article did <em>not</em> use this technique, as it was very inefficient. It used some cleverness beyond the scope of this post. The second-from-last version I quite liked, though:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">dropWhileFp ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhileFp p l <span class="fu">=</span> foldr f l l <span class="kw">where</span>
  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail a
        <span class="fu">|</span> otherwise <span class="fu">=</span> l</code></pre></div>
<p>However, the idea of building up a function in a fold gave me an idea for adapting it to some of the Trie functions.</p>
<h2 id="folding-inwards">Folding Inwards</h2>
<p>Let’s start with <code class="sourceCode haskell">member</code>. It needs to fold over a list, and generate a function which acts on a Trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f base</code></pre></div>
<p>The <code class="sourceCode haskell">base</code> is the function being built up: the final part of the function chain. Each part of the function is generated based on each element of the list, and then chained with the base using <code class="sourceCode haskell"><span class="fu">.</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member <span class="fu">=</span> foldr f base <span class="kw">where</span>
  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </code></pre></div>
<p>The base here is what’s called when the list is empty. Here’s what it looked like in the explicit recursion version:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member [] (<span class="dt">Trie</span> e _) <span class="fu">=</span> e</code></pre></div>
<p>We could simplify this by using record syntax, and <code class="sourceCode haskell">getTrie</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member [] t <span class="fu">=</span> getTrie t</code></pre></div>
<p>And this has an obvious pointsfree version:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member [] <span class="fu">=</span> getTrie</code></pre></div>
<p>That fits for the base case. It’s just a function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">member <span class="fu">=</span> foldr f endHere <span class="kw">where</span>
  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </code></pre></div>
<p>Then, how to combine it. That’s easy enough, actually. It accesses the map, searches it for the key, and calls the accumulating function on it. If it’s not found in the map, just return <code class="sourceCode haskell"><span class="dt">False</span></code>. Here it is:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f endHere <span class="kw">where</span>
  f e a <span class="fu">=</span> fromMaybe <span class="dt">False</span> <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie</code></pre></div>
<p>One of the other standard functions for a Trie is returning the “completions” for a given sequence. It’s a very similar function to <code class="sourceCode haskell">member</code>, actually: instead of calling <code class="sourceCode haskell">endHere</code> on the final Trie found, though, just return the Trie itself. And the thing to return if any given element of the sequence isn’t found is just an empty Trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">complete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
complete <span class="fu">=</span> foldr f id <span class="kw">where</span>
  f e a <span class="fu">=</span> fromMaybe empty <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie </code></pre></div>
<p>In fact, you could abstract out the commonality here:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">follow ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> c <span class="ot">-&gt;</span> (<span class="dt">Trie</span> a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> c
follow ifMiss onEnd <span class="fu">=</span> foldr f onEnd <span class="kw">where</span>
  f e a <span class="fu">=</span> fromMaybe ifMiss <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie 
  
<span class="ot">memberAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
memberAbs <span class="fu">=</span> follow <span class="dt">False</span> endHere

<span class="ot">completeAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
completeAbs <span class="fu">=</span> follow empty id</code></pre></div>
<h2 id="folding-in-and-out">Folding in and out</h2>
<p><code class="sourceCode haskell">insert</code> is another deal entirely. In <code class="sourceCode haskell">member</code>, the fold was tunneling into a Trie, applying the accumulator function to successively deeper Tries, and returning a result based on the final Trie. <code class="sourceCode haskell">insert</code> needs to do the same tunneling - but the Trie returned needs to be the <em>outer</em> Trie.</p>
<p>It turns out it’s not that difficult. Instead of “building up a function” that is then applied to a Trie, here a function is “sent” into the inner Tries. The cool thing here is that the function being sent hasn’t been generated yet.</p>
<p>Here’s some more illustration of what I mean. Start off with the normal <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m)</code></pre></div>
<p>With the final function to be applied being one that just flips the <code class="sourceCode haskell">endHere</code> tag to <code class="sourceCode haskell"><span class="dt">True</span></code>. Then <code class="sourceCode haskell">f</code>: this is going to act <em>over</em> the map of the Trie that it’s called on. It’s useful to define a function just for that:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">overMap ::</span> <span class="dt">Ord</span> b 
        <span class="ot">=&gt;</span> (<span class="dt">Map.Map</span> a (<span class="dt">Trie</span> a)
        <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> b (<span class="dt">Trie</span> b))
        <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
        <span class="ot">-&gt;</span> <span class="dt">Trie</span> b
overMap f (<span class="dt">Trie</span> e m) <span class="fu">=</span> <span class="dt">Trie</span> e (f m)</code></pre></div>
<p>Then, it will look up the next element of the sequence in the Trie, and apply the accumulating function to it. (if it’s not found it will provide an empty Trie instead) Simple!</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty
  <span class="dt">Trie</span> v k <span class="ot">`mappend`</span> <span class="dt">Trie</span> t l <span class="fu">=</span>
    <span class="dt">Trie</span> (v <span class="fu">||</span> t) (Map.unionWith mappend k l)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m) <span class="kw">where</span>
  f e a <span class="fu">=</span> 
    overMap (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e)</code></pre></div>
<p>I think this is really cool: with just a <code class="sourceCode haskell">foldr</code>, you’re burrowing into a Trie, changing it, and burrowing back out again.</p>
<h2 id="removal">Removal</h2>
<p>This is always the tricky one with a Trie. You <em>can</em> just follow a given sequence down to its tag, and flip it from on to off. But that doesn’t remove the sequence itself from the Trie. So maybe you just delete the sequence - but that doesn’t work either. How do you know that there are no other sequences stored below the one you were examining?</p>
<p>What you need to do is to send a function into the Trie, and have it report back as to whether or not it stores other sequences below it. So this version of <code class="sourceCode haskell">foldr</code> is going to burrow into the Trie, like <code class="sourceCode haskell">member</code>; maintain the outer Trie, like <code class="sourceCode haskell">insert</code>; but <em>also</em> send messages back up to the outer functions. Cool!</p>
<p>The way to do the “message sending” is with <code class="sourceCode haskell"><span class="dt">Maybe</span></code>. If the function you send into the Trie to delete the end of the sequence returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, then it signifies that you can delete that member. Luckily, the <code class="sourceCode haskell">alter</code> function on <code class="sourceCode haskell"><span class="dt">Data.Map</span></code> works well with this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">alter ::</span> <span class="dt">Ord</span> k 
      <span class="ot">=&gt;</span> (<span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)
      <span class="ot">-&gt;</span> k
      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a
      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a</code></pre></div>
<p>Its first argument is a function which is given the result of looking up its <em>second</em> argument. If the function returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, that key-value pair in the map is deleted (if it was there). If it returns <code class="sourceCode haskell"><span class="dt">Just</span></code> something, though, that key-value pair is added. In the delete function, we can chain the accumulating function with <code class="sourceCode haskell"><span class="fu">=&lt;&lt;</span></code>. This will skip the rest of the accumulation if any part of the sequence isn’t found. The actual function we’re chaining on is <code class="sourceCode haskell">nilIfEmpty</code>, which checks if a given Trie is empty, and returns <code class="sourceCode haskell"><span class="dt">Just</span></code> the Trie if it’s not, or <code class="sourceCode haskell"><span class="dt">Nothing</span></code> otherwise.</p>
<p>Here’s the finished version:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a
delete <span class="fu">=</span> (fromMaybe empty <span class="fu">.</span>) <span class="fu">.</span> foldr f i <span class="kw">where</span>
  i (<span class="dt">Trie</span> _ m) <span class="fu">|</span> Map.null m  <span class="fu">=</span> <span class="dt">Nothing</span>
               <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Trie</span> <span class="dt">False</span> m)
  f e a <span class="fu">=</span> nilIfEmpty <span class="fu">.</span> overMap (Map.alter (a <span class="fu">=&lt;&lt;</span>) e) 
  
null<span class="ot"> ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
null (<span class="dt">Trie</span> e m) <span class="fu">=</span> (not e) <span class="fu">&amp;&amp;</span> (Map.null m)

<span class="ot">nilIfEmpty ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Trie</span> a)
nilIfEmpty t <span class="fu">|</span> null t    <span class="fu">=</span> <span class="dt">Nothing</span>
             <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> t</code></pre></div>
<h2 id="folding-the-foldable">Folding the Foldable</h2>
<p>So how about folding the Trie itself? Same trick: build up a function with a fold. This time, a fold over the map, not a list. And the function being built up is a cons operation. When you hit a <code class="sourceCode haskell"><span class="dt">True</span></code> tag, fire off an empty list to the built-up function, allowing it to evaluate:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldrTrie ::</span> ([a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> b
foldrTrie f i (<span class="dt">Trie</span> a m) <span class="fu">=</span> Map.foldrWithKey ff s m <span class="kw">where</span>
  s    <span class="fu">=</span> <span class="kw">if</span> a <span class="kw">then</span> f [] i <span class="kw">else</span> i
  ff k <span class="fu">=</span> flip (foldrTrie <span class="fu">$</span> f <span class="fu">.</span> (k <span class="fu">:</span>))</code></pre></div>
<p>Unfortunately, <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">it’s not easy</a> to make the Trie <em>conform</em> to <code class="sourceCode haskell"><span class="dt">Foldable</span></code>. It is possible, and it’s what I’m currently trying to figure out, but it’s non-trivial.</p>
]]></description>
    <pubDate>Tue, 06 Oct 2015 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Faking dependent types in Swift</title>
    <link>http://doisinkidney.com/posts/2015-09-06-dependent-types.html</link>
    <description><![CDATA[<div class="info">
    Posted on September  6, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p><a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types</a> are types “that depend on values”. Say you had a function <code class="sourceCode scala">f</code> that took an integer. If you can write that function whereby it returns a value of type <code class="sourceCode scala">A</code> when that integer is even, or a type <code class="sourceCode scala">B</code> if the integer is odd, then you’re working with dependent types. (I think. I’m not sure: if I’ve got it wrong <a href="https://twitter.com/oisdk">tweet me</a>.)</p>
<h2 id="dependent-pretendance">Dependent Pretendance</h2>
<p>As far as I can tell, this is not possible in Swift. All variables are statically typed, and those types must be found at compile-time. As long as you’re not messing around with casting:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct A {}
struct B {}

func <span class="fu">f</span>(i: Int) -&gt; AnyObject {
  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? <span class="fu">A</span>() as! AnyObject : <span class="fu">B</span>() as! AnyObject
}</code></pre></div>
<p>You won’t be able to manage it.</p>
<p>Now, sum types can give you something that <em>looks</em> like dependent types:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct A {}
struct B {}

enum SumType {
  <span class="kw">case</span> <span class="fu">Even</span>(A), <span class="fu">Odd</span>(B)
}

func <span class="fu">f</span>(i: Int) -&gt; SumType {
  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? .<span class="fu">Even</span>(<span class="fu">A</span>()) : .<span class="fu">Odd</span>(<span class="fu">B</span>())
}</code></pre></div>
<p>But that doesn’t fit the description: the thing returned is of type <code class="sourceCode scala">SumType</code>, <em>not</em> <code class="sourceCode scala">A</code> or <code class="sourceCode scala">B</code>.</p>
<p>That’s fine, though. As with all of these highfalutin mathematical concepts in programming, you can steal some of the cool and fun <em>patterns</em> from your Haskells and Lisps and Idrises and implement them in whatever language you want.</p>
<p>As it happens, implementing this stuff in Swift gets you even <em>further</em> away from the formal definition of dependent types. Instead of allowing types to be decided at runtime, you end up forcing even <em>more</em> resolution and computation to happen at compile-time. Take “numbers-as-types”, for instance:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol Nat { <span class="fu">init</span>() }
struct Zero : Nat {}
protocol NonZero: Nat { typealias Pred: Nat }
struct Succ&lt;N : Nat&gt; : NonZero { typealias Pred = N }</code></pre></div>
<p>Once you encode some numbers by hand:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">typealias One   = Succ&lt;Zero&gt;
typealias Two   = Succ&lt;One&gt;
typealias Three = Succ&lt;Two&gt;
typealias Four  = Succ&lt;Three&gt;
typealias Five  = Succ&lt;Four&gt;
typealias Six   = Succ&lt;Five&gt;
typealias Seven = Succ&lt;Six&gt;
typealias Eight = Succ&lt;Seven&gt;
typealias Nine  = Succ&lt;Eight&gt;</code></pre></div>
<p>You get thinking about exactly <em>how much</em> computation you can achieve at compile time:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">Sum&lt;One, Two&gt;.<span class="fu">Result</span>    <span class="co">// Three</span>
Comp&lt;Five, Nine&gt;.<span class="fu">Result</span> <span class="co">// LT</span>
Comp&lt;Four, Four&gt;.<span class="fu">Result</span> <span class="co">// EQ</span></code></pre></div>
<h2 id="sum-types-divide-types-multiply-types">Sum types, divide types, multiply types</h2>
<p>What I wanted, ideally, was some basic “Algebraic data types”. (Today. Today was the day I made the worst pun.) I wanted to be able to add the type <code class="sourceCode scala">One</code> to the type <code class="sourceCode scala">Two</code> and get the type <code class="sourceCode scala">Three</code>. Once you can manage those, multiplication, division and all kinds of silliness are possible. I set myself some rules: all calculations must be performed at compile-time, and all calculations must work with arbitrary values.</p>
<p>I’ve not been able to manage, unfortunately. If someone could figure out how to do it, I would <a href="https://twitter.com/oisdk">love to hear it</a>. I’ve been stealing ideas from <a href="http://strictlypositive.org/faking.ps.gz">Faking It: Simulating Dependent Types in Haskell</a> mainly.</p>
<p>Here’s the kind of code that made me think it was possible:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let ar = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">reverse</span>()
let se = <span class="fu">AnySequence</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]).<span class="fu">reverse</span>()</code></pre></div>
<p>The types returned by those two methods are different. This is all to do with that protocol-oriented-programming business: the compiler will try to select the most specialised version of a method to use. So in the example above, since an array can just be indexed backwards, the compiler uses a method that returns a lazy <code class="sourceCode scala">ReverseRandomAccessCollection</code>. However, for the <code class="sourceCode scala">AnySequence</code>, the <code class="sourceCode scala">reverse</code> method has to create a whole new array.</p>
<p>With that in mind, we can make a protocol:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol BinaryOp {
  typealias A: Nat
  typealias B: Nat
}</code></pre></div>
<p>Then, we can extend it, like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct EQ {}
extension BinaryOp where A == B {
  typealias Result = EQ
}</code></pre></div>
<p>So far, so good! The compiler will add that method to all types that conform to the <code class="sourceCode scala">where</code> clause. So if there is a concrete type that conforms to <code>BinaryOp</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Comp&lt;E0: Nat, E1: Nat&gt; : BinaryOp {
  typealias A = E0
  typealias B = E1
}</code></pre></div>
<p>Only instances where <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are equal will get the type alias:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">Comp&lt;One, One&gt;.<span class="fu">Result</span>
Comp&lt;One, Two&gt;.<span class="fu">Result</span> <span class="co">// Error</span></code></pre></div>
<p>But that’s not ideal. We want something that returns <code class="sourceCode scala">NEQ</code> when the types are not the same. Easy enough, right?</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct NEQ {}
extension BinaryOp {
  typealias Result = NEQ
}</code></pre></div>
<p>But there’s an error: <code class="sourceCode scala">invalid redeclaration of &#39;Result&#39;</code>. The compiler won’t allow polymorphism with typealiases. It <em>does</em> allow polymorphism with properties, though:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension BinaryOp {
  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }
}
extension BinaryOp where A == B {
  <span class="kw">var</span> r: NEQ { <span class="kw">return</span> <span class="fu">NEQ</span>() }
}</code></pre></div>
<p>This is already a less elegant solution than the typealiases, since we’re going to have to initialise things. All of the type information is available at compile-time, though, so I’ve not broken any of my rules.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">Comp&lt;One, One&gt;().<span class="fu">r</span> <span class="co">// EQ</span>
Comp&lt;One, Two&gt;().<span class="fu">r</span> <span class="co">// NEQ</span></code></pre></div>
<p>How about something more complex? Instead of <code class="sourceCode scala">EQ</code> and <code class="sourceCode scala">NEQ</code>, maybe <code class="sourceCode scala">LT</code>, <code class="sourceCode scala">GT</code>, and <code>EQ</code>?</p>
<p>It’s hard to see how it would work. Well, here’s the base case:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension BinaryOp where A == B {
  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }
}</code></pre></div>
<p>Then, any non-zero is bigger than zero:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct LT {}
extension BinaryOp where A == Zero, B : NonZero {
  <span class="kw">var</span> r: LT { <span class="kw">return</span> <span class="fu">LT</span>() }
}
struct GT {}
extension BinaryOp where A : NonZero, B == Zero {
  <span class="kw">var</span> r: GT { <span class="kw">return</span> <span class="fu">GT</span>() }
}</code></pre></div>
<p>If both <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are nonzero, they should have a <code class="sourceCode scala">Pred</code> typealias, which we can use, recursively:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension BinaryOp where A : NonZero, B : NonZero {
  <span class="kw">var</span> r: ?? {
    <span class="kw">return</span> Comp&lt;A.<span class="fu">Pred</span>, B.<span class="fu">Pred</span>&gt;().<span class="fu">r</span>
  }
}</code></pre></div>
<p>This doesn’t work. I’m fairly sure this is a definitive dead end. Here’s the error: <code class="sourceCode scala">ambiguous reference to member &#39;r&#39;</code>. The problem is that that error encapsulates exactly what I’m trying to achieve: I <em>want</em> the reference to be ambiguous, so it <em>depends</em> on the types of <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code>. Most other routes I went down hit similar roadblocks:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol BinaryOp {
  typealias A: Nat
  typealias B: Nat
  typealias Result
  <span class="kw">var</span> r: Result { get }
}</code></pre></div>
<p>The idea here was that you could have various implementations of <code class="sourceCode scala">r</code>, so that the <code class="sourceCode scala">Result</code> typealias would be inferred. The problem is the compiler wants to figure out what <code class="sourceCode scala">Result</code> is when you make a type that conforms to the protocol, so every type will get the default implementation.</p>
<p>Yet more versions I tried all hit the <code class="sourceCode scala">ambiguous</code> error, which makes me think this kind of thing is fundamentally impossible in Swift’s current form.</p>
<p>So I’ve got to break one of the rules: no more arbitrary numbers.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct AddOne&lt;N : Nat&gt; {
  typealias Result = Succ&lt;N&gt;
}
struct AddTwo&lt;N : Nat&gt; {
  typealias Result = Succ&lt;AddOne&lt;N&gt;.<span class="fu">Result</span>&gt;
}</code></pre></div>
<p>And so on. Or:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Binary where A == B {
  <span class="kw">var</span> sub: Zero { <span class="kw">return</span> <span class="fu">Zero</span>() }
  <span class="kw">var</span> com: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }
}
extension Binary where A == Succ&lt;B&gt; {
  <span class="kw">var</span> sub: One { <span class="kw">return</span> <span class="fu">One</span>() }
  <span class="kw">var</span> com: GT { <span class="kw">return</span> <span class="fu">GT</span>() }
}</code></pre></div>
<p>Which can give you subtraction.</p>
<h2 id="lets-pretend-to-be-useful">Let’s Pretend to be Useful</h2>
<p>All of that stuff is interesting, but very <em>very</em> far from being useful.</p>
<p>The <a href="https://bigonotetaking.wordpress.com/2015/09/04/in-which-i-misunderstand-dependent-types/">length-indexed list from the other day</a> probably is useful, though. As well as being kind of cool and safe, there are some (minor) optimisations it can do.</p>
<p>The other dependent type staple is the heterogenous list.</p>
<p>Now, this isn’t just any heterogenous list: we’re not writing Python here. This is a <em>statically typed</em> heterogenous list. Swift has a construct very similar to this already: a tuple!</p>
<p>But tuples aren’t very extensible:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Tuple where First : Comparable {...
extension Tuple where Count == Two {...</code></pre></div>
<p>And you can’t work with them in terms that most lists can:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">(<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>, <span class="fl">2.0</span>) + (<span class="st">&quot;b&quot;</span>, -<span class="dv">3</span>)</code></pre></div>
<p>So that’s where another tuple type can come in. A la <a href="https://twitter.com/rob_rix/status/633262294336729088">Rob Rix</a>, we could make a right-recursive tuple, terminated by <code class="sourceCode scala">()</code>. There’ll be one overarching protocol:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol _AnyTuple : CustomStringConvertible {
  <span class="kw">var</span> tDesc: String { get }
  <span class="kw">var</span> count: Int { get }
  typealias Arity : Nat
}</code></pre></div>
<p>And the empty tuple:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct EmptyTuple {}

extension EmptyTuple : _AnyTuple {
  <span class="kw">var</span> description: String { <span class="kw">return</span> <span class="st">&quot;()&quot;</span> }
  <span class="kw">var</span> tDesc: String { <span class="kw">return</span>  <span class="st">&quot;)&quot;</span> }
  <span class="kw">var</span> count: Int { <span class="kw">return</span> <span class="dv">0</span> }
  typealias Arity = Zero
}</code></pre></div>
<p>The descriptions are just there to give us a pretty printout. Here’s the tuple struct:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct NonEmptyTuple&lt;Element, Tail : _AnyTuple&gt; { <span class="kw">var</span> (head, tail): (Element, Tail) }

extension NonEmptyTuple : _AnyTuple {
  <span class="kw">var</span> count: Int { <span class="kw">return</span> tail.<span class="fu">count</span> + <span class="dv">1</span> }
  <span class="kw">var</span> description: String {
    <span class="kw">return</span> <span class="st">&quot;(&quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span>
  }
  <span class="kw">var</span> tDesc: String {
    <span class="kw">return</span> <span class="st">&quot;, &quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span>
  }
  typealias Arity = Succ&lt;Tail.<span class="fu">Arity</span>&gt;
}</code></pre></div>
<p>Now, to build a tuple. Since it’s right-recursive, it might look like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="dv">1</span> , <span class="st">&quot;a&quot;</span> , <span class="fl">4.0</span> , ()</code></pre></div>
<p>But there are two problems with that: first, the comma is not overloadable. That’s probably a good thing. Second, it doesn’t really look like a tuple.</p>
<p><a href="https://twitter.com/jckarter/status/639953308401057793">Joe Groff</a> solved the first problem (albeit by committing a mortal sin). Just use a unicode comma! The only one I could find that works has the delightful name of Hypodiastole.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">infix operator ⸒ { associativity right precedence <span class="dv">90</span> }</code></pre></div>
<p>Trying to find it in the character viewer each time was a pain, though. So I went with the boring vertical bar.</p>
<p>The second problem can be solved with some sneaky overloading. Here’s what these functions look like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">infix operator | { associativity right precedence <span class="dv">90</span> }

func |&lt;E, T:_AnyTuple&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, T&gt; {
  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: rhs)
}

func |&lt;E, T&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, NonEmptyTuple&lt;T, EmptyTuple&gt;&gt; {
  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: <span class="fu">NonEmptyTuple</span>(head: rhs, tail: <span class="fu">EmptyTuple</span>()))
}</code></pre></div>
<p>We can now, finally, build a Tuple:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">(<span class="dv">1</span> | <span class="fl">2.0</span> | <span class="st">&quot;a&quot;</span> ) <span class="co">// (1, 2.0, &quot;a&quot;)</span></code></pre></div>
<p>One little wrinkle with protocols, though. If you try this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension NonEmptyTuple where Arity == Two {...</code></pre></div>
<p>There’s an error: <code class="sourceCode scala">neither <span class="kw">type</span> in same-<span class="kw">type</span> refers to a generic parameter or associated <span class="kw">type</span></code>. Generally speaking, <code class="sourceCode scala">==</code> requirements in struct extensions don’t work. However, they do work on protocols. So a wrapper protocol is needed:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol Tuple : _AnyTuple {
  typealias Head
  typealias Tail : _AnyTuple
  typealias Arity : NonZero
  <span class="kw">var</span> head : Head { get }
  <span class="kw">var</span> tail : Tail { get }
}

extension NonEmptyTuple : Tuple {}</code></pre></div>
<p>Alright. Time to work with it.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Tuple where
  Head : IntegerArithmeticType,
  Tail : Tuple,
  Tail.<span class="fu">Head</span> : IntegerArithmeticType,
  Arity == Two {
  func <span class="fu">matSum</span>(<span class="kw">with</span>: Self) -&gt; NonEmptyTuple&lt;Head, NonEmptyTuple&lt;Tail.<span class="fu">Head</span>, EmptyTuple&gt;&gt; {
    let a = head + <span class="kw">with</span>.<span class="fu">head</span>
    let b = tail.<span class="fu">head</span> + <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span>
    <span class="kw">return</span> (a | b)
  }
}

(<span class="dv">1</span> | <span class="dv">4</span>).<span class="fu">matSum</span>(<span class="dv">3</span> | <span class="dv">2</span>) <span class="co">// (4, 6)</span></code></pre></div>
<p>The basic advantage of this heterogenous list in Swift is its extensibility: you can treat tuples of length 2 as a type, or tuples where the third element is comparable as a type, and so on.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Tuple where Tail : Tuple, Tail.<span class="fu">Head</span> : Comparable {
  func isSecondLessThan
    &lt;T : Tuple where T.<span class="fu">Tail</span> : Tuple, T.<span class="fu">Tail</span>.<span class="fu">Head</span> == Tail.<span class="fu">Head</span>&gt;
    (<span class="kw">with</span>: T) -&gt; Bool {
    <span class="kw">return</span> tail.<span class="fu">head</span> &lt; <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span>
  }
}

let a = (<span class="dv">1</span> | <span class="fl">3.0</span> | <span class="st">&quot;a&quot;</span> | <span class="dv">43</span>)
let b = (<span class="st">&quot;c&quot;</span> | <span class="fl">4.0</span> | <span class="dv">1</span>)

a.<span class="fu">isSecondLessThan</span>(b)</code></pre></div>
<p>Most of this stuff is madness. The custom infix unicode operator should have tipped you off to that: but it’s not to say that <em>nothing</em> here is useful. Compile-time warnings are great. I think the fixed-length array works. But this tuple stuff is too hacky: it only becomes useful if there are some low-level changes to the language.</p>
<p>What’s really useful, though, is <em>thinking</em> about types with dependency in mind. Getting familiar with what is and isn’t possible to write between the <code class="sourceCode scala">where</code> and the <code class="sourceCode scala">{</code> in an extension gives you a good idea of how powerful protocols and their specialisations are.</p>
<p>For some extra reading, check out <a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell">DependentHaskell</a>, <a href="https://wiki.haskell.org/Heterogenous_collections">Heterogenous Collections in Haskell</a>, and <a href="http://programmers.stackexchange.com/questions/132835/is-there-a-specific-purpose-for-heterogeneous-lists">Strongly Typed Heterogenous Collections</a>. I’m muddling my way through seeing what’s possible with length-indexed lists, heterogenous lists, and numeral types <a href="https://github.com/oisdk/PretendDependSwift">over here</a>, if you’re interested.</p>
]]></description>
    <pubDate>Sun, 06 Sep 2015 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2015-09-06-dependent-types.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Using Protocols to Build a (very) Generic Deque</title>
    <link>http://doisinkidney.com/posts/2015-08-24-generic-deque.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 24, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>(Download the playground to use the code and see the outputs)</p>
<p>This post is an update on a <a href="https://bigonotetaking.wordpress.com/2015/08/09/yet-another-root-of-all-evil/">previous implementation of a Deque</a>. A full implementation of this Deque is available <a href="https://github.com/oisdk/SwiftDataStructures/blob/master/SwiftDataStructures/Deque.swift">here</a>.</p>
<p>A Deque is a data structure comprised of two stacks, facing opposite directions. In this way, operations at either end of the Deque have the same complexity as operations on one end of the underlying stack. This implementation uses two arrays, with the front reversed: appending, prepending, and removal of the first and last elements are all (amortized) O(1).</p>
<p>The standard library has three <code class="sourceCode scala">Array</code> structs: <code class="sourceCode scala">Array</code>, <code class="sourceCode scala">ArraySlice</code>, and <code class="sourceCode scala">ContiguousArray</code>. They all have the same interface, with different underlying implementations. An <code class="sourceCode scala">Array</code> is a standard vector-like structure, which allows O(1) amortized appending, fast iteration, etc. A <code class="sourceCode scala">ContiguousArray</code> has stricter rules about contiguity, but it’s not bridged to Objective-C.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let array  = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]
let cArray: ContiguousArray = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</code></pre></div>
<p>An <code class="sourceCode scala">ArraySlice</code> is a reference into an <code class="sourceCode scala">Array</code> or <code class="sourceCode scala">ContiguousArray</code>, for more efficient slicing. All the information an <code class="sourceCode scala">ArraySlice</code> contains is the beginning and end points of the slice (as well as any changes made to the slice separate from the array)</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let slice = array[<span class="dv">0</span>..&lt;<span class="dv">6</span>]</code></pre></div>
<p>To replicate these semantics in a Deque requires three separate structs: one with an <code class="sourceCode scala">Array</code> as the stack, another with an <code class="sourceCode scala">ArraySlice</code> as the stack, and a third with a <code class="sourceCode scala">ContiguousArray</code>. The standard library seems to duplicate the structs, along with their methods and properties.</p>
<p>It would be much nicer to just define a protocol that represented the <em>difference</em> between the deque types: then you could just write the methods and properties once, on top of it. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">protocol DequeType {
  typealias Container : RangeReplaceableCollectionType, MutableSliceable
  <span class="kw">var</span> front: Container { get set }
  <span class="kw">var</span> back : Container { get set }
  <span class="fu">init</span>()
}</code></pre></div>
<p>There’s one problem with this: both stacks need to be made public. It would be much nicer to hide the stacks (especially since an invariant needs to be checked and maintained on every mutation). If anyone has an idea of how to accomplish that, <a href="https://twitter.com/oisdk">tweet me</a>.</p>
<p>The first method to implement is a subscript. Indexing is difficult, because the front stack will be reversed, so the index used to get in to the Deque will need to be translated into an equivalent index in the array.</p>
<p>Any (valid) index will point into either the front or back queue, and the transformations applied to it in each case is different. If it’s in the front, the end result will look like <code class="sourceCode scala">front[front.<span class="fu">endIndex</span> - <span class="dv">1</span> - i]</code>, whereas if it’s in the back, it should be <code class="sourceCode scala">back[i - front.<span class="fu">endIndex</span>]</code>. There’s nothing specified about the Containers except that they’re <code class="sourceCode scala">RangeReplaceableCollectionType</code> and <code class="sourceCode scala">MutableSliceable</code>, so the index types will have to be as generic as possible. (you could specify <code class="sourceCode scala">where Index == Int</code>, but that’s more specific than needed, and not very extensible.)</p>
<p>Both of those transformations are subtractions, an operation that’s possible on <code>RandomAccessIndexType</code>s with the <code class="sourceCode scala">advancedBy</code> method. <code class="sourceCode scala">advancedBy</code> takes the associated <code class="sourceCode scala">Distance</code> type of the <code class="sourceCode scala">RandomAccessIndexType</code>. That’s enough information to figure out that the Deque’s index type must be the same as the Distance of the Index of the Container.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension DequeType {
  typealias Index = Container.<span class="fu">Index</span>.<span class="fu">Distance</span>
}</code></pre></div>
<p>The method that will translate an index into the relevant index in the stacks will return an enum:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public enum IndexLocation&lt;I&gt; {
  <span class="kw">case</span> <span class="fu">Front</span>(I), <span class="fu">Back</span>(I)
}</code></pre></div>
<p>Then, the translate method itself:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension DequeType where
  Container.<span class="fu">Index</span> : RandomAccessIndexType,
  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {
  
  <span class="kw">private</span> func <span class="fu">translate</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>)
    -&gt; IndexLocation&lt;Container.<span class="fu">Index</span>&gt; {
    <span class="kw">return</span> i &lt; front.<span class="fu">count</span> ?
      .<span class="fu">Front</span>(front.<span class="fu">endIndex</span>.<span class="fu">predecessor</span>().<span class="fu">advancedBy</span>(-i)) :
      .<span class="fu">Back</span>(back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i - front.<span class="fu">count</span>))
  }
}</code></pre></div>
<p>This performs two steps: 1. Check which stack it’s in. 2. Subtract in the appropriate order</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let d: Deque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>] <span class="co">// [1, 2, 3 | 4, 5, 6]</span>

d.<span class="fu">translate</span>(<span class="dv">0</span>) <span class="co">// Front: 2</span>
d.<span class="fu">translate</span>(<span class="dv">4</span>) <span class="co">// Back: 1</span></code></pre></div>
<p>This means that the logic for converting distance to index is separated from the logic for actual indexing. Great! Here’s the indexing:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension DequeType where
  Container.<span class="fu">Index</span> : RandomAccessIndexType,
  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {
  <span class="kw">var</span> startIndex: Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> <span class="dv">0</span> }
  <span class="kw">var</span> endIndex  : Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> front.<span class="fu">count</span> + back.<span class="fu">count</span> }
  <span class="fu">subscript</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>) -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span> {
    get {
      switch <span class="fu">translate</span>(i) {
      <span class="kw">case</span> let .<span class="fu">Front</span>(i): <span class="kw">return</span> front[i]
      <span class="kw">case</span> let .<span class="fu">Back</span>(i): <span class="kw">return</span> back[i]
      }
    } set {
      switch <span class="fu">translate</span>(i) {
      <span class="kw">case</span> let .<span class="fu">Front</span>(i): front[i] = newValue
      <span class="kw">case</span> let .<span class="fu">Back</span>(i): back[i] = newValue
      }
    }
  }
}</code></pre></div>
<p>This makes things much easier to test and debug.</p>
<p>Here’s where the power of protocols becomes obvious. If you go back to the original definition of <code class="sourceCode scala">DequeType</code>, you can add <code class="sourceCode scala">Indexable</code>. It may seem like now only indexable things can conform, but what happens in practice is that when <code class="sourceCode scala">Indexable</code> looks for its requirements, <em>it can use the implementations in DequeType</em>. That means that we’ve just made anything that can conform to <code class="sourceCode scala">DequeType</code> indexable. That’s awesome.</p>
<p>Next job is ranged indices. This is a good bit more complicated than the individual indices, so it definitely will benefit from being separated into a translate method:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension DequeType where
  Container.<span class="fu">Index</span> : RandomAccessIndexType,
  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : BidirectionalIndexType {
  
  <span class="kw">private</span> func translate
    (i: Range&lt;Container.<span class="fu">Index</span>.<span class="fu">Distance</span>&gt;)
    -&gt; IndexRangeLocation&lt;Container.<span class="fu">Index</span>&gt; {
      <span class="kw">if</span> i.<span class="fu">endIndex</span> &lt;= front.<span class="fu">count</span> {
        let s = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">endIndex</span>)
        <span class="kw">if</span> s == front.<span class="fu">startIndex</span> &amp;&amp; i.<span class="fu">isEmpty</span> { <span class="kw">return</span> .<span class="fu">Between</span> }
        let e = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)
        <span class="kw">return</span> .<span class="fu">Front</span>(s..&lt;e)
      }
      <span class="kw">if</span> i.<span class="fu">startIndex</span> &gt;= front.<span class="fu">count</span> {
        let s = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">startIndex</span> - front.<span class="fu">count</span>)
        let e = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)
        <span class="kw">return</span> .<span class="fu">Back</span>(s..&lt;e)
      }
      let f = front.<span class="fu">startIndex</span>..&lt;front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)
      let b = back.<span class="fu">startIndex</span>..&lt;back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)
      <span class="kw">return</span> .<span class="fu">Over</span>(f, b)
  }
}

let otherDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>] <span class="co">// [0, 1, 2 | 3, 4, 5]</span>

otherDeque.<span class="fu">translate</span>(<span class="dv">0</span>...<span class="dv">2</span>) <span class="co">// Front: 0..&lt;3</span>
otherDeque.<span class="fu">translate</span>(<span class="dv">4</span>...<span class="dv">5</span>) <span class="co">// Back: 1..&lt;3</span>
otherDeque.<span class="fu">translate</span>(<span class="dv">2</span>...<span class="dv">5</span>) <span class="co">// Over: 0..&lt;1, 0..&lt;3</span>
otherDeque.<span class="fu">translate</span>(<span class="dv">3</span>..&lt;<span class="dv">3</span>) <span class="co">// Between</span></code></pre></div>
<p>The invariant that must be maintained in the deque is this: if either stack has more than one element, the other cannot be empty. If the invariant is violated, the longer stack is reversed, and put in place of the shorter.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public enum Balance {
  <span class="kw">case</span> FrontEmpty, BackEmpty, Balanced
}

extension DequeType {
  
  public <span class="kw">var</span> balance: Balance {
    <span class="fu">let</span> (f, b) = (front.<span class="fu">count</span>, back.<span class="fu">count</span>)
    <span class="kw">if</span> f == <span class="dv">0</span> {
      <span class="kw">if</span> b &gt; <span class="dv">1</span> {
        <span class="kw">return</span> .<span class="fu">FrontEmpty</span>
      }
    } <span class="kw">else</span> <span class="kw">if</span> b == <span class="dv">0</span> {
      <span class="kw">if</span> f &gt; <span class="dv">1</span> {
        <span class="kw">return</span> .<span class="fu">BackEmpty</span>
      }
    }
    <span class="kw">return</span> .<span class="fu">Balanced</span>
  }
  
  public <span class="kw">var</span> isBalanced: Bool {
    <span class="kw">return</span> balance == .<span class="fu">Balanced</span>
  }
}</code></pre></div>
<p>A deque is a good data structure for certain uses, especially those that require popping and appending from either end. <code class="sourceCode scala"><span class="fu">popFirst</span>()</code> and <code class="sourceCode scala"><span class="fu">popLast</span>()</code> aren’t included in the standard <code class="sourceCode scala">RangeReplaceableCollectionType</code>, though, so we’ll have to add our own.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension RangeReplaceableCollectionType where Index : BidirectionalIndexType {
  <span class="kw">private</span> mutating func <span class="fu">popLast</span>() -&gt; Generator.<span class="fu">Element</span>? {
    <span class="kw">return</span> isEmpty ? nil : <span class="fu">removeLast</span>()
  }
}

<span class="kw">var</span> mutableDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]
mutableDeque.<span class="fu">popLast</span>() <span class="co">// 5</span>
mutableDeque           <span class="co">// [0, 1, 2 | 3, 4]</span>

extension DequeType where Container.<span class="fu">Index</span> : BidirectionalIndexType {
  public mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {
    <span class="kw">return</span> back.<span class="fu">popLast</span>()
  }
}</code></pre></div>
<p>The method needs to include <code class="sourceCode scala"><span class="fu">check</span>()</code>, which we can do with <code>defer</code></p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {
  defer { <span class="fu">check</span>() }
  <span class="kw">return</span> back.<span class="fu">popLast</span>()
}

mutableDeque.<span class="fu">popLast</span>() <span class="co">// 4</span>
mutableDeque           <span class="co">// [0, 1, 2 | 3]</span>
mutableDeque.<span class="fu">popLast</span>() <span class="co">// 3</span>
mutableDeque           <span class="co">// [0 | 1, 2]</span></code></pre></div>
<p>You also can’t just pop from the back queue in <code class="sourceCode scala"><span class="fu">popLast</span>()</code>, because it may be the case that the front stack has one element left</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {
  defer { <span class="fu">check</span>() }
  <span class="kw">return</span> back.<span class="fu">popLast</span>() ?? front.<span class="fu">popLast</span>()
}

mutableDeque.<span class="fu">popLast</span>() <span class="co">// 2</span>
mutableDeque.<span class="fu">popLast</span>() <span class="co">// 1</span>
mutableDeque           <span class="co">// [0|]</span>
mutableDeque.<span class="fu">popLast</span>() <span class="co">// 0</span>
mutableDeque           <span class="co">// [|]</span>
mutableDeque.<span class="fu">popLast</span>() <span class="co">// nil</span></code></pre></div>
<p>The rest of the Deque was easy, with little to no repetition. Using protocols in this way was really surprisingly powerful: now, you can define a <code class="sourceCode scala">DequeType</code>, with full access to all of the collection methods, all the way up to <code class="sourceCode scala">RangeReplaceableCollectionType</code>, in five lines:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct Deque&lt;Element&gt; : DequeType {
  public <span class="kw">var</span> front, back: [Element]
  public typealias SubSequence = DequeSlice&lt;Element&gt;
  public <span class="fu">init</span>() { (front, back) = ([], []) }
}

public struct DequeSlice&lt;Element&gt; : DequeType {
  public <span class="kw">var</span> front, back: ArraySlice&lt;Element&gt;
  public typealias SubSequence = DequeSlice
  public <span class="fu">init</span>() { (front, back) = ([], []) }
}</code></pre></div>
<p>There’s no performance hit, there’s no safety problems. I only have one version of code to test, one version to change, one version to read. It’s completely extensible: you could use any kind of stack for the front and back. Even another Deque, if you were so inclined:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct DequeDeque&lt;Element&gt; : DequeType {
  <span class="kw">var</span> front, back: Deque&lt;Element&gt;
  typealias SubSequence = DequeDequeSlice&lt;Element&gt;
  <span class="fu">init</span>() { front = <span class="fu">Deque</span>(); back = <span class="fu">Deque</span>() }
}

struct DequeDequeSlice&lt;Element&gt; : DequeType {
  <span class="kw">var</span> front, back: DequeSlice&lt;Element&gt;
  typealias SubSequence = DequeDequeSlice
  <span class="fu">init</span>() { front = <span class="fu">DequeSlice</span>(); back = <span class="fu">DequeSlice</span>() }
}

let dd: DequeDeque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>]
dd.<span class="fu">front</span> <span class="co">// [4 | 3, 2, 1]</span>
dd.<span class="fu">back</span>  <span class="co">// [5 | 6, 7, 8]</span></code></pre></div>
<p>Woo protocols!</p>
]]></description>
    <pubDate>Mon, 24 Aug 2015 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2015-08-24-generic-deque.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Swift</title>
    <link>http://doisinkidney.com/posts/2015-08-11-swift-trie.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 11, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>If you google “cool data structures” you’ll get <a href="http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures">this</a> as your first result. It’s a stackoverflow question: “What are the lesser known but useful data structures?”. And the top answer is a Trie. I read up on them, and found out a lot of cool things about their use (as well as finding out that I’m now the kind of person who googles “cool data structures”). So I rocked on up to my playground, and got writing.</p>
<p>A Trie is a prefix tree. It’s another recursive data structure: each Trie contains other children Tries, identifiable by their prefixes.</p>
<p>It’s a bit of a hipster data structure, not very widely used, but it’s got some useful applications. It’s got set-like operations, with insertion and searching each at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the length of the sequence being searched for. A Set is the only way to go for hashable, unordered elements. But, if you’ve got <em>sequences</em> of hashable elements, a Trie might be for you. (one thing to note is that Sets are hashable themselves, so if the sequences you want to store are unordered, a Set of Sets is more applicable)</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1092px-Trie_example.svg.png" alt="A trie for keys" />
<p class="caption">A trie for keys</p>
</div>
<p>In Swift, we can do this by having every Trie contain a dictionary of prefixes and Tries. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct Trie&lt;Element : Hashable&gt; {
  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]
}</code></pre></div>
<p>We don’t run into the problem of structs not being allowed to be recursive here, because we don’t directly store a Trie within a Trie - we store a <em>dictionary</em>, and therefore a reference to the child Tries. In this dictionary, the keys correspond to the prefixes. So how do we fill it up? Like lists, we can use the decomposition properties of generators:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {
    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
      children = [head:<span class="fu">Trie</span>(gen:gen)]
    } <span class="kw">else</span> {
      children = [:]
    }
  }
  public init
    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;
    (_ seq: S) {
      self.<span class="fu">init</span>(gen: seq.<span class="fu">generate</span>())
  }
}</code></pre></div>
<p>That’s not really enough. That can store one sequence, but we need an <code class="sourceCode scala">insert</code> function. Here ya go:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> mutating func insert
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) {
      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()
      }
  }
  public mutating func insert
    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;
    (seq: S) {
      <span class="fu">insert</span>(seq.<span class="fu">generate</span>())
  }
}</code></pre></div>
<p>There’s a line in there that some may find offensive:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</code></pre></div>
<p>And, to be honest, I’m not a huge fan of it myself. It’s making use of the fact that you can call mutating methods on optionals with chaining. When you do it in this example, the optional is returned by the dictionary lookup: we then want to mutate that value, if it’s there, with an insertion.</p>
<p>If it’s <em>not</em> there, though, we want to add it in, so we’ve got to have some way of understanding and dealing with that. We could try and extract the child Trie, like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
  <span class="kw">if</span> <span class="kw">var</span> child = children[head] {
    child.<span class="fu">insert</span>(gen)
  } <span class="kw">else</span> {
    children[head] = <span class="fu">Trie</span>(gen: gen)
  }
}</code></pre></div>
<p>But the child there is just a copy of the actual child in the Trie we want to mutate. We could then set it back to the dictionary entry - but at this stage it feels like a lot of extra, inefficient work.</p>
<p>So, you can make use of the fact the functions which don’t return anything actually <em>do</em> return something: a special value called <code class="sourceCode scala">Void</code>, or <code class="sourceCode scala">()</code>. Except that, in this case, it’s <code class="sourceCode scala">()?</code> (or <code class="sourceCode scala">Optional&amp;lt;Void&amp;gt;</code>). We’re not interested in the void itself, obviously, just whether or not it’s <code class="sourceCode scala">nil</code>. So, one way you could use it would be like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> let _ = children[head]?.<span class="fu">insert</span>(gen) { <span class="kw">return</span> }
children[head] = <span class="fu">Trie</span>(gen: gen)</code></pre></div>
<p>Or, to use <code class="sourceCode scala">guard</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">guard let _ = children[head]?.<span class="fu">insert</span>(gen) <span class="kw">else</span> { children[head] = <span class="fu">Trie</span>(gen: gen) }</code></pre></div>
<p>But I think the nil coalescing operator is a little clearer, without the distraction of <code class="sourceCode scala">let</code> or <code class="sourceCode scala">_</code>.</p>
<p>This data structure, as you can see, has a very different feel to the list. For a start, it’s much more mutable, with in-place mutating methods being a little easier than methods that return a new Trie. Also, laziness is pretty much out of the question: almost every imaginable useful method would involve evaluation of the entire Trie. (if anyone <em>does</em> have a useful way of thinking about Tries lazily, I’d love to hear it)</p>
<p>The contains function, the most important of them all, is here:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> func contains
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) -&gt; Bool {
      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? <span class="kw">true</span>
  }
  public func contains
    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;
    (seq: S) -&gt; Bool {
      <span class="kw">return</span> <span class="fu">contains</span>(seq.<span class="fu">generate</span>())
  }
}</code></pre></div>
<p>So this uses more generators. If the generator is empty (<code class="sourceCode scala">gen.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>), then the Trie contains that sequence, as we have not yet found a dictionary without that element. Within the <code class="sourceCode scala"><span class="fu">map</span>()</code> we search for the next element from the generator. If <em>that</em> returns <code class="sourceCode scala">nil</code>, then the Trie doesn’t contain that sequence. Finally, if none of that works, return whether or not the child Trie contains the rest of the generator. Let’s try it out:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">var</span> jo = <span class="fu">Trie</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])
jo.<span class="fu">insert</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])
jo.<span class="fu">insert</span>([<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>])

jo.<span class="fu">contains</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]) <span class="co">// true</span>
jo.<span class="fu">contains</span>([<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]) <span class="co">// false</span></code></pre></div>
<p>There’s a catch. The <code class="sourceCode scala">contains</code> method doesn’t work as we’d like it to:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">jo.<span class="fu">contains</span>([<span class="dv">1</span>, <span class="dv">2</span>]) <span class="co">// true</span></code></pre></div>
<p>Because we return <code class="sourceCode scala"><span class="kw">true</span></code> <em>whenever</em> the generator runs out, our Trie “contains” every prefix of the sequences that have been inserted. This is not what we want. One way to solve this may be to return <code class="sourceCode scala"><span class="kw">true</span></code> only if the last Trie found has no children. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> func contains
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) -&gt; Bool {
      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? children.<span class="fu">isEmpty</span>
  }
}</code></pre></div>
<p>But this doesn’t really work either. what if we did <code class="sourceCode scala">jo.<span class="fu">insert</span>([<span class="dv">1</span>, <span class="dv">2</span>])</code>? Now, if we check if the Trie contains <code class="sourceCode scala">[<span class="dv">1</span>, <span class="dv">2</span>]</code>, we’ll get back <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>It’s time for flags. We need to add an extra variable to our Trie: a Boolean, which describes whether or not that Trie represents the end of a sequence.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct Trie&lt;Element : Hashable&gt; {
  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]
  <span class="kw">private</span> <span class="kw">var</span> endHere : Bool
}</code></pre></div>
<p>We’ll also need to change our <code class="sourceCode scala">insert</code> and <code class="sourceCode scala">init</code> functions, so that when the generator returns <code class="sourceCode scala">nil</code>, <code class="sourceCode scala">endHere</code> gets initialised to <code class="sourceCode scala"><span class="kw">true</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {
    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
      (children, endHere) = ([head:<span class="fu">Trie</span>(gen:gen)], <span class="kw">false</span>)
    } <span class="kw">else</span> {
      (children, endHere) = ([:], <span class="kw">true</span>)
    }
  }
}

extension Trie {
  <span class="kw">private</span> mutating func insert
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) {
      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {
        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()
      } <span class="kw">else</span> {
        endHere = <span class="kw">true</span>
      }
  }
}</code></pre></div>
<p>And the contains function now returns <code class="sourceCode scala">endHere</code>, instead of true:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public extension Trie {
  <span class="kw">private</span> func contains
    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;
    (<span class="kw">var</span> gen: G) -&gt; Bool {
      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? endHere
  }
}</code></pre></div>
<p>While we’re improving the <code class="sourceCode scala">contains</code> function, we could use <code class="sourceCode scala">guard</code> to make it much more readable:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public extension Trie {
  <span class="kw">private</span> func contains&lt;
    G : GeneratorType where G.<span class="fu">Element</span> == Element
    &gt;(<span class="kw">var</span> gen: G) -&gt; Bool {
      guard let head = gen.<span class="fu">next</span>() <span class="kw">else</span> { <span class="kw">return</span> endHere }
      <span class="kw">return</span> children[head]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>
  }
}</code></pre></div>
<p><a href="https://twitter.com/chriseidhof/status/629215881843884032">Chris Eidhof gave me this idea.</a> (Apparently there’s a Trie implementation in <a href="http://www.objc.io/books/fpinswift/">Functional Programming in Swift</a>, his book. I’ve not read it, but it’s on my list. If <a href="http://www.objc.io/books/advanced-swift/">Advanced Swift</a>is anything to go by, it should be fantastic.)</p>
<p>The objective of this Trie is to replicate all of the Set methods: Union, Intersect, etc. Most of those are manageable to build from just <code class="sourceCode scala">insert</code>, <code class="sourceCode scala">init</code>, and <code class="sourceCode scala">contains</code>, but there’s one other function that comes in handy: <code class="sourceCode scala">remove</code>.</p>
<p>Remove is deceptively difficult. You could just walk to the end of your given sequence to remove, and switch <code class="sourceCode scala">endHere</code> from <code class="sourceCode scala"><span class="kw">true</span></code> to <code class="sourceCode scala"><span class="kw">false</span></code>, but that’s kind of cheating. I mean, you’ll be storing the same amount of information that way after a removal. No, what you need is something that deletes branches of a tree that aren’t being used any more.</p>
<p>Again, this is a little complicated. You can’t just find the head of the sequence you want to remove, and then delete all children: you may be deleting other entries along with that. You <em>also</em> can’t just delete when a given Trie only contains one child: that child may branch off subsequently, or it may contain prefixes for the sequence you want to remove.</p>
<p>Crucially, all of the information telling you whether or not you can delete a given entry in a given Trie will come from the <em>children</em> of that Trie. What I decided to go with was this: I’ll have some mutating method that does the work recursively. However, this method also <em>returns</em> a value, representing some important information for whatever called it. In this case, the <code class="sourceCode scala">remove</code> method would remove, as you’d imagine, but it will also return a Boolean, signifying whether the Trie it was called on can be removed. Since I used the normal structure of having a private method take a generator, and then a public wrapper method take a sequence, I could have the public method just discard the Boolean.</p>
<p>Let’s go through it. Here’s the signature:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">private</span> mutating func remove&lt;
  G : GeneratorType where G.<span class="fu">Element</span> == Element
  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</code></pre></div>
<p>No surprises there. Similar to the other methods. Then, get the head from the generator:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> let head = g.<span class="fu">next</span>() {</code></pre></div>
<p>Within that if block is the meat of the logic, so I might skip to what happens if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code> for the start:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">private</span> mutating func remove&lt;
  G : GeneratorType where G.<span class="fu">Element</span> == Element
  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {
    <span class="kw">if</span> let head = g.<span class="fu">next</span>() {...}
    endHere = <span class="kw">false</span>
    <span class="kw">return</span> children.<span class="fu">isEmpty</span>
}</code></pre></div>
<p>So the sequence being removed has ended. That means that whatever Trie you’re on should have its <code class="sourceCode scala">endHere</code> set to <code class="sourceCode scala"><span class="kw">false</span></code>. To the user of the Trie, that’s all that matters: from now on, if the contains method on that Trie is used with that sequence, it will return false.</p>
<p>However, to find out if you can delete the data itself, it returns <code class="sourceCode scala">children.<span class="fu">isEmpty</span></code>. If it has no children, it does not hold any other sequences or information, so it can be deleted.</p>
<p>Now for inside the if block:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }
children.<span class="fu">removeValueForKey</span>(head)
<span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></code></pre></div>
<p>So it calls <code class="sourceCode scala">remove</code> on the child Trie corresponding to <code class="sourceCode scala">head</code>. That guard statement will fail for two distinct reasons: if <code class="sourceCode scala">children</code> doesn’t contain <code class="sourceCode scala">head</code>, then the sequence being removed wasn’t in the Trie in the first place. The method will then return false, so that no removal or mutation is done.</p>
<p>If it <em>does</em> contain <code class="sourceCode scala">head</code>, but the Bool returned from the remove method is <code class="sourceCode scala"><span class="kw">false</span></code>, that means that its <em>child</em> is not removable, so it is also not removable, so it should return <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>Otherwise, it will remove that member (<code class="sourceCode scala">children.<span class="fu">removeValueForKey</span>(head)</code>). Then, the Trie can decide whether or not it itself is removable: <code class="sourceCode scala"><span class="kw">return</span> !endHere &amp;amp;&amp;amp; children.<span class="fu">isEmpty</span></code>. If the <code class="sourceCode scala">endHere</code> is set to true, then it is the end of some sequence: it is not removable. Otherwise, it’s removable if it has no children. Here’s the whole thing, with its public version:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  <span class="kw">private</span> mutating func remove&lt;
    G : GeneratorType where G.<span class="fu">Element</span> == Element
    &gt;(<span class="kw">var</span> g: G) -&gt; Bool { <span class="co">// Return value signifies whether or not it can be removed</span>
      <span class="kw">if</span> let head = g.<span class="fu">next</span>() {
        guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }
        children.<span class="fu">removeValueForKey</span>(head)
        <span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span>
      }
      endHere = <span class="kw">false</span>
      <span class="kw">return</span> children.<span class="fu">isEmpty</span>
  }
  public mutating func remove&lt;
    S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element
    &gt;(seq: S) {
      <span class="fu">remove</span>(seq.<span class="fu">generate</span>())
  }
}</code></pre></div>
<p>That was a little heavy. And kind of ugly. Let’s lighten things up for a second, with one of the loveliest <code class="sourceCode scala">count</code> properties I’ve seen:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  public <span class="kw">var</span> count: Int {
    <span class="kw">return</span> children.<span class="fu">values</span>.<span class="fu">reduce</span>(endHere ? <span class="dv">1</span> : <span class="dv">0</span>) { $<span class="dv">0</span> + $<span class="fl">1.</span>count }
  }
}</code></pre></div>
<p>All it’s really doing is counting the instances of a <code class="sourceCode scala"><span class="kw">true</span></code> <code class="sourceCode scala">endHere</code>. If the current Trie is an end, then it knows that it adds one to the count (<code class="sourceCode scala">endHere ? <span class="dv">1</span> : <span class="dv">0</span></code>), and it adds that to the sum of the counts of its children.</p>
<p>Now then. <code class="sourceCode scala">SequenceType</code>. <a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/">Getting tree-like structures to conform to <code class="sourceCode scala">SequenceType</code> is a bit of a pain</a>, mainly because of their recursiveness. Getting a linear representation is easy enough:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">extension Trie {
  public <span class="kw">var</span> contents: [[Element]] {
    <span class="kw">return</span> children.<span class="fu">flatMap</span> {
      (head: Element, child: Trie&lt;Element&gt;) -&gt; [[Element]] in
      child.<span class="fu">contents</span>.<span class="fu">map</span> { [head] + $<span class="dv">0</span> } + (child.<span class="fu">endHere</span> ? [[head]] : [])
    }
  }
}</code></pre></div>
<p>And then you could just return the generate method from that for your Trie’s generate method.</p>
<p>The problem is that it’s not very proper: you’re translating your data structure into another data structure just to iterate through it. What you really want is something that generates each element on demand.</p>
<p>But it gets ugly quick. You’ve got to do a lot of stuff by hand which it isn’t nice to do by hand, and you’ve got to employ some dirty tricks (like using closures as a kind of homemade <code class="sourceCode scala">indirect</code>). At any rate, here it is:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">public struct TrieGenerator&lt;Element : Hashable&gt; : GeneratorType {
  <span class="kw">private</span> <span class="kw">var</span> children: DictionaryGenerator&lt;Element, Trie&lt;Element&gt;&gt;
  <span class="kw">private</span> <span class="kw">var</span> curHead : Element?
  <span class="kw">private</span> <span class="kw">var</span> curEnd  : Bool = <span class="kw">false</span>
  <span class="kw">private</span> <span class="kw">var</span> innerGen: (() -&gt; [Element]?)?
  <span class="kw">private</span> mutating func <span class="fu">update</span>() {
    guard <span class="fu">let</span> (head, child) = children.<span class="fu">next</span>() <span class="kw">else</span> { innerGen = nil; <span class="kw">return</span> }
    curHead = head
    <span class="kw">var</span> g = child.<span class="fu">generate</span>()
    innerGen = {g.<span class="fu">next</span>()}
    curEnd = child.<span class="fu">endHere</span>
  }
  public mutating func <span class="fu">next</span>() -&gt; [Element]? {
    <span class="kw">for</span> ; innerGen != nil; <span class="fu">update</span>() {
      <span class="kw">if</span> let next = innerGen!() {
        <span class="kw">return</span> [curHead!] + next
      } <span class="kw">else</span> <span class="kw">if</span> curEnd {
        curEnd = <span class="kw">false</span>
        <span class="kw">return</span> [curHead!]
      }
    }
    <span class="kw">return</span> nil
  }
  <span class="kw">private</span> <span class="fu">init</span>(_ from: Trie&lt;Element&gt;) {
    children = from.<span class="fu">children</span>.<span class="fu">generate</span>()
    <span class="fu">update</span>()
  }
}</code></pre></div>
<p>It’s got a similar logic to the lazy flatMap I did from a while ago.</p>
<p>The code is all available <a href="https://github.com/oisdk/SwiftTrie">here</a>, as a playground, or <a href="https://github.com/oisdk/SwiftSequence">here</a>, in SwiftSequence, where it’s accompanied by some tests.</p>
]]></description>
    <pubDate>Tue, 11 Aug 2015 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2015-08-11-swift-trie.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>

    </channel>
</rss>
