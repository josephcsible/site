<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Donnacha Oisin Kidney's Blog</title>
        <link>http://doisinkidney.com</link>
        <description><![CDATA[Mainly writing about programming]]></description>
        <atom:link href="http://doisinkidney.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 30 Sep 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Probability Trees</title>
    <link>http://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 30, 2016
</div>
<div class="info">
    
        Part 3 of a <a href="/series/probability.html">3-part series on probability</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span>
<span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span>

<span class="kw">module</span> <span class="dt">ProbTree</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Data.Ratio</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span></code></pre></div>
<p>Previously, I tried to figure out how to make the probability monad more “listy”. I read a little more about the topic <span class="citation">(especially Erwig and Kollmansberger 2006; and Kidd 2007)</span>.</p>
<p>I then thought about what a probability monad would look like if it was based on other data structures. I feel like the standard version really wants to be:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ProperProb</span> a <span class="fu">=</span> <span class="dt">ProperProb</span>
  {<span class="ot"> yes ::</span> <span class="dt">Map</span> a (<span class="dt">Product</span> <span class="dt">Rational</span>) }</code></pre></div>
<p>But of course a monad instance isn’t allowed.</p>
<p>Similar to a map, though, is a binary tree:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span>
                  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)</code></pre></div>
<p>And it feels better for probability - <em>flatter</em>, somehow. Transmuting it into a probability-thing:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certain</span> a
            <span class="fu">|</span> <span class="dt">Choice</span> (<span class="dt">Odds</span> a) <span class="dt">Rational</span> (<span class="dt">Odds</span> a)
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</code></pre></div>
<p>That looks good to me. A choice between two different branches feels more natural than a choice between a head and a tail.</p>
<p>The fold is similar to before, with an unfold for good measure:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b
foldOdds f b <span class="fu">=</span> r <span class="kw">where</span>
  r (<span class="dt">Certain</span> x) <span class="fu">=</span> b x
  r (<span class="dt">Choice</span> xs p ys) <span class="fu">=</span> f (r xs) p (r ys)
  
<span class="ot">unfoldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Either</span> a (b,<span class="dt">Rational</span>,b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
unfoldOdds f <span class="fu">=</span> r <span class="kw">where</span>
  r b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span>
    <span class="dt">Left</span> a <span class="ot">-&gt;</span> <span class="dt">Certain</span> a
    <span class="dt">Right</span> (x,p,y) <span class="ot">-&gt;</span> <span class="dt">Choice</span> (r x) p (r y)
  
<span class="ot">fi ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
fi <span class="dt">True</span>  t _ <span class="fu">=</span> t
fi <span class="dt">False</span> _ f <span class="fu">=</span> f</code></pre></div>
<p>I changed the pattern synonym a little:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">
<span class="ot">unRatio ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> (a,a)
unRatio <span class="fu">=</span> numerator   <span class="fu">&amp;&amp;&amp;</span> denominator 
      <span class="fu">&gt;&gt;&gt;</span> fromInteger <span class="fu">***</span> fromInteger

pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (unRatio <span class="ot">-&gt;</span> (n,d))</code></pre></div>
<p>Then, the <code class="sourceCode haskell">probOf</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOf e <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> fi (e <span class="fu">==</span> x) <span class="dv">1</span> <span class="dv">0</span>
  f x (n<span class="fu">:%</span>d) y <span class="fu">=</span> (x <span class="fu">*</span> n <span class="fu">+</span> y <span class="fu">*</span> d) <span class="fu">/</span> (n <span class="fu">+</span> d)</code></pre></div>
<p>This version doesn’t have the option for short-circuiting on the first value it finds.</p>
<p>For generating from lists, you can try to evenly divide the list among each branch.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">fromListOdds ::</span> (([b], <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromListOdds fr e <span class="fu">=</span> r <span class="kw">where</span>
  r [] <span class="fu">=</span> <span class="dt">Nothing</span>
  r xs <span class="fu">=</span> <span class="dt">Just</span> (unfoldOdds f (xs, length xs))
  f ([x],_) <span class="fu">=</span> <span class="dt">Left</span> (e x)
  f (xs ,n) <span class="fu">=</span> <span class="dt">Right</span> ((ys,l), fr (ys,l) <span class="fu">%</span> fr (zs,r), (zs,r)) <span class="kw">where</span>
    l <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span>
    r <span class="fu">=</span> n <span class="fu">-</span> l
    (ys,zs) <span class="fu">=</span> splitAt l xs

<span class="ot">equalOdds ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
equalOdds <span class="fu">=</span> fromListOdds (fromIntegral <span class="fu">.</span> snd) id

<span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromDistrib <span class="fu">=</span> fromListOdds (sum <span class="fu">.</span> map snd <span class="fu">.</span> fst) fst</code></pre></div>
<p>What’s really nice about this version is the fact that the old <code class="sourceCode haskell">append</code> is just the <code class="sourceCode haskell"><span class="dt">Choice</span></code> constructor, leaving the instances to be really nice:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
flatten <span class="fu">=</span> foldOdds <span class="dt">Choice</span> id

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Certain</span>
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)
  
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</code></pre></div>
<p>Finally, as a bonus, to remove duplicates:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">lcd ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
lcd <span class="fu">=</span> foldl&#39; (\a e <span class="ot">-&gt;</span> lcm a (denominator e)) <span class="dv">1</span>

<span class="ot">toDistrib ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> [(a,<span class="dt">Integer</span>)]
toDistrib <span class="fu">=</span> factorOut <span class="fu">.</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> [(x,<span class="dv">1</span>)]
  f l p r <span class="fu">=</span> (map<span class="fu">.</span>fmap) (n<span class="fu">%</span>t<span class="fu">*</span>) l <span class="fu">++</span> (map<span class="fu">.</span>fmap) (d<span class="fu">%</span>t<span class="fu">*</span>) r <span class="kw">where</span>
    n <span class="fu">=</span> numerator p
    d <span class="fu">=</span> denominator p
    t <span class="fu">=</span> n <span class="fu">+</span> d
  factorOut xs <span class="fu">=</span> (map<span class="fu">.</span>fmap) (numerator <span class="fu">.</span> (lcd&#39;<span class="fu">*</span>)) xs <span class="kw">where</span>
    lcd&#39; <span class="fu">=</span> fromIntegral <span class="fu">.</span> lcd <span class="fu">.</span> map snd <span class="fu">$</span> xs

<span class="ot">counts ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> n) <span class="ot">=&gt;</span> [(a,n)] <span class="ot">-&gt;</span> [(a,n)]
counts <span class="fu">=</span> 
  Map.assocs <span class="fu">.</span> 
  Map.fromListWith (<span class="fu">+</span>)
      
<span class="ot">compress ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
compress xs <span class="fu">=</span> <span class="kw">let</span> <span class="dt">Just</span> ys <span class="fu">=</span> (fromDistrib <span class="fu">.</span> counts <span class="fu">.</span> toDistrib) xs <span class="kw">in</span> ys</code></pre></div>
<p>After reading yet more on this, I found that the main issue with the monad is its performance. Two articles in particular: <span class="citation">Larsen (2011)</span>, and <span class="citation">Scibior, Ghahramani, and Gordon (2015)</span>, refer to a GADT implementation of the monad which maximises laziness.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. <a href="http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf">http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.” <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory efficient implementation of probability monads.” <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf" class="uri">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-scibior_practical_2015">
<p>Scibior, A., Z. Ghahramani, and A. D. Gordon. 2015. “Practical probabilistic programming with monads.” In <em>2015 ACM SIGPLAN symposium on haskell</em>, 50:165–176. ACM. <a href="http://mlg.eng.cam.ac.uk/pub/pdf/SciGhaGor15.pdf" class="uri">http://mlg.eng.cam.ac.uk/pub/pdf/SciGhaGor15.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 30 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>
<item>
    <title>2016-09-30-prob-trees-lhs</title>
    <link>http://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 30, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: 
    
</div>

<div id="header">
<div id="logo">
<a href="../">Donnacha Oisín Kidney</a>
</div>
<div id="navigation">
<a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../rss.xml">Feed</a>
</div>
</div>
<div id="content">
<h2 id="probability-trees">Probability Trees</h2>
<div class="info">
Posted on September 30, 2016
</div>
<div class="info">
Part 3 of a <a href="../series/probability.html">3-part series on probability</a>
</div>
<div class="info">
Tags: <a href="../tags/Haskell.html">Haskell</a>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span>
<span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span>

<span class="kw">module</span> <span class="dt">ProbTree</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Data.Ratio</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span></code></pre></div>
</div>
<p>Previously, I tried to figure out how to make the probability monad more “listy”. I read a little more about the topic <span class="citation">(especially Erwig and Kollmansberger 2006; and Kidd 2007)</span>.</p>
<p>I then thought about what a probability monad would look like if it was based on other data structures. I feel like the standard version really wants to be:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ProperProb</span> a <span class="fu">=</span> <span class="dt">ProperProb</span>
  {<span class="ot"> yes ::</span> <span class="dt">Map</span> a (<span class="dt">Product</span> <span class="dt">Rational</span>) }</code></pre></div>
</div>
<p>But of course a monad instance isn’t allowed.</p>
<p>Similar to a map, though, is a binary tree:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span>
                  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)</code></pre></div>
</div>
<p>And it feels better for probability - <em>flatter</em>, somehow. Transmuting it into a probability-thing:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certain</span> a
            <span class="fu">|</span> <span class="dt">Choice</span> (<span class="dt">Odds</span> a) <span class="dt">Rational</span> (<span class="dt">Odds</span> a)
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</code></pre></div>
</div>
<p>That looks good to me. A choice between two different branches feels more natural than a choice between a head and a tail.</p>
<p>The fold is similar to before, with an unfold for good measure:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b
foldOdds f b <span class="fu">=</span> r <span class="kw">where</span>
  r (<span class="dt">Certain</span> x) <span class="fu">=</span> b x
  r (<span class="dt">Choice</span> xs p ys) <span class="fu">=</span> f (r xs) p (r ys)
  
<span class="ot">unfoldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Either</span> a (b,<span class="dt">Rational</span>,b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
unfoldOdds f <span class="fu">=</span> r <span class="kw">where</span>
  r b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span>
    <span class="dt">Left</span> a <span class="ot">-&gt;</span> <span class="dt">Certain</span> a
    <span class="dt">Right</span> (x,p,y) <span class="ot">-&gt;</span> <span class="dt">Choice</span> (r x) p (r y)
  
<span class="ot">fi ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
fi <span class="dt">True</span>  t _ <span class="fu">=</span> t
fi <span class="dt">False</span> _ f <span class="fu">=</span> f</code></pre></div>
</div>
<p>I changed the pattern synonym a little:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">unRatio ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> (a,a)
unRatio <span class="fu">=</span> numerator   <span class="fu">&amp;&amp;&amp;</span> denominator 
      <span class="fu">&gt;&gt;&gt;</span> fromInteger <span class="fu">***</span> fromInteger

pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (unRatio <span class="ot">-&gt;</span> (n,d))</code></pre></div>
</div>
<p>Then, the <code class="sourceCode haskell">probOf</code> function:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOf e <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> fi (e <span class="fu">==</span> x) <span class="dv">1</span> <span class="dv">0</span>
  f x (n<span class="fu">:%</span>d) y <span class="fu">=</span> (x <span class="fu">*</span> n <span class="fu">+</span> y <span class="fu">*</span> d) <span class="fu">/</span> (n <span class="fu">+</span> d)</code></pre></div>
</div>
<p>This version doesn’t have the option for short-circuiting on the first value it finds.</p>
<p>For generating from lists, you can try to evenly divide the list among each branch.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">fromListOdds ::</span> (([b], <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromListOdds fr e <span class="fu">=</span> r <span class="kw">where</span>
  r [] <span class="fu">=</span> <span class="dt">Nothing</span>
  r xs <span class="fu">=</span> <span class="dt">Just</span> (unfoldOdds f (xs, length xs))
  f ([x],_) <span class="fu">=</span> <span class="dt">Left</span> (e x)
  f (xs ,n) <span class="fu">=</span> <span class="dt">Right</span> ((ys,l), fr (ys,l) <span class="fu">%</span> fr (zs,r), (zs,r)) <span class="kw">where</span>
    l <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span>
    r <span class="fu">=</span> n <span class="fu">-</span> l
    (ys,zs) <span class="fu">=</span> splitAt l xs

<span class="ot">equalOdds ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
equalOdds <span class="fu">=</span> fromListOdds (fromIntegral <span class="fu">.</span> snd) id

<span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromDistrib <span class="fu">=</span> fromListOdds (sum <span class="fu">.</span> map snd <span class="fu">.</span> fst) fst</code></pre></div>
</div>
<p>What’s really nice about this version is the fact that the old <code class="sourceCode haskell">append</code> is just the <code class="sourceCode haskell"><span class="dt">Choice</span></code> constructor, leaving the instances to be really nice:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
flatten <span class="fu">=</span> foldOdds <span class="dt">Choice</span> id

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Certain</span>
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)
  
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</code></pre></div>
</div>
<p>Finally, as a bonus, to remove duplicates:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">lcd ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
lcd <span class="fu">=</span> foldl&#39; (\a e <span class="ot">-&gt;</span> lcm a (denominator e)) <span class="dv">1</span>

<span class="ot">toDistrib ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> [(a,<span class="dt">Integer</span>)]
toDistrib <span class="fu">=</span> factorOut <span class="fu">.</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> [(x,<span class="dv">1</span>)]
  f l p r <span class="fu">=</span> (map<span class="fu">.</span>fmap) (n<span class="fu">%</span>t<span class="fu">*</span>) l <span class="fu">++</span> (map<span class="fu">.</span>fmap) (d<span class="fu">%</span>t<span class="fu">*</span>) r <span class="kw">where</span>
    n <span class="fu">=</span> numerator p
    d <span class="fu">=</span> denominator p
    t <span class="fu">=</span> n <span class="fu">+</span> d
  factorOut xs <span class="fu">=</span> (map<span class="fu">.</span>fmap) (numerator <span class="fu">.</span> (lcd&#39;<span class="fu">*</span>)) xs <span class="kw">where</span>
    lcd&#39; <span class="fu">=</span> fromIntegral <span class="fu">.</span> lcd <span class="fu">.</span> map snd <span class="fu">$</span> xs

<span class="ot">counts ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> n) <span class="ot">=&gt;</span> [(a,n)] <span class="ot">-&gt;</span> [(a,n)]
counts <span class="fu">=</span> 
  Map.assocs <span class="fu">.</span> 
  Map.fromListWith (<span class="fu">+</span>)
      
<span class="ot">compress ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
compress xs <span class="fu">=</span> <span class="kw">let</span> <span class="dt">Just</span> ys <span class="fu">=</span> (fromDistrib <span class="fu">.</span> counts <span class="fu">.</span> toDistrib) xs <span class="kw">in</span> ys</code></pre></div>
</div>
<p>After reading yet more on this, I found that the main issue with the monad is its performance. Two articles in particular: <span class="citation">Larsen (2011)</span>, and <span class="citation">Scibior, Ghahramani, and Gordon (2015)</span>, refer to a GADT implementation of the monad which maximises laziness.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. <a href="http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf">http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.” <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf" class="uri" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory efficient implementation of probability monads.” <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf" class="uri" class="uri">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-scibior_practical_2015">
<p>Scibior, A., Z. Ghahramani, and A. D. Gordon. 2015. “Practical probabilistic programming with monads.” In <em>2015 ACM SIGPLAN symposium on haskell</em>, 50:165–176. ACM. <a href="http://mlg.eng.cam.ac.uk/pub/pdf/SciGhaGor15.pdf" class="uri" class="uri">http://mlg.eng.cam.ac.uk/pub/pdf/SciGhaGor15.pdf</a>.</p>
</div>
</div>
</div>
<div id="footer">
Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
]]></description>
    <pubDate>Fri, 30 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>
<item>
    <title>A Different Probability Monad</title>
    <link>http://doisinkidney.com/posts/2016-09-27-odds-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 27, 2016
</div>
<div class="info">
    
        Part 2 of a <a href="/series/probability.html">3-part series on probability</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>One of the more unusual monads is the “probability monad”:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span>
<span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span>
<span class="ot">{-# language BangPatterns #-}</span>

<span class="kw">module</span> <span class="dt">Prob</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Data.Ratio</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Probability</span> a <span class="fu">=</span> <span class="dt">Probability</span>
  {<span class="ot"> runProb ::</span> [(a,<span class="dt">Rational</span>)] }
  
<span class="kw">data</span> <span class="dt">Coin</span> <span class="fu">=</span> <span class="dt">Heads</span> <span class="fu">|</span> <span class="dt">Tails</span>

<span class="ot">toss ::</span> <span class="dt">Probability</span> <span class="dt">Coin</span>
toss <span class="fu">=</span> <span class="dt">Probability</span> [(<span class="dt">Heads</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>), (<span class="dt">Tails</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>)]</code></pre></div>
<p>Although it’s a little inefficient, it’s an elegant representation. I’ve written about it before <a href="2015-08-03-monty-hall.html">here</a>.</p>
<p>It has some notable deficiencies, though. For instance: the user has to constantly check that all the probabilities add up to one. Its list can be empty, which doesn’t make sense. Also, individual outcomes can appear more than once in the same list.</p>
<p>A first go a fixing the problem might look something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Distrib</span> a <span class="fu">=</span> <span class="dt">Distrib</span>
  {<span class="ot"> runDist ::</span> [(a,<span class="dt">Rational</span>)] }

<span class="ot">tossProb ::</span> <span class="dt">Distrib</span> <span class="dt">Coin</span>
tossProb <span class="fu">=</span> <span class="dt">Distrib</span> [(<span class="dt">Heads</span>, <span class="dv">1</span>), (<span class="dt">Tails</span>, <span class="dv">1</span>)]</code></pre></div>
<p>The type is the same as before: it’s the semantics which have changed. The second field of the tuples no longer have to add up to one. The list can still be empty, though, and now finding the probability of, say, the head, looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probHead ::</span> <span class="dt">Distrib</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probHead (<span class="dt">Distrib</span> xs<span class="fu">@</span>((_,p)<span class="fu">:</span>_)) <span class="fu">=</span> p <span class="fu">/</span> sum [ q <span class="fu">|</span> (_,q) <span class="ot">&lt;-</span> xs ]</code></pre></div>
<p>Infinite lists aren’t possible, either.</p>
<p>One other way to look at the problem is to mimic the structure of cons-lists. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certainly</span> a
            <span class="fu">|</span> <span class="dt">Odds</span> a <span class="dt">Rational</span> (<span class="dt">Odds</span> a)
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Here, the <code class="sourceCode haskell"><span class="dt">Odds</span></code> constructor (analogous to <code class="sourceCode haskell">(<span class="fu">:</span>)</code>) contains the betting-style odds of the head element vs. <em>the rest of the list</em>. The coin from before is represented by:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">tossOdds ::</span> <span class="dt">Odds</span> <span class="dt">Coin</span>
tossOdds <span class="fu">=</span> <span class="dt">Odds</span> <span class="dt">Heads</span> (<span class="dv">1</span> <span class="fu">%</span> <span class="dv">1</span>) (<span class="dt">Certainly</span> <span class="dt">Tails</span>)</code></pre></div>
<p>This representation has tons of nice properties. First, let’s use some pattern-synonym magic for rationals:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">pattern<span class="ot"> (:%) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span>
pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (numerator <span class="fu">&amp;&amp;&amp;</span> denominator <span class="ot">-&gt;</span> (n,d)) <span class="kw">where</span>
  n <span class="fu">:%</span> d <span class="fu">=</span> n <span class="fu">%</span> d</code></pre></div>
<p>Then, finding the probability of the head element is this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probHeadOdds ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probHeadOdds (<span class="dt">Certainly</span> _) <span class="fu">=</span> <span class="dv">1</span>
probHeadOdds (<span class="dt">Odds</span> _ (n <span class="fu">:%</span> d) _) <span class="fu">=</span> n <span class="fu">:%</span> (n <span class="fu">+</span> d)</code></pre></div>
<p>The representation can handle infinite lists no problem:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">probHeadOdds (<span class="dt">Odds</span> <span class="ch">&#39;a&#39;</span> (<span class="dv">1</span> <span class="fu">:%</span> <span class="dv">1</span>) undefined)
<span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span></code></pre></div>
<p>Taking the tail preserves semantics, also. To do some more involved manipulation, a fold helper is handy:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldOdds ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b
foldOdds f b <span class="fu">=</span> r <span class="kw">where</span>
  r (<span class="dt">Certainly</span> x) <span class="fu">=</span> b x
  r (<span class="dt">Odds</span> x p xs) <span class="fu">=</span> f x p (r xs)</code></pre></div>
<p>You can use this function to find the probability of a given item:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOfEvent ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOfEvent e <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> <span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
  f x n r <span class="fu">=</span> (<span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>This assumes that each item only occurs once. A function which combines multiple events might look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOf p <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
  f x n r <span class="fu">=</span> (<span class="kw">if</span> p x <span class="kw">then</span> r <span class="fu">+</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>Some utility functions to create <code class="sourceCode haskell"><span class="dt">Odds</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">equalOdds ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
equalOdds xs <span class="fu">=</span> <span class="kw">case</span> length xs <span class="kw">of</span>
  <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
  n <span class="ot">-&gt;</span> <span class="dt">Just</span> (foldr f undefined xs (n <span class="fu">-</span> <span class="dv">1</span>)) <span class="kw">where</span>
    f y a <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Certainly</span> y
    f y a n <span class="fu">=</span> <span class="dt">Odds</span> y (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (a (n <span class="fu">-</span> <span class="dv">1</span>))

<span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromDistrib [] <span class="fu">=</span> <span class="dt">Nothing</span>
fromDistrib xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> f (tot<span class="fu">*</span>lst) xs <span class="kw">where</span>
  (tot,lst) <span class="fu">=</span> foldl&#39; (\(<span class="fu">!</span>t,_) e <span class="ot">-&gt;</span> (t<span class="fu">+</span>e,e)) (<span class="dv">0</span>,undefined) (map snd xs)
  f _ [(x,_)] <span class="fu">=</span> <span class="dt">Certainly</span> x
  f n ((x,p)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Odds</span> x (mp <span class="fu">%</span> np) (f np xs) <span class="kw">where</span>
    mp <span class="fu">=</span> p <span class="fu">*</span> lst
    np <span class="fu">=</span> n <span class="fu">-</span> mp
                  
<span class="ot">probOfEach ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOfEach x xs <span class="fu">=</span> probOf (x<span class="fu">==</span>) xs

<span class="ot">propOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Rational</span>
propOf _ [] <span class="fu">=</span> <span class="dt">Nothing</span>
propOf x xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">.</span> uncurry (<span class="fu">%</span>) <span class="fu">$</span>
  foldl&#39; (\(<span class="fu">!</span>n,<span class="fu">!</span>m) e <span class="ot">-&gt;</span> (<span class="kw">if</span> x <span class="fu">==</span> e <span class="kw">then</span> n<span class="fu">+</span><span class="dv">1</span> <span class="kw">else</span> n, m<span class="fu">+</span><span class="dv">1</span>)) (<span class="dv">0</span>,<span class="dv">0</span>) xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">propOf x xs <span class="fu">==</span> fmap (probOfEach x) (equalOdds xs)</code></pre></div>
<p>And finally, the instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">append ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
append <span class="fu">=</span> foldOdds f <span class="dt">Odds</span> <span class="kw">where</span>
  f e r a p ys <span class="fu">=</span> <span class="dt">Odds</span> e ip (a op ys) <span class="kw">where</span>
    ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)
    op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
flatten <span class="fu">=</span> foldOdds append id

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Certainly</span>
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)
  
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</code></pre></div>
]]></description>
    <pubDate>Tue, 27 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-27-odds-lhs.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>
<item>
    <title>2016-09-27-odds-lhs</title>
    <link>http://doisinkidney.com/posts/2016-09-27-odds-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 27, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: 
    
</div>

<div id="header">
<div id="logo">
<a href="../">Donnacha Oisín Kidney</a>
</div>
<div id="navigation">
<a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../rss.xml">Feed</a>
</div>
</div>
<div id="content">
<h2 id="a-different-probability-monad">A Different Probability Monad</h2>
<div class="info">
Posted on September 27, 2016
</div>
<div class="info">
Part 2 of a <a href="../series/probability.html">3-part series on probability</a>
</div>
<div class="info">
Tags: <a href="../tags/Haskell.html">Haskell</a>
</div>
<p>One of the more unusual monads is the “probability monad”:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span>
<span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span>
<span class="ot">{-# language BangPatterns #-}</span>

<span class="kw">module</span> <span class="dt">Prob</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Data.Ratio</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span></code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Probability</span> a <span class="fu">=</span> <span class="dt">Probability</span>
  {<span class="ot"> runProb ::</span> [(a,<span class="dt">Rational</span>)] }
  
<span class="kw">data</span> <span class="dt">Coin</span> <span class="fu">=</span> <span class="dt">Heads</span> <span class="fu">|</span> <span class="dt">Tails</span>

<span class="ot">toss ::</span> <span class="dt">Probability</span> <span class="dt">Coin</span>
toss <span class="fu">=</span> <span class="dt">Probability</span> [(<span class="dt">Heads</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>), (<span class="dt">Tails</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>)]</code></pre></div>
</div>
<p>Although it’s a little inefficient, it’s an elegant representation. I’ve written about it before <a href="2015-08-03-monty-hall.html">here</a>.</p>
<p>It has some notable deficiencies, though. For instance: the user has to constantly check that all the probabilities add up to one. Its list can be empty, which doesn’t make sense. Also, individual outcomes can appear more than once in the same list.</p>
<p>A first go a fixing the problem might look something like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Distrib</span> a <span class="fu">=</span> <span class="dt">Distrib</span>
  {<span class="ot"> runDist ::</span> [(a,<span class="dt">Rational</span>)] }

<span class="ot">tossProb ::</span> <span class="dt">Distrib</span> <span class="dt">Coin</span>
tossProb <span class="fu">=</span> <span class="dt">Distrib</span> [(<span class="dt">Heads</span>, <span class="dv">1</span>), (<span class="dt">Tails</span>, <span class="dv">1</span>)]</code></pre></div>
</div>
<p>The type is the same as before: it’s the semantics which have changed. The second field of the tuples no longer have to add up to one. The list can still be empty, though, and now finding the probability of, say, the head, looks like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probHead ::</span> <span class="dt">Distrib</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probHead (<span class="dt">Distrib</span> xs<span class="fu">@</span>((_,p)<span class="fu">:</span>_)) <span class="fu">=</span> p <span class="fu">/</span> sum [ q <span class="fu">|</span> (_,q) <span class="ot">&lt;-</span> xs ]</code></pre></div>
</div>
<p>Infinite lists aren’t possible, either.</p>
<p>One other way to look at the problem is to mimic the structure of cons-lists. Something like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certainly</span> a
            <span class="fu">|</span> <span class="dt">Odds</span> a <span class="dt">Rational</span> (<span class="dt">Odds</span> a)
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</code></pre></div>
</div>
<p>Here, the <code class="sourceCode haskell"><span class="dt">Odds</span></code> constructor (analogous to <code class="sourceCode haskell">(<span class="fu">:</span>)</code>) contains the betting-style odds of the head element vs. <em>the rest of the list</em>. The coin from before is represented by:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">tossOdds ::</span> <span class="dt">Odds</span> <span class="dt">Coin</span>
tossOdds <span class="fu">=</span> <span class="dt">Odds</span> <span class="dt">Heads</span> (<span class="dv">1</span> <span class="fu">%</span> <span class="dv">1</span>) (<span class="dt">Certainly</span> <span class="dt">Tails</span>)</code></pre></div>
</div>
<p>This representation has tons of nice properties. First, let’s use some pattern-synonym magic for rationals:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">pattern<span class="ot"> (:%) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span>
pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (numerator <span class="fu">&amp;&amp;&amp;</span> denominator <span class="ot">-&gt;</span> (n,d)) <span class="kw">where</span>
  n <span class="fu">:%</span> d <span class="fu">=</span> n <span class="fu">%</span> d</code></pre></div>
</div>
<p>Then, finding the probability of the head element is this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probHeadOdds ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probHeadOdds (<span class="dt">Certainly</span> _) <span class="fu">=</span> <span class="dv">1</span>
probHeadOdds (<span class="dt">Odds</span> _ (n <span class="fu">:%</span> d) _) <span class="fu">=</span> n <span class="fu">:%</span> (n <span class="fu">+</span> d)</code></pre></div>
</div>
<p>The representation can handle infinite lists no problem:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">probHeadOdds (<span class="dt">Odds</span> <span class="ch">&#39;a&#39;</span> (<span class="dv">1</span> <span class="fu">:%</span> <span class="dv">1</span>) undefined)
<span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span></code></pre></div>
</div>
<p>Taking the tail preserves semantics, also. To do some more involved manipulation, a fold helper is handy:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">foldOdds ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b
foldOdds f b <span class="fu">=</span> r <span class="kw">where</span>
  r (<span class="dt">Certainly</span> x) <span class="fu">=</span> b x
  r (<span class="dt">Odds</span> x p xs) <span class="fu">=</span> f x p (r xs)</code></pre></div>
</div>
<p>You can use this function to find the probability of a given item:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOfEvent ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOfEvent e <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> <span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
  f x n r <span class="fu">=</span> (<span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
</div>
<p>This assumes that each item only occurs once. A function which combines multiple events might look like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOf p <span class="fu">=</span> foldOdds f b <span class="kw">where</span>
  b x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
  f x n r <span class="fu">=</span> (<span class="kw">if</span> p x <span class="kw">then</span> r <span class="fu">+</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
</div>
<p>Some utility functions to create <code class="sourceCode haskell"><span class="dt">Odds</span></code>:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">equalOdds ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
equalOdds xs <span class="fu">=</span> <span class="kw">case</span> length xs <span class="kw">of</span>
  <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
  n <span class="ot">-&gt;</span> <span class="dt">Just</span> (foldr f undefined xs (n <span class="fu">-</span> <span class="dv">1</span>)) <span class="kw">where</span>
    f y a <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Certainly</span> y
    f y a n <span class="fu">=</span> <span class="dt">Odds</span> y (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (a (n <span class="fu">-</span> <span class="dv">1</span>))

<span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)
fromDistrib [] <span class="fu">=</span> <span class="dt">Nothing</span>
fromDistrib xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> f (tot<span class="fu">*</span>lst) xs <span class="kw">where</span>
  (tot,lst) <span class="fu">=</span> foldl&#39; (\(<span class="fu">!</span>t,_) e <span class="ot">-&gt;</span> (t<span class="fu">+</span>e,e)) (<span class="dv">0</span>,undefined) (map snd xs)
  f _ [(x,_)] <span class="fu">=</span> <span class="dt">Certainly</span> x
  f n ((x,p)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Odds</span> x (mp <span class="fu">%</span> np) (f np xs) <span class="kw">where</span>
    mp <span class="fu">=</span> p <span class="fu">*</span> lst
    np <span class="fu">=</span> n <span class="fu">-</span> mp
                  
<span class="ot">probOfEach ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span>
probOfEach x xs <span class="fu">=</span> probOf (x<span class="fu">==</span>) xs

<span class="ot">propOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Rational</span>
propOf _ [] <span class="fu">=</span> <span class="dt">Nothing</span>
propOf x xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">.</span> uncurry (<span class="fu">%</span>) <span class="fu">$</span>
  foldl&#39; (\(<span class="fu">!</span>n,<span class="fu">!</span>m) e <span class="ot">-&gt;</span> (<span class="kw">if</span> x <span class="fu">==</span> e <span class="kw">then</span> n<span class="fu">+</span><span class="dv">1</span> <span class="kw">else</span> n, m<span class="fu">+</span><span class="dv">1</span>)) (<span class="dv">0</span>,<span class="dv">0</span>) xs</code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell">propOf x xs <span class="fu">==</span> fmap (probOfEach x) (equalOdds xs)</code></pre></div>
</div>
<p>And finally, the instances:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">append ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
append <span class="fu">=</span> foldOdds f <span class="dt">Odds</span> <span class="kw">where</span>
  f e r a p ys <span class="fu">=</span> <span class="dt">Odds</span> e ip (a op ys) <span class="kw">where</span>
    ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)
    op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a
flatten <span class="fu">=</span> foldOdds append id

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Certainly</span>
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)
  
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span>
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</code></pre></div>
</div>
</div>
<div id="footer">
Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
]]></description>
    <pubDate>Tue, 27 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-27-odds-lhs.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>
<item>
    <title>Revisiting a Trie in Haskell</title>
    <link>http://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 26, 2016
</div>
<div class="info">
    
        Part 2 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="conforming-to-foldable">Conforming to Foldable</h1>
<p>When I ended the last post, I had a nice <code class="sourceCode haskell"><span class="dt">Trie</span></code> datatype, with plenty of functions, but I couldn’t get it to conform to the standard Haskell classes. The problem was to do with the type variables in the Trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language GADTs, FlexibleInstances, TypeFamilies #-}</span>
<span class="ot">{-# language DeriveFoldable, DeriveFunctor, DeriveTraversable #-}</span>
<span class="ot">{-# language FunctionalDependencies, FlexibleInstances #-}</span>

<span class="kw">module</span> <span class="dt">Tries</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">IsList</span>(..))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OldTrie</span> a <span class="fu">=</span> <span class="dt">OldTrie</span>
  {<span class="ot"> otEndHere  ::</span> <span class="dt">Bool</span>
  ,<span class="ot"> otChildren ::</span> <span class="dt">Map</span> a (<span class="dt">OldTrie</span> a) }</code></pre></div>
<p>Although the type variable is <code class="sourceCode haskell">a</code>, the trie really contains <em>lists</em> of <code class="sourceCode haskell">a</code>s. At least, that’s what’s reflected in functions like <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">member</code>, etc.:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">member ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f otEndHere <span class="kw">where</span>
  f e a <span class="fu">=</span> maybe <span class="dt">False</span> a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> otChildren
  
<span class="ot">otInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a
otInsert <span class="fu">=</span> foldr f b <span class="kw">where</span>
  b (<span class="dt">OldTrie</span> _ c) <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">True</span> c
  f e a (<span class="dt">OldTrie</span> n c) <span class="fu">=</span> <span class="dt">OldTrie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)
  
<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">OldTrie</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">False</span> mempty
  <span class="dt">OldTrie</span> v c <span class="ot">`mappend`</span> <span class="dt">OldTrie</span> t d <span class="fu">=</span> 
    <span class="dt">OldTrie</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</code></pre></div>
<p>Realistically, the type which the trie contains is more like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Trie</span> (f a)</code></pre></div>
<p>That signature strongly hints at GADTs, as was indicated by <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">this stackoverflow answer</a>. The particular GADT which is applicable here is this:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TrieSet</span> a <span class="kw">where</span> <span class="dt">TrieSet</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">tsEndHere ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
tsEndHere (<span class="dt">TrieSet</span> e _) <span class="fu">=</span> e

<span class="ot">tsChildren ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a])
tsChildren (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> c

<span class="ot">tsInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]
tsInsert <span class="fu">=</span> foldr f b <span class="kw">where</span>
<span class="ot">  b ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]
<span class="ot">  f ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (<span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]

  b (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">True</span> c
  f e a (<span class="dt">TrieSet</span> n c) <span class="fu">=</span> <span class="dt">TrieSet</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)
  
<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">False</span> Map.empty
  <span class="dt">TrieSet</span> v c <span class="ot">`mappend`</span> <span class="dt">TrieSet</span> t d <span class="fu">=</span> 
    <span class="dt">TrieSet</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</code></pre></div>
<p>Why lists and not a general <code class="sourceCode haskell"><span class="dt">Foldable</span></code>? Well, for the particular use I had in mind (conforming to the <code class="sourceCode haskell"><span class="dt">Foldable</span></code> typeclass), I need <code class="sourceCode haskell">(<span class="fu">:</span>)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">TrieSet</span> <span class="kw">where</span>
  foldr f b (<span class="dt">TrieSet</span> e c) <span class="fu">=</span> <span class="kw">if</span> e <span class="kw">then</span> f [] r <span class="kw">else</span> r <span class="kw">where</span>
    r <span class="fu">=</span> Map.foldrWithKey (flip <span class="fu">.</span> g <span class="fu">.</span> (<span class="fu">:</span>)) b c
    g k <span class="fu">=</span> foldr (f <span class="fu">.</span> k)</code></pre></div>
<p>With some more helper functions, the interface becomes pretty nice:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  showsPrec d t <span class="fu">=</span> 
    showParen 
      (d <span class="fu">&gt;</span> <span class="dv">10</span>)
      (showString <span class="st">&quot;fromList &quot;</span> <span class="fu">.</span> shows (foldr (<span class="fu">:</span>) [] t))

<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">TrieSet</span> [a]) <span class="fu">=</span> [a]
  fromList <span class="fu">=</span> foldr tsInsert mempty
  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</code></pre></div>
<p>The trie has the side-effect of lexicographically sorting what it’s given:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XGADTs</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">fromList [<span class="st">&quot;ced&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ced&quot;</span>, <span class="st">&quot;cb&quot;</span>, <span class="st">&quot;ab&quot;</span>]<span class="ot"> ::</span> <span class="dt">TrieSet</span> <span class="dt">String</span>
fromList [<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;abc&quot;</span>,<span class="st">&quot;cb&quot;</span>,<span class="st">&quot;ced&quot;</span>]</code></pre></div>
<h1 id="further-generalizing">Further Generalizing</h1>
<p>Most implementations of tries that I’ve seen are map-like data structures, rather than set-like. In other words, instead of holding a <code class="sourceCode haskell"><span class="dt">Bool</span></code> at the value position, it holds a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> something.</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">
<span class="kw">data</span> <span class="dt">Trie</span> a b <span class="fu">=</span> <span class="dt">Trie</span>
  {<span class="ot"> endHere  ::</span> b
  ,<span class="ot"> children ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a b) 
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</code></pre></div>
<p>This is a much more straightforward datatype. <code class="sourceCode haskell"><span class="dt">Foldable</span></code> can even be automatically derived.</p>
<p>However, I haven’t made the <code class="sourceCode haskell">endHere</code> field a <code class="sourceCode haskell"><span class="dt">Maybe</span> a</code>. I want to be able to write something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieSet</span> [a] <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Bool</span>
<span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Maybe</span> b)</code></pre></div>
<p>And have it automatically choose the implementation of the functions I need<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>To do that, though, I’ll need to write the base functions, agnostic of the type of <code>b</code>. I <em>can</em> rely on something like <code class="sourceCode haskell"><span class="dt">Monoid</span></code>, though:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Trie</span> mempty Map.empty
  mappend (<span class="dt">Trie</span> v k) (<span class="dt">Trie</span> t l) <span class="fu">=</span> 
    <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) k l)</code></pre></div>
<p>In fact, quite a lot of functions naturally lend themselves to this fold + monoid style:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> b
lookup <span class="fu">=</span> foldr f endHere <span class="kw">where</span>
  f e a <span class="fu">=</span> foldMap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> children

<span class="ot">insert&#39; ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b
insert&#39; xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> 
    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c) </code></pre></div>
<p>A monoid is needed for the values, though, and neither <code class="sourceCode haskell"><span class="dt">Bool</span></code> nor <code class="sourceCode haskell"><span class="ot">∀</span> a<span class="fu">.</span> <span class="dt">Maybe</span> a</code> conform to <code class="sourceCode haskell"><span class="dt">Monoid</span></code>. Looking back to the implementation of the trie-set, the <code class="sourceCode haskell">(<span class="fu">||</span>)</code> function has been replaced by <code class="sourceCode haskell">mappend</code>. There <em>is</em> a newtype wrapper in <code class="sourceCode haskell"><span class="dt">Data.Monoid</span></code> which has exactly this behaviour, though: <code class="sourceCode haskell"><span class="dt">Any</span></code>.</p>
<p>Using that, the type signatures specialize to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieSet</span> a <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Any</span>
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">Any</span>
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Any</span> <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</code></pre></div>
<p>Similarly, for <code class="sourceCode haskell"><span class="dt">Maybe</span></code>, there’s both <code class="sourceCode haskell"><span class="dt">First</span></code> and <code class="sourceCode haskell"><span class="dt">Last</span></code>. They have the behaviour:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span class="dt">First</span> (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">First</span> (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">First</span> (<span class="dt">Just</span> x)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span class="dt">Last</span>  (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y)</code></pre></div>
<p>I think it makes more sense for a value inserted into a map to overwrite whatever was there before. Since the newer value is on the left in the <code class="sourceCode haskell">mappend</code>, then, <code class="sourceCode haskell"><span class="dt">First</span></code> makes most sense.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">First</span> b)
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">First</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</code></pre></div>
<p>There are some other ways that you can interpret the monoid. For instance, subbing in <code class="sourceCode haskell"><span class="dt">Sum</span> <span class="dt">Int</span></code> gives you a bag-like trie:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieBag</span> a <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Sum</span> <span class="dt">Int</span>)
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span>
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a</code></pre></div>
<p>This is a set which can store multiple copies of each member. Turned the other way around, a map which stores many values for each key looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieBin</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a [b]
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> [b]
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</code></pre></div>
<p>This method so far isn’t really satisfying, though. Really, the <code class="sourceCode haskell">insert</code> signatures should look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</code></pre></div>
<p>Modifying insert slightly, you can get exactly that:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Applicative</span> c, <span class="dt">Monoid</span> (c b)) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b) <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b)
insert xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (pure v <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</code></pre></div>
<p><code class="sourceCode haskell">pure</code> from <code class="sourceCode haskell"><span class="dt">Applicative</span></code> is needed for the “embedding”.</p>
<p>Similarly, the “inserting” for the set-like types isn’t really right. The value argument is out of place. This should be the signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a
<span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a</code></pre></div>
<p>In particular, while we have an “empty” thing (0, False) for monoids, we need a “one” thing (1, True) for this function. A semiring<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> gives this exact method:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> a <span class="kw">where</span>
<span class="ot">  one ::</span> a
<span class="ot">  mul ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
  
<span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Sum</span> a) <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dv">1</span>
  mul <span class="fu">=</span> (<span class="fu">*</span>)

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Any</span> <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dt">Any</span> <span class="dt">True</span>
  <span class="dt">Any</span> x <span class="ot">`mul`</span> <span class="dt">Any</span> y <span class="fu">=</span> <span class="dt">Any</span> (x <span class="fu">&amp;&amp;</span> y)</code></pre></div>
<p>This class is kind of like a combination of both monoid wrappers for both <code class="sourceCode haskell"><span class="dt">Int</span></code> and <code class="sourceCode haskell"><span class="dt">Bool</span></code>. You could take advantage of that:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">
<span class="kw">class</span> (<span class="dt">Monoid</span> add, <span class="dt">Monoid</span> mult)
  <span class="ot">=&gt;</span> <span class="dt">SemiringIso</span> a add mult <span class="fu">|</span> a <span class="ot">-&gt;</span> add, a <span class="ot">-&gt;</span> mult <span class="kw">where</span>
<span class="ot">    toAdd    ::</span> a <span class="ot">-&gt;</span> add
<span class="ot">    fromAdd  ::</span> add <span class="ot">-&gt;</span> a
<span class="ot">    toMult   ::</span> a <span class="ot">-&gt;</span> mult
<span class="ot">    fromMult ::</span> mult <span class="ot">-&gt;</span> a
  
(<span class="fu">&lt;+&gt;</span>),<span class="ot"> (&lt;.&gt;) ::</span> <span class="dt">SemiringIso</span> a add mult <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> fromAdd  (toAdd  x <span class="fu">&lt;&gt;</span> toAdd  y)
x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> fromMult (toMult x <span class="fu">&lt;&gt;</span> toMult y)

<span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Int</span> (<span class="dt">Sum</span> <span class="dt">Int</span>) (<span class="dt">Product</span> <span class="dt">Int</span>) <span class="kw">where</span>
  toAdd    <span class="fu">=</span> <span class="dt">Sum</span>
  fromAdd  <span class="fu">=</span> getSum
  toMult   <span class="fu">=</span> <span class="dt">Product</span>
  fromMult <span class="fu">=</span> getProduct
  
<span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Bool</span> <span class="dt">Any</span> <span class="dt">All</span> <span class="kw">where</span>
  toAdd    <span class="fu">=</span> <span class="dt">Any</span>
  fromAdd  <span class="fu">=</span> getAny
  toMult   <span class="fu">=</span> <span class="dt">All</span>
  fromMult <span class="fu">=</span> getAll</code></pre></div>
<p>But it seems like overkill.</p>
<p>Anyway, assuming that we have the functions from <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, here’s the <code>add</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) 
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b
add xs <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (one <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> 
    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</code></pre></div>
<p>Now, expressions can be built up without specifying the specific monoid implementation, and the whole behaviour can be changed with a type signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">Trie</span> a b) <span class="fu">=</span> [a]
  fromList <span class="fu">=</span> foldr add mempty
<span class="ot">ans ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">ans <span class="fu">=</span> lookup <span class="st">&quot;abc&quot;</span> (fromList [<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ghi&quot;</span>])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span class="ot">ans ::</span> <span class="dt">Sum</span> <span class="dt">Int</span>
<span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">2</span>}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span class="ot">ans ::</span> <span class="dt">Any</span>
<span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}</code></pre></div>
<p>Slightly fuller implementations of all of these are available <a href="https://github.com/oisdk/hstrie">here</a>.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Kind of like <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">program inference in lieu of type inference</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>This isn’t really a very good definition of semiring. While Haskell doesn’t have this class in base, <a href="https://github.com/purescript/purescript-prelude/blob/master/src/Data/Semiring.purs">Purescript has it in their prelude.</a><a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></description>
    <pubDate>Mon, 26 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>
<item>
    <title>2016-09-26-revisiting-trie-lhs</title>
    <link>http://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 26, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: 
    
</div>

<div id="header">
<div id="logo">
<a href="../">Donnacha Oisín Kidney</a>
</div>
<div id="navigation">
<a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../rss.xml">Feed</a>
</div>
</div>
<div id="content">
<h2 id="revisiting-a-trie-in-haskell">Revisiting a Trie in Haskell</h2>
<div class="info">
Posted on September 26, 2016
</div>
<div class="info">
Part 2 of a <a href="../series/tries.html">2-part series on tries</a>
</div>
<div class="info">
Tags: <a href="../tags/Haskell.html">Haskell</a>
</div>
<h1 id="conforming-to-foldable">Conforming to Foldable</h1>
<p>When I ended the last post, I had a nice <code class="sourceCode haskell"><span class="dt">Trie</span></code> datatype, with plenty of functions, but I couldn’t get it to conform to the standard Haskell classes. The problem was to do with the type variables in the Trie:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">{-# language GADTs, FlexibleInstances, TypeFamilies #-}</span>
<span class="ot">{-# language DeriveFoldable, DeriveFunctor, DeriveTraversable #-}</span>
<span class="ot">{-# language FunctionalDependencies, FlexibleInstances #-}</span>

<span class="kw">module</span> <span class="dt">Tries</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">IsList</span>(..))</code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OldTrie</span> a <span class="fu">=</span> <span class="dt">OldTrie</span>
  {<span class="ot"> otEndHere  ::</span> <span class="dt">Bool</span>
  ,<span class="ot"> otChildren ::</span> <span class="dt">Map</span> a (<span class="dt">OldTrie</span> a) }</code></pre></div>
</div>
<p>Although the type variable is <code class="sourceCode haskell">a</code>, the trie really contains <em>lists</em> of <code class="sourceCode haskell">a</code>s. At least, that’s what’s reflected in functions like <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">member</code>, etc.:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">member ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
member <span class="fu">=</span> foldr f otEndHere <span class="kw">where</span>
  f e a <span class="fu">=</span> maybe <span class="dt">False</span> a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> otChildren
  
<span class="ot">otInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a
otInsert <span class="fu">=</span> foldr f b <span class="kw">where</span>
  b (<span class="dt">OldTrie</span> _ c) <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">True</span> c
  f e a (<span class="dt">OldTrie</span> n c) <span class="fu">=</span> <span class="dt">OldTrie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)
  
<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">OldTrie</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">False</span> mempty
  <span class="dt">OldTrie</span> v c <span class="ot">`mappend`</span> <span class="dt">OldTrie</span> t d <span class="fu">=</span> 
    <span class="dt">OldTrie</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</code></pre></div>
</div>
<p>Realistically, the type which the trie contains is more like:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Trie</span> (f a)</code></pre></div>
</div>
<p>That signature strongly hints at GADTs, as was indicated by <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">this stackoverflow answer</a>. The particular GADT which is applicable here is this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TrieSet</span> a <span class="kw">where</span> <span class="dt">TrieSet</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="ot">tsEndHere ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
tsEndHere (<span class="dt">TrieSet</span> e _) <span class="fu">=</span> e

<span class="ot">tsChildren ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a])
tsChildren (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> c

<span class="ot">tsInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]
tsInsert <span class="fu">=</span> foldr f b <span class="kw">where</span>
<span class="ot">  b ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]
<span class="ot">  f ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (<span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]

  b (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">True</span> c
  f e a (<span class="dt">TrieSet</span> n c) <span class="fu">=</span> <span class="dt">TrieSet</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)
  
<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">False</span> Map.empty
  <span class="dt">TrieSet</span> v c <span class="ot">`mappend`</span> <span class="dt">TrieSet</span> t d <span class="fu">=</span> 
    <span class="dt">TrieSet</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</code></pre></div>
</div>
<p>Why lists and not a general <code class="sourceCode haskell"><span class="dt">Foldable</span></code>? Well, for the particular use I had in mind (conforming to the <code class="sourceCode haskell"><span class="dt">Foldable</span></code> typeclass), I need <code class="sourceCode haskell">(<span class="fu">:</span>)</code>.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">TrieSet</span> <span class="kw">where</span>
  foldr f b (<span class="dt">TrieSet</span> e c) <span class="fu">=</span> <span class="kw">if</span> e <span class="kw">then</span> f [] r <span class="kw">else</span> r <span class="kw">where</span>
    r <span class="fu">=</span> Map.foldrWithKey (flip <span class="fu">.</span> g <span class="fu">.</span> (<span class="fu">:</span>)) b c
    g k <span class="fu">=</span> foldr (f <span class="fu">.</span> k)</code></pre></div>
</div>
<p>With some more helper functions, the interface becomes pretty nice:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  showsPrec d t <span class="fu">=</span> 
    showParen 
      (d <span class="fu">&gt;</span> <span class="dv">10</span>)
      (showString <span class="st">&quot;fromList &quot;</span> <span class="fu">.</span> shows (foldr (<span class="fu">:</span>) [] t))

<span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">TrieSet</span> [a]) <span class="fu">=</span> [a]
  fromList <span class="fu">=</span> foldr tsInsert mempty
  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</code></pre></div>
</div>
<p>The trie has the side-effect of lexicographically sorting what it’s given:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XGADTs</span></code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell">fromList [<span class="st">&quot;ced&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ced&quot;</span>, <span class="st">&quot;cb&quot;</span>, <span class="st">&quot;ab&quot;</span>]<span class="ot"> ::</span> <span class="dt">TrieSet</span> <span class="dt">String</span>
fromList [<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;abc&quot;</span>,<span class="st">&quot;cb&quot;</span>,<span class="st">&quot;ced&quot;</span>]</code></pre></div>
</div>
<h1 id="further-generalizing">Further Generalizing</h1>
<p>Most implementations of tries that I’ve seen are map-like data structures, rather than set-like. In other words, instead of holding a <code class="sourceCode haskell"><span class="dt">Bool</span></code> at the value position, it holds a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> something.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Trie</span> a b <span class="fu">=</span> <span class="dt">Trie</span>
  {<span class="ot"> endHere  ::</span> b
  ,<span class="ot"> children ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a b) 
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</code></pre></div>
</div>
<p>This is a much more straightforward datatype. <code class="sourceCode haskell"><span class="dt">Foldable</span></code> can even be automatically derived.</p>
<p>However, I haven’t made the <code class="sourceCode haskell">endHere</code> field a <code class="sourceCode haskell"><span class="dt">Maybe</span> a</code>. I want to be able to write something like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieSet</span> [a] <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Bool</span>
<span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Maybe</span> b)</code></pre></div>
</div>
<p>And have it automatically choose the implementation of the functions I need<a href="#fn1" id="fnref1" class="footnoteRef"><sup>1</sup></a>.</p>
<p>To do that, though, I’ll need to write the base functions, agnostic of the type of <code>b</code>. I <em>can</em> rely on something like <code class="sourceCode haskell"><span class="dt">Monoid</span></code>, though:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Trie</span> mempty Map.empty
  mappend (<span class="dt">Trie</span> v k) (<span class="dt">Trie</span> t l) <span class="fu">=</span> 
    <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) k l)</code></pre></div>
</div>
<p>In fact, quite a lot of functions naturally lend themselves to this fold + monoid style:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> b
lookup <span class="fu">=</span> foldr f endHere <span class="kw">where</span>
  f e a <span class="fu">=</span> foldMap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> children

<span class="ot">insert&#39; ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b
insert&#39; xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> 
    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c) </code></pre></div>
</div>
<p>A monoid is needed for the values, though, and neither <code class="sourceCode haskell"><span class="dt">Bool</span></code> nor <code class="sourceCode haskell"><span class="ot">∀</span> a<span class="fu">.</span> <span class="dt">Maybe</span> a</code> conform to <code class="sourceCode haskell"><span class="dt">Monoid</span></code>. Looking back to the implementation of the trie-set, the <code class="sourceCode haskell">(<span class="fu">||</span>)</code> function has been replaced by <code class="sourceCode haskell">mappend</code>. There <em>is</em> a newtype wrapper in <code class="sourceCode haskell"><span class="dt">Data.Monoid</span></code> which has exactly this behaviour, though: <code class="sourceCode haskell"><span class="dt">Any</span></code>.</p>
<p>Using that, the type signatures specialize to:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieSet</span> a <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Any</span>
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">Any</span>
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Any</span> <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</code></pre></div>
</div>
<p>Similarly, for <code class="sourceCode haskell"><span class="dt">Maybe</span></code>, there’s both <code class="sourceCode haskell"><span class="dt">First</span></code> and <code class="sourceCode haskell"><span class="dt">Last</span></code>. They have the behaviour:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span class="dt">First</span> (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">First</span> (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">First</span> (<span class="dt">Just</span> x)</code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span class="dt">Last</span>  (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y)</code></pre></div>
</div>
<p>I think it makes more sense for a value inserted into a map to overwrite whatever was there before. Since the newer value is on the left in the <code class="sourceCode haskell">mappend</code>, then, <code class="sourceCode haskell"><span class="dt">First</span></code> makes most sense.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">First</span> b)
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">First</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</code></pre></div>
</div>
<p>There are some other ways that you can interpret the monoid. For instance, subbing in <code class="sourceCode haskell"><span class="dt">Sum</span> <span class="dt">Int</span></code> gives you a bag-like trie:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieBag</span> a <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Sum</span> <span class="dt">Int</span>)
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span>
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a</code></pre></div>
</div>
<p>This is a set which can store multiple copies of each member. Turned the other way around, a map which stores many values for each key looks like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TrieBin</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a [b]
lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> [b]
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</code></pre></div>
</div>
<p>This method so far isn’t really satisfying, though. Really, the <code class="sourceCode haskell">insert</code> signatures should look like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b
<span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</code></pre></div>
</div>
<p>Modifying insert slightly, you can get exactly that:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">insert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Applicative</span> c, <span class="dt">Monoid</span> (c b)) 
       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b) <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b)
insert xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (pure v <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</code></pre></div>
</div>
<p><code class="sourceCode haskell">pure</code> from <code class="sourceCode haskell"><span class="dt">Applicative</span></code> is needed for the “embedding”.</p>
<p>Similarly, the “inserting” for the set-like types isn’t really right. The value argument is out of place. This should be the signature:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) 
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a
<span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a</code></pre></div>
</div>
<p>In particular, while we have an “empty” thing (0, False) for monoids, we need a “one” thing (1, True) for this function. A semiring<a href="#fn2" id="fnref2" class="footnoteRef"><sup>2</sup></a> gives this exact method:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> a <span class="kw">where</span>
<span class="ot">  one ::</span> a
<span class="ot">  mul ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
  
<span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Sum</span> a) <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dv">1</span>
  mul <span class="fu">=</span> (<span class="fu">*</span>)

<span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Any</span> <span class="kw">where</span>
  one <span class="fu">=</span> <span class="dt">Any</span> <span class="dt">True</span>
  <span class="dt">Any</span> x <span class="ot">`mul`</span> <span class="dt">Any</span> y <span class="fu">=</span> <span class="dt">Any</span> (x <span class="fu">&amp;&amp;</span> y)</code></pre></div>
</div>
<p>This class is kind of like a combination of both monoid wrappers for both <code class="sourceCode haskell"><span class="dt">Int</span></code> and <code class="sourceCode haskell"><span class="dt">Bool</span></code>. You could take advantage of that:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Monoid</span> add, <span class="dt">Monoid</span> mult)
  <span class="ot">=&gt;</span> <span class="dt">SemiringIso</span> a add mult <span class="fu">|</span> a <span class="ot">-&gt;</span> add, a <span class="ot">-&gt;</span> mult <span class="kw">where</span>
<span class="ot">    toAdd    ::</span> a <span class="ot">-&gt;</span> add
<span class="ot">    fromAdd  ::</span> add <span class="ot">-&gt;</span> a
<span class="ot">    toMult   ::</span> a <span class="ot">-&gt;</span> mult
<span class="ot">    fromMult ::</span> mult <span class="ot">-&gt;</span> a
  
(<span class="fu">&lt;+&gt;</span>),<span class="ot"> (&lt;.&gt;) ::</span> <span class="dt">SemiringIso</span> a add mult <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> fromAdd  (toAdd  x <span class="fu">&lt;&gt;</span> toAdd  y)
x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> fromMult (toMult x <span class="fu">&lt;&gt;</span> toMult y)

<span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Int</span> (<span class="dt">Sum</span> <span class="dt">Int</span>) (<span class="dt">Product</span> <span class="dt">Int</span>) <span class="kw">where</span>
  toAdd    <span class="fu">=</span> <span class="dt">Sum</span>
  fromAdd  <span class="fu">=</span> getSum
  toMult   <span class="fu">=</span> <span class="dt">Product</span>
  fromMult <span class="fu">=</span> getProduct
  
<span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Bool</span> <span class="dt">Any</span> <span class="dt">All</span> <span class="kw">where</span>
  toAdd    <span class="fu">=</span> <span class="dt">Any</span>
  fromAdd  <span class="fu">=</span> getAny
  toMult   <span class="fu">=</span> <span class="dt">All</span>
  fromMult <span class="fu">=</span> getAll</code></pre></div>
</div>
<p>But it seems like overkill.</p>
<p>Anyway, assuming that we have the functions from <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, here’s the <code>add</code> function:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) 
    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b
add xs <span class="fu">=</span> foldr f b xs <span class="kw">where</span>
  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (one <span class="fu">&lt;&gt;</span> p) c
  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> 
    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</code></pre></div>
</div>
<p>Now, expressions can be built up without specifying the specific monoid implementation, and the whole behaviour can be changed with a type signature:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">Trie</span> a b) <span class="fu">=</span> [a]
  fromList <span class="fu">=</span> foldr add mempty
<span class="ot">ans ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> b</code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate"><code class="sourceCode haskell">ans <span class="fu">=</span> lookup <span class="st">&quot;abc&quot;</span> (fromList [<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ghi&quot;</span>])</code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span class="ot">ans ::</span> <span class="dt">Sum</span> <span class="dt">Int</span>
<span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">2</span>}</code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span class="ot">ans ::</span> <span class="dt">Any</span>
<span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}</code></pre></div>
</div>
<p>Slightly fuller implementations of all of these are available <a href="https://github.com/oisdk/hstrie">here</a>.</p>
<div class="footnotes">
<hr />
<ol>
<li><div id="fn1">

</div>
<p>Kind of like <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">program inference in lieu of type inference</a><a href="#fnref1">↩</a></p></li>
<li><div id="fn2">

</div>
<p>This isn’t really a very good definition of semiring. While Haskell doesn’t have this class in base, <a href="https://github.com/purescript/purescript-prelude/blob/master/src/Data/Semiring.purs">Purescript has it in their prelude.</a><a href="#fnref2">↩</a></p></li>
</ol>
</div>
</div>
<div id="footer">
Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
]]></description>
    <pubDate>Mon, 26 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>
<item>
    <title>Lenses are Static Selectors</title>
    <link>http://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 16, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>So I don’t really know what <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html">KVC</a> is, or much about <code class="sourceCode scala">performSelector</code> functions. <a href="http://inessential.com/2016/05/20/updating_local_objects_with_server_objec">This</a> blogpost, from Brent Simmons, let me know a little bit about why I would want to use them.</p>
<p>It centred around removing code repetition of this type:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {
  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span>
}

<span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {
  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span> <span class="co">// There was an (intentional)</span>
}                                    <span class="co">// bug here in the original post</span></code></pre></div>
<p>To clean up the code, Brent used selector methods. At first, I was a little uncomfortable with the solution. As far as I could tell, the basis of a lot of this machinery used functions with types like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">get</span>(fromSelector: String) -&gt; AnyObject?
func <span class="fu">set</span>(forSelector: String) -&gt; ()</code></pre></div>
<p>Which <em>seems</em> to be extremely dynamic. Stringly-typed and all that. Except that there are two different things going on here. One is the dynamic stuff; the ability to get rid of types when you need to. The other, though, has <em>nothing</em> to do with types. The other idea is being able to pass around something which can access the property (or method) of an object. Let’s look at the code that was being repeated:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {
  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span>
}

<span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {
  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span>
}</code></pre></div>
<p>The logical, obvious thing to do here is try refactor out the common elements. In fact, the only things that <em>differ</em> between the two actions above are the <code class="sourceCode scala">foo</code> and <code class="sourceCode scala">bar</code>. It would be great to be able to write a function like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">checkThenUpdate</span>(selector) {
  <span class="kw">if</span> localObject.<span class="fu">selector</span> != serverObject.<span class="fu">selector</span> {
    localObject.<span class="fu">selector</span> = serverObject.<span class="fu">selector</span>
  }
}</code></pre></div>
<p>And then maybe a single line like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">[foo, bar, baz].<span class="fu">forEach</span>(checkThenUpdate)</code></pre></div>
<p>That’s pretty obviously better. It’s just good programming: when faced with repetition, find the repeated part, and abstract it out. Is it more <em>dynamic</em> than the repetition, though? I don’t think so. All you have to figure out is an appropriate type for the selector, and you can keep all of your static checking. To me, it seems a lot like a <a href="https://hackage.haskell.org/package/lens">lens</a>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Lens&lt;Whole, Part&gt; {
  let get: Whole -&gt; Part
  let set: (Whole, Part) -&gt; Whole
}</code></pre></div>
<p>(This is a lens similar to the ones used in the <a href="http://hackage.haskell.org/package/data-lens">data-lens</a> library, in contrast to van Laarhoven lenses, or LensFamilies. LensFamilies are used in the <a href="https://hackage.haskell.org/package/lens">lens</a> package, and they allow you to change the type of the <code class="sourceCode scala">Part</code>. They’re also just normal functions, rather than a separate type, so you can manipulate them in a pretty standard way. Swift’s type system isn’t able to model those lenses, though, unfortunately.) It has two things: a getter and a setter. The getter is pretty obvious: it takes the object, and returns the property. The setter is a little more confusing. It’s taking an object, and the new property you want to stick in to the object, and returns the object with that property updated. For instance, if we were to make a <code class="sourceCode scala">Person</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct LocalPerson {
  <span class="kw">var</span> age: Int
  <span class="kw">var</span> name: String
}</code></pre></div>
<p>We could then have a lens for the <code class="sourceCode scala">name</code> field like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let localName: Lens&lt;LocalPerson,String&gt; = <span class="fu">Lens</span>(
  get: { p in p.<span class="fu">name</span> },
  set: { (oldPerson,newName) in
    <span class="kw">var</span> newPerson = oldPerson
    newPerson.<span class="fu">name</span> = newName
    <span class="kw">return</span> newPerson
  }
)</code></pre></div>
<p>And you’d use it like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let caoimhe = <span class="fu">LocalPerson</span>(age: <span class="dv">46</span>, name: <span class="st">&quot;caoimhe&quot;</span>)
localName.<span class="fu">get</span>(caoimhe) <span class="co">// 46</span>
localName.<span class="fu">set</span>(caoimhe, <span class="st">&quot;breifne&quot;</span>) <span class="co">// LocalPerson(age: 46, name: &quot;breifne&quot;)</span></code></pre></div>
<p>Straight away, we’re able to do (something) like the <code class="sourceCode scala">checkThenUpdate</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func checkThenUpdate
  &lt;A: Equatable&gt;
  (localLens: Lens&lt;LocalPerson,A&gt;, serverLens: Lens&lt;ServerPerson,A&gt;) {
  let serverProp = serverLens.<span class="fu">get</span>(serverObject)
  <span class="kw">if</span> localLens.<span class="fu">get</span>(localObject) != serverProp {
    localObject = localLens.<span class="fu">set</span>(localObject,serverProp)
  }
}</code></pre></div>
<p>And it could be called pretty tersely:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">checkThenUpdate</span>(localName, serverLens: serverName)</code></pre></div>
<p>The biggest problem with this approach, obviously, is the boilerplate. In Haskell, that’s solved with Template Haskell, so the lens code is generated for you. (I’d love to see something like that in Swift) There’s a protocol-oriented spin on lenses, also. One of the variants on lenses in Haskell are called “classy-lenses”. That’s where, instead of just generating a lens with the same name as the field it looks into, you generate a typeclass (protocol) for anything with that lens. In Swift, it might work something like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Place {
  <span class="kw">var</span> name: String
}

<span class="co">// Instead of just having a lens for the name field, have a whole protocol</span>
<span class="co">// for things with a name field:</span>

protocol HasName {
  associatedtype Name
  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; { get }
  <span class="kw">var</span> name: Name { get set }
}

<span class="co">// Because the mutable property is included in the protocol, you can rely on</span>
<span class="co">// it in extensions:</span>

extension HasName {
  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; {
    <span class="kw">return</span> <span class="fu">Lens</span>(
      get: {$<span class="fl">0.</span>name},
      set: { (w,p) in 
        <span class="kw">var</span> n = w
        n.<span class="fu">name</span> = p
        <span class="kw">return</span> n
      }
    )
  }
  <span class="kw">var</span> name: Name {
    get { <span class="kw">return</span> Self.<span class="fu">name</span>.<span class="fu">get</span>(self) }
    set { self = Self.<span class="fu">name</span>.<span class="fu">set</span>(self,newValue) }
  }
}

<span class="co">// This way, you can provide either the lens or the property, and you get the</span>
<span class="co">// other for free.</span>

extension Place: HasName {}

<span class="co">// Then, you can rely on that protocol, and all of the types:</span>

func checkEqualOnNames
  &lt;A,B where A: HasName, B: HasName, A.<span class="fu">Name</span>: Equatable, A.<span class="fu">Name</span> == B.<span class="fu">Name</span>&gt;
  (x: A, _ y: B) -&gt; Bool {
    <span class="kw">return</span> x.<span class="fu">name</span> == y.<span class="fu">name</span>
}</code></pre></div>
<p>This protocol lets you do a kind of static <code class="sourceCode scala">respondsToSelector</code>, with all of the types intact. Other people have spoken about the other things you can do with lenses in Swift (<a href="https://www.youtube.com/watch?v=ofjehH9f-CU">Brandon Williams - Lenses in Swift</a>), like composing them together, chaining operations, etc. (One other thing they can emulate is <a href="https://gist.github.com/erica/6794d48d917e2084d6ed">method cascading</a>) Unfortunately, in current Swift, the boilerplate makes all of this a little unpleasant. Still, they’re an interesting idea, and they show how a good type system needn’t always get in the way.</p>
]]></description>
    <pubDate>Thu, 16 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>
<item>
    <title>2016-06-16-lenses-are-static-selectors</title>
    <link>http://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 16, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: 
    
</div>

<div id="header">
<div id="logo">
<a href="../">Donnacha Oisín Kidney</a>
</div>
<div id="navigation">
<a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../rss.xml">Feed</a>
</div>
</div>
<div id="content">
<h2 id="lenses-are-static-selectors">Lenses are Static Selectors</h2>
<div class="info">
Posted on June 16, 2016
</div>
<div class="info">

</div>
<div class="info">
Tags: <a href="../tags/Swift.html">Swift</a>
</div>
<p>So I don’t really know what <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html">KVC</a> is, or much about <code class="sourceCode scala">performSelector</code> functions. <a href="http://inessential.com/2016/05/20/updating_local_objects_with_server_objec">This</a> blogpost, from Brent Simmons, let me know a little bit about why I would want to use them.</p>
<p>It centred around removing code repetition of this type:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {
  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span>
}

<span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {
  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span> <span class="co">// There was an (intentional)</span>
}                                    <span class="co">// bug here in the original post</span></code></pre></div>
</div>
<p>To clean up the code, Brent used selector methods. At first, I was a little uncomfortable with the solution. As far as I could tell, the basis of a lot of this machinery used functions with types like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">get</span>(fromSelector: String) -&gt; AnyObject?
func <span class="fu">set</span>(forSelector: String) -&gt; ()</code></pre></div>
</div>
<p>Which <em>seems</em> to be extremely dynamic. Stringly-typed and all that. Except that there are two different things going on here. One is the dynamic stuff; the ability to get rid of types when you need to. The other, though, has <em>nothing</em> to do with types. The other idea is being able to pass around something which can access the property (or method) of an object. Let’s look at the code that was being repeated:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {
  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span>
}

<span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {
  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span>
}</code></pre></div>
</div>
<p>The logical, obvious thing to do here is try refactor out the common elements. In fact, the only things that <em>differ</em> between the two actions above are the <code class="sourceCode scala">foo</code> and <code class="sourceCode scala">bar</code>. It would be great to be able to write a function like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func <span class="fu">checkThenUpdate</span>(selector) {
  <span class="kw">if</span> localObject.<span class="fu">selector</span> != serverObject.<span class="fu">selector</span> {
    localObject.<span class="fu">selector</span> = serverObject.<span class="fu">selector</span>
  }
}</code></pre></div>
</div>
<p>And then maybe a single line like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">[foo, bar, baz].<span class="fu">forEach</span>(checkThenUpdate)</code></pre></div>
</div>
<p>That’s pretty obviously better. It’s just good programming: when faced with repetition, find the repeated part, and abstract it out. Is it more <em>dynamic</em> than the repetition, though? I don’t think so. All you have to figure out is an appropriate type for the selector, and you can keep all of your static checking. To me, it seems a lot like a <a href="https://hackage.haskell.org/package/lens">lens</a>:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Lens&lt;Whole, Part&gt; {
  let get: Whole -&gt; Part
  let set: (Whole, Part) -&gt; Whole
}</code></pre></div>
</div>
<p>(This is a lens similar to the ones used in the <a href="http://hackage.haskell.org/package/data-lens">data-lens</a> library, in contrast to van Laarhoven lenses, or LensFamilies. LensFamilies are used in the <a href="https://hackage.haskell.org/package/lens">lens</a> package, and they allow you to change the type of the <code class="sourceCode scala">Part</code>. They’re also just normal functions, rather than a separate type, so you can manipulate them in a pretty standard way. Swift’s type system isn’t able to model those lenses, though, unfortunately.) It has two things: a getter and a setter. The getter is pretty obvious: it takes the object, and returns the property. The setter is a little more confusing. It’s taking an object, and the new property you want to stick in to the object, and returns the object with that property updated. For instance, if we were to make a <code class="sourceCode scala">Person</code>:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct LocalPerson {
  <span class="kw">var</span> age: Int
  <span class="kw">var</span> name: String
}</code></pre></div>
</div>
<p>We could then have a lens for the <code class="sourceCode scala">name</code> field like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let localName: Lens&lt;LocalPerson,String&gt; = <span class="fu">Lens</span>(
  get: { p in p.<span class="fu">name</span> },
  set: { (oldPerson,newName) in
    <span class="kw">var</span> newPerson = oldPerson
    newPerson.<span class="fu">name</span> = newName
    <span class="kw">return</span> newPerson
  }
)</code></pre></div>
</div>
<p>And you’d use it like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let caoimhe = <span class="fu">LocalPerson</span>(age: <span class="dv">46</span>, name: <span class="st">&quot;caoimhe&quot;</span>)
localName.<span class="fu">get</span>(caoimhe) <span class="co">// 46</span>
localName.<span class="fu">set</span>(caoimhe, <span class="st">&quot;breifne&quot;</span>) <span class="co">// LocalPerson(age: 46, name: &quot;breifne&quot;)</span></code></pre></div>
</div>
<p>Straight away, we’re able to do (something) like the <code class="sourceCode scala">checkThenUpdate</code> function:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">func checkThenUpdate
  &lt;A: Equatable&gt;
  (localLens: Lens&lt;LocalPerson,A&gt;, serverLens: Lens&lt;ServerPerson,A&gt;) {
  let serverProp = serverLens.<span class="fu">get</span>(serverObject)
  <span class="kw">if</span> localLens.<span class="fu">get</span>(localObject) != serverProp {
    localObject = localLens.<span class="fu">set</span>(localObject,serverProp)
  }
}</code></pre></div>
</div>
<p>And it could be called pretty tersely:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">checkThenUpdate</span>(localName, serverLens: serverName)</code></pre></div>
</div>
<p>The biggest problem with this approach, obviously, is the boilerplate. In Haskell, that’s solved with Template Haskell, so the lens code is generated for you. (I’d love to see something like that in Swift) There’s a protocol-oriented spin on lenses, also. One of the variants on lenses in Haskell are called “classy-lenses”. That’s where, instead of just generating a lens with the same name as the field it looks into, you generate a typeclass (protocol) for anything with that lens. In Swift, it might work something like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">struct Place {
  <span class="kw">var</span> name: String
}

<span class="co">// Instead of just having a lens for the name field, have a whole protocol</span>
<span class="co">// for things with a name field:</span>

protocol HasName {
  associatedtype Name
  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; { get }
  <span class="kw">var</span> name: Name { get set }
}

<span class="co">// Because the mutable property is included in the protocol, you can rely on</span>
<span class="co">// it in extensions:</span>

extension HasName {
  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; {
    <span class="kw">return</span> <span class="fu">Lens</span>(
      get: {$<span class="fl">0.</span>name},
      set: { (w,p) in 
        <span class="kw">var</span> n = w
        n.<span class="fu">name</span> = p
        <span class="kw">return</span> n
      }
    )
  }
  <span class="kw">var</span> name: Name {
    get { <span class="kw">return</span> Self.<span class="fu">name</span>.<span class="fu">get</span>(self) }
    set { self = Self.<span class="fu">name</span>.<span class="fu">set</span>(self,newValue) }
  }
}

<span class="co">// This way, you can provide either the lens or the property, and you get the</span>
<span class="co">// other for free.</span>

extension Place: HasName {}

<span class="co">// Then, you can rely on that protocol, and all of the types:</span>

func checkEqualOnNames
  &lt;A,B where A: HasName, B: HasName, A.<span class="fu">Name</span>: Equatable, A.<span class="fu">Name</span> == B.<span class="fu">Name</span>&gt;
  (x: A, _ y: B) -&gt; Bool {
    <span class="kw">return</span> x.<span class="fu">name</span> == y.<span class="fu">name</span>
}</code></pre></div>
</div>
<p>This protocol lets you do a kind of static <code class="sourceCode scala">respondsToSelector</code>, with all of the types intact. Other people have spoken about the other things you can do with lenses in Swift (<a href="https://www.youtube.com/watch?v=ofjehH9f-CU">Brandon Williams - Lenses in Swift</a>), like composing them together, chaining operations, etc. (One other thing they can emulate is <a href="https://gist.github.com/erica/6794d48d917e2084d6ed">method cascading</a>) Unfortunately, in current Swift, the boilerplate makes all of this a little unpleasant. Still, they’re an interesting idea, and they show how a good type system needn’t always get in the way.</p>
</div>
<div id="footer">
Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
]]></description>
    <pubDate>Thu, 16 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>
<item>
    <title>Folding Two Things at Once</title>
    <link>http://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>There’s a whole family of Haskell brainteasers surrounding one function: <code class="sourceCode haskell">foldr</code>. The general idea is to convert some function on lists which uses recursion into one that uses <code class="sourceCode haskell">foldr</code>. <code class="sourceCode haskell">map</code>, for instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map f <span class="fu">=</span> foldr (\e a <span class="ot">-&gt;</span> f e <span class="fu">:</span> a) []</code></pre></div>
<p>Some can get a little trickier. <code class="sourceCode haskell">dropWhile</code>, for instance. (See <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">here</a> and <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">here</a> for interesting articles on that one in particular.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dropWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhile p <span class="fu">=</span> fst <span class="fu">.</span> foldr f ([],[]) <span class="kw">where</span>
  f e <span class="fu">~</span>(xs,ys) <span class="fu">=</span> (<span class="kw">if</span> p e <span class="kw">then</span> xs <span class="kw">else</span> zs, zs) <span class="kw">where</span> zs <span class="fu">=</span> e <span class="fu">:</span> ys</code></pre></div>
<h2 id="zip">Zip</h2>
<p>One function which was a little harder to convert than it first seemed was <code class="sourceCode haskell">zip</code>.</p>
<p>Here’s the first (non) solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> foldr f (const []) <span class="kw">where</span>
  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys
  f _ _  [] <span class="fu">=</span> []</code></pre></div>
<p>The problem with the above isn’t that it doesn’t work: it does. The problem is that it’s not <em>really</em> using <code class="sourceCode haskell">foldr</code>. It’s only using it on the first list: there’s still a manual uncons being performed on the second. Ideally, I would want the function to look something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs ys <span class="fu">=</span> foldr f (\_ _ <span class="ot">-&gt;</span> []) xs (foldr g (const []) ys)</code></pre></div>
<p>The best solution I found online only dealt with <code class="sourceCode haskell"><span class="dt">Fold</span></code>s, not <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s. You can read it <a href="http://okmij.org/ftp/Haskell/zip-folds.lhs">here</a>.</p>
<h2 id="recursive-types">Recursive Types</h2>
<p>Reworking the solution online for <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s, the initial intuition is to have the <code class="sourceCode haskell">foldr</code> on the <code class="sourceCode haskell">ys</code> produce a function which takes an element of the <code class="sourceCode haskell">xs</code>, and returns a function which takes an element of the <code class="sourceCode haskell">xs</code>, and so on, finally returning the created list. The <em>problem</em> with that approach is the types involved:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs <span class="fu">=</span> foldr f (const []) xs <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
  g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 r2)
  f e r x <span class="fu">=</span> x e r</code></pre></div>
<p>You get the error:</p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Occurs</span> check<span class="fu">:</span> cannot construct the infinite <span class="kw">type</span><span class="fu">:</span> t0 <span class="fu">~</span> a <span class="ot">-&gt;</span> (t0 <span class="ot">-&gt;</span> [(a, b)]) <span class="ot">-&gt;</span> [(a, b)]</code>.</p>
</blockquote>
<p>Haskell’s typechecker doesn’t allow for infinitely recursive types.</p>
<p>You’ll be familiar with this problem if you’ve ever tried to encode the Y-combinator, or if you’ve fiddled around with the recursion-schemes package. You might also be familiar with the solution: a <code class="sourceCode haskell"><span class="kw">newtype</span></code>, encapsulating the recursion. In this case, the <code class="sourceCode haskell"><span class="kw">newtype</span></code> looks very similar to the signature for <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecFold</span> a b <span class="fu">=</span> 
  <span class="dt">RecFold</span> {<span class="ot"> runRecFold ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecFold</span> a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b }</code></pre></div>
<p>Now you can insert and remove the <code class="sourceCode haskell"><span class="dt">RecFold</span></code> wrapper, helping the typechecker to understand the recursive types as it goes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs <span class="fu">=</span>
  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>As an aside, the performance characteristics of the <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper are totally opaque to me. There may be significant improvements by using <code class="sourceCode haskell">coerce</code> from <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Coerce.html">Data.Coerce</a>, but I haven’t looked into it.</p>
<h2 id="generalised-zips">Generalised Zips</h2>
<p>The immediate temptation from the function above is to generalise it. First to <code class="sourceCode haskell">zipWith</code>, obviously:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]
zipWith c xs <span class="fu">=</span>
  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>What’s maybe a little more interesting, though, would be a <code class="sourceCode haskell">foldr</code> on two lists. Something which folds through both at once, using a supplied combining function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldr2 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g)
       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c)
       <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> c
foldr2 c i xs <span class="fu">=</span>
  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> i) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>Of course, once you can do two, you can do three:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldr3 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g, <span class="dt">Foldable</span> h)
       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> d)
       <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> h c <span class="ot">-&gt;</span> d
foldr3 c i xs ys <span class="fu">=</span>
  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr2 g (\_ _ <span class="ot">-&gt;</span> i) ys <span class="kw">where</span>
    g e2 e3 r2 e1 r1 <span class="fu">=</span> c e1 e2 e3 (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
<p>And so on.</p>
<p>There’s the added benefit that the above functions work on much more than just lists.</p>
<h2 id="catamorphisms">Catamorphisms</h2>
<p>Getting a little formal about the above functions, a <code class="sourceCode haskell">fold</code> can be described as a catamorphism. This is a name for a pattern of breaking down some recursive structure. There’s a bunch of them in the <a href="https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html">recursion-schemes</a> package. The question is, then: can you express the above as a kind of catamorphism? Initially, using the same techniques as before, you can:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecF</span> f a <span class="fu">=</span> <span class="dt">RecF</span> {<span class="ot"> unRecF ::</span> <span class="dt">Base</span> f (<span class="dt">RecF</span> f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a }

<span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)
     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">RecF</span> g c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">RecF</span> g c <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c)
     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c
zipo alg xs ys <span class="fu">=</span> cata (flip unRecF) ys (cata (<span class="dt">RecF</span> <span class="fu">.</span> alg) xs)</code></pre></div>
<p>Then, coming full circle, you get a quite nice encoding of <code class="sourceCode haskell">zip</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> zipo alg <span class="kw">where</span>
  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []
  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []
  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x, y) <span class="fu">:</span> ys xs</code></pre></div>
<p>However, the <code class="sourceCode haskell"><span class="dt">RecF</span></code> is a little ugly. In fact, it’s possible to write the above without any recursive types, using the RankNTypes extension. (It’s possible that you could do the same with <code class="sourceCode haskell">foldr2</code> as well, but I haven’t figured it out yet)</p>
<p>You can actually use a <code class="sourceCode haskell"><span class="kw">newtype</span></code> that’s provided by the recursion-schemes library as-is. It’s <code class="sourceCode haskell"><span class="dt">Mu</span></code>. This is required for an encoding of the Y-combinator. It’s usually presented in this form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Mu</span> a <span class="fu">=</span> <span class="dt">Roll</span> {<span class="ot"> unroll ::</span> <span class="dt">Mu</span> a <span class="ot">-&gt;</span> a }</code></pre></div>
<p>However, in the recursion-schemes package, its definition looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> (forall a<span class="fu">.</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a)</code></pre></div>
<p>No recursion! The <code class="sourceCode haskell">zipo</code> combinator above can be written using <code class="sourceCode haskell"><span class="dt">Mu</span></code> like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)
     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">Mu</span> (<span class="dt">Base</span> g) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">Mu</span> (<span class="dt">Base</span> g)) <span class="ot">-&gt;</span> c)
     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c
zipo alg xs <span class="fu">=</span> cata (\x <span class="ot">-&gt;</span> alg x <span class="fu">.</span> project) xs <span class="fu">.</span> refix</code></pre></div>
<p>And the new version of <code class="sourceCode haskell">zip</code> has a slightly more natural order of arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> zipo alg <span class="kw">where</span>
  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []
  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []
  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</code></pre></div>
<h2 id="zipping-into">Zipping Into</h2>
<p>There’s one more issue, though, that’s slightly tangential. A lot of the time, the attraction of rewriting functions using folds and catamorphisms is that the function becomes more general: it no longer is restricted to lists. For <code class="sourceCode haskell">zip</code>, however, there’s still a pesky list left in the signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> [(a,b)]</code></pre></div>
<p>It would be a little nicer to be able to zip through something <em>preserving</em> the structure of one of the things being zipped through. For no reason in particular, let’s assume we’ll preserve the structure of the first argument. The function will have to account for the second argument running out before the first, though. A <code class="sourceCode haskell"><span class="dt">Maybe</span></code> can account for that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) 
        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) 
        <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f c</code></pre></div>
<p>If the second argument runs out, <code class="sourceCode haskell"><span class="dt">Nothing</span></code> will be passed to the combining function.</p>
<p>It’s clear that this isn’t a <em>fold</em> over the first argument, it’s a <em>traversal</em>. A first go at the function uses the state monad, but restricts the second argument to a list:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c
zipInto c xs ys <span class="fu">=</span> evalState (traverse f xs) ys <span class="kw">where</span>
  f x <span class="fu">=</span> <span class="kw">do</span>
    h <span class="ot">&lt;-</span> gets uncons
    <span class="kw">case</span> h <span class="kw">of</span> 
      <span class="dt">Just</span> (y,t) <span class="ot">-&gt;</span> <span class="kw">do</span> 
        put t
        pure (c x (<span class="dt">Just</span> y))
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> pure (c x <span class="dt">Nothing</span>)</code></pre></div>
<p>That code can be cleaned up a little:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c 
zipInto c <span class="fu">=</span> evalState <span class="fu">.</span> traverse (state <span class="fu">.</span> f <span class="fu">.</span> c) <span class="kw">where</span>
  f x [] <span class="fu">=</span> (x <span class="dt">Nothing</span>, [])
  f x (y<span class="fu">:</span>ys) <span class="fu">=</span> (x (<span class="dt">Just</span> y), ys)</code></pre></div>
<p>But really, the uncons needs to go. Another <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper is needed, and here’s the end result:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecAccu</span> a b <span class="fu">=</span>
  <span class="dt">RecAccu</span> {<span class="ot"> runRecAccu ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecAccu</span> a b, b) }
  
<span class="ot">zipInto ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Foldable</span> f)
        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> t c
zipInto f xs <span class="fu">=</span>
  snd <span class="fu">.</span> flip (mapAccumL runRecAccu) xs <span class="fu">.</span> <span class="dt">RecAccu</span> <span class="fu">.</span> foldr h i <span class="kw">where</span>
    i e <span class="fu">=</span> (<span class="dt">RecAccu</span> i, f e <span class="dt">Nothing</span>)
    h e2 a e1 <span class="fu">=</span> (<span class="dt">RecAccu</span> a, f e1 (<span class="dt">Just</span> e2))</code></pre></div>
]]></description>
    <pubDate>Sun, 17 Apr 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>
<item>
    <title>2016-04-17-folding-two-at-once</title>
    <link>http://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: 
    
</div>

<div id="header">
<div id="logo">
<a href="../">Donnacha Oisín Kidney</a>
</div>
<div id="navigation">
<a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../rss.xml">Feed</a>
</div>
</div>
<div id="content">
<h2 id="folding-two-things-at-once">Folding Two Things at Once</h2>
<div class="info">
Posted on April 17, 2016
</div>
<div class="info">

</div>
<div class="info">
Tags: <a href="../tags/Haskell.html">Haskell</a>
</div>
<p>There’s a whole family of Haskell brainteasers surrounding one function: <code class="sourceCode haskell">foldr</code>. The general idea is to convert some function on lists which uses recursion into one that uses <code class="sourceCode haskell">foldr</code>. <code class="sourceCode haskell">map</code>, for instance:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map f <span class="fu">=</span> foldr (\e a <span class="ot">-&gt;</span> f e <span class="fu">:</span> a) []</code></pre></div>
</div>
<p>Some can get a little trickier. <code class="sourceCode haskell">dropWhile</code>, for instance. (See <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">here</a> and <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">here</a> for interesting articles on that one in particular.)</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dropWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
dropWhile p <span class="fu">=</span> fst <span class="fu">.</span> foldr f ([],[]) <span class="kw">where</span>
  f e <span class="fu">~</span>(xs,ys) <span class="fu">=</span> (<span class="kw">if</span> p e <span class="kw">then</span> xs <span class="kw">else</span> zs, zs) <span class="kw">where</span> zs <span class="fu">=</span> e <span class="fu">:</span> ys</code></pre></div>
</div>
<h2 id="zip">Zip</h2>
<p>One function which was a little harder to convert than it first seemed was <code class="sourceCode haskell">zip</code>.</p>
<p>Here’s the first (non) solution:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> foldr f (const []) <span class="kw">where</span>
  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys
  f _ _  [] <span class="fu">=</span> []</code></pre></div>
</div>
<p>The problem with the above isn’t that it doesn’t work: it does. The problem is that it’s not <em>really</em> using <code class="sourceCode haskell">foldr</code>. It’s only using it on the first list: there’s still a manual uncons being performed on the second. Ideally, I would want the function to look something like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs ys <span class="fu">=</span> foldr f (\_ _ <span class="ot">-&gt;</span> []) xs (foldr g (const []) ys)</code></pre></div>
</div>
<p>The best solution I found online only dealt with <code class="sourceCode haskell"><span class="dt">Fold</span></code>s, not <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s. You can read it <a href="http://okmij.org/ftp/Haskell/zip-folds.lhs">here</a>.</p>
<h2 id="recursive-types">Recursive Types</h2>
<p>Reworking the solution online for <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s, the initial intuition is to have the <code class="sourceCode haskell">foldr</code> on the <code class="sourceCode haskell">ys</code> produce a function which takes an element of the <code class="sourceCode haskell">xs</code>, and returns a function which takes an element of the <code class="sourceCode haskell">xs</code>, and so on, finally returning the created list. The <em>problem</em> with that approach is the types involved:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs <span class="fu">=</span> foldr f (const []) xs <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
  g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 r2)
  f e r x <span class="fu">=</span> x e r</code></pre></div>
</div>
<p>You get the error:</p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Occurs</span> check<span class="fu">:</span> cannot construct the infinite <span class="kw">type</span><span class="fu">:</span> t0 <span class="fu">~</span> a <span class="ot">-&gt;</span> (t0 <span class="ot">-&gt;</span> [(a, b)]) <span class="ot">-&gt;</span> [(a, b)]</code>.</p>
</blockquote>
<p>Haskell’s typechecker doesn’t allow for infinitely recursive types.</p>
<p>You’ll be familiar with this problem if you’ve ever tried to encode the Y-combinator, or if you’ve fiddled around with the recursion-schemes package. You might also be familiar with the solution: a <code class="sourceCode haskell"><span class="kw">newtype</span></code>, encapsulating the recursion. In this case, the <code class="sourceCode haskell"><span class="kw">newtype</span></code> looks very similar to the signature for <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecFold</span> a b <span class="fu">=</span> 
  <span class="dt">RecFold</span> {<span class="ot"> runRecFold ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecFold</span> a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b }</code></pre></div>
</div>
<p>Now you can insert and remove the <code class="sourceCode haskell"><span class="dt">RecFold</span></code> wrapper, helping the typechecker to understand the recursive types as it goes:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip xs <span class="fu">=</span>
  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
</div>
<p>As an aside, the performance characteristics of the <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper are totally opaque to me. There may be significant improvements by using <code class="sourceCode haskell">coerce</code> from <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Coerce.html">Data.Coerce</a>, but I haven’t looked into it.</p>
<h2 id="generalised-zips">Generalised Zips</h2>
<p>The immediate temptation from the function above is to generalise it. First to <code class="sourceCode haskell">zipWith</code>, obviously:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]
zipWith c xs <span class="fu">=</span>
  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
</div>
<p>What’s maybe a little more interesting, though, would be a <code class="sourceCode haskell">foldr</code> on two lists. Something which folds through both at once, using a supplied combining function:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldr2 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g)
       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c)
       <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> c
foldr2 c i xs <span class="fu">=</span>
  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> i) <span class="kw">where</span>
    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
</div>
<p>Of course, once you can do two, you can do three:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldr3 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g, <span class="dt">Foldable</span> h)
       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> d)
       <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> h c <span class="ot">-&gt;</span> d
foldr3 c i xs ys <span class="fu">=</span>
  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr2 g (\_ _ <span class="ot">-&gt;</span> i) ys <span class="kw">where</span>
    g e2 e3 r2 e1 r1 <span class="fu">=</span> c e1 e2 e3 (r1 (<span class="dt">RecFold</span> r2))
    f e r x <span class="fu">=</span> runRecFold x e r</code></pre></div>
</div>
<p>And so on.</p>
<p>There’s the added benefit that the above functions work on much more than just lists.</p>
<h2 id="catamorphisms">Catamorphisms</h2>
<p>Getting a little formal about the above functions, a <code class="sourceCode haskell">fold</code> can be described as a catamorphism. This is a name for a pattern of breaking down some recursive structure. There’s a bunch of them in the <a href="https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html">recursion-schemes</a> package. The question is, then: can you express the above as a kind of catamorphism? Initially, using the same techniques as before, you can:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecF</span> f a <span class="fu">=</span> <span class="dt">RecF</span> {<span class="ot"> unRecF ::</span> <span class="dt">Base</span> f (<span class="dt">RecF</span> f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a }

<span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)
     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">RecF</span> g c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">RecF</span> g c <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c)
     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c
zipo alg xs ys <span class="fu">=</span> cata (flip unRecF) ys (cata (<span class="dt">RecF</span> <span class="fu">.</span> alg) xs)</code></pre></div>
</div>
<p>Then, coming full circle, you get a quite nice encoding of <code class="sourceCode haskell">zip</code>:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> zipo alg <span class="kw">where</span>
  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []
  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []
  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x, y) <span class="fu">:</span> ys xs</code></pre></div>
</div>
<p>However, the <code class="sourceCode haskell"><span class="dt">RecF</span></code> is a little ugly. In fact, it’s possible to write the above without any recursive types, using the RankNTypes extension. (It’s possible that you could do the same with <code class="sourceCode haskell">foldr2</code> as well, but I haven’t figured it out yet)</p>
<p>You can actually use a <code class="sourceCode haskell"><span class="kw">newtype</span></code> that’s provided by the recursion-schemes library as-is. It’s <code class="sourceCode haskell"><span class="dt">Mu</span></code>. This is required for an encoding of the Y-combinator. It’s usually presented in this form:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Mu</span> a <span class="fu">=</span> <span class="dt">Roll</span> {<span class="ot"> unroll ::</span> <span class="dt">Mu</span> a <span class="ot">-&gt;</span> a }</code></pre></div>
</div>
<p>However, in the recursion-schemes package, its definition looks like this:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> (forall a<span class="fu">.</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a)</code></pre></div>
</div>
<p>No recursion! The <code class="sourceCode haskell">zipo</code> combinator above can be written using <code class="sourceCode haskell"><span class="dt">Mu</span></code> like so:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)
     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">Mu</span> (<span class="dt">Base</span> g) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">Mu</span> (<span class="dt">Base</span> g)) <span class="ot">-&gt;</span> c)
     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c
zipo alg xs <span class="fu">=</span> cata (\x <span class="ot">-&gt;</span> alg x <span class="fu">.</span> project) xs <span class="fu">.</span> refix</code></pre></div>
</div>
<p>And the new version of <code class="sourceCode haskell">zip</code> has a slightly more natural order of arguments:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
zip <span class="fu">=</span> zipo alg <span class="kw">where</span>
  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []
  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []
  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</code></pre></div>
</div>
<h2 id="zipping-into">Zipping Into</h2>
<p>There’s one more issue, though, that’s slightly tangential. A lot of the time, the attraction of rewriting functions using folds and catamorphisms is that the function becomes more general: it no longer is restricted to lists. For <code class="sourceCode haskell">zip</code>, however, there’s still a pesky list left in the signature:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip<span class="ot"> ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> [(a,b)]</code></pre></div>
</div>
<p>It would be a little nicer to be able to zip through something <em>preserving</em> the structure of one of the things being zipped through. For no reason in particular, let’s assume we’ll preserve the structure of the first argument. The function will have to account for the second argument running out before the first, though. A <code class="sourceCode haskell"><span class="dt">Maybe</span></code> can account for that:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) 
        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) 
        <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f c</code></pre></div>
</div>
<p>If the second argument runs out, <code class="sourceCode haskell"><span class="dt">Nothing</span></code> will be passed to the combining function.</p>
<p>It’s clear that this isn’t a <em>fold</em> over the first argument, it’s a <em>traversal</em>. A first go at the function uses the state monad, but restricts the second argument to a list:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c
zipInto c xs ys <span class="fu">=</span> evalState (traverse f xs) ys <span class="kw">where</span>
  f x <span class="fu">=</span> <span class="kw">do</span>
    h <span class="ot">&lt;-</span> gets uncons
    <span class="kw">case</span> h <span class="kw">of</span> 
      <span class="dt">Just</span> (y,t) <span class="ot">-&gt;</span> <span class="kw">do</span> 
        put t
        pure (c x (<span class="dt">Just</span> y))
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> pure (c x <span class="dt">Nothing</span>)</code></pre></div>
</div>
<p>That code can be cleaned up a little:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c 
zipInto c <span class="fu">=</span> evalState <span class="fu">.</span> traverse (state <span class="fu">.</span> f <span class="fu">.</span> c) <span class="kw">where</span>
  f x [] <span class="fu">=</span> (x <span class="dt">Nothing</span>, [])
  f x (y<span class="fu">:</span>ys) <span class="fu">=</span> (x (<span class="dt">Just</span> y), ys)</code></pre></div>
</div>
<p>But really, the uncons needs to go. Another <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper is needed, and here’s the end result:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RecAccu</span> a b <span class="fu">=</span>
  <span class="dt">RecAccu</span> {<span class="ot"> runRecAccu ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecAccu</span> a b, b) }
  
<span class="ot">zipInto ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Foldable</span> f)
        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> t c
zipInto f xs <span class="fu">=</span>
  snd <span class="fu">.</span> flip (mapAccumL runRecAccu) xs <span class="fu">.</span> <span class="dt">RecAccu</span> <span class="fu">.</span> foldr h i <span class="kw">where</span>
    i e <span class="fu">=</span> (<span class="dt">RecAccu</span> i, f e <span class="dt">Nothing</span>)
    h e2 a e1 <span class="fu">=</span> (<span class="dt">RecAccu</span> a, f e1 (<span class="dt">Just</span> e2))</code></pre></div>
</div>
</div>
<div id="footer">
Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
]]></description>
    <pubDate>Sun, 17 Apr 2016 00:00:00 UT</pubDate>
    <guid>http://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</guid>
    <dc:creator>Donnacha Oisin Kidney</dc:creator>
</item>

    </channel>
</rss>
