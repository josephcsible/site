<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Donnacha Oisín Kidney's Blog</title>
        <link>https://doisinkidney.com</link>
        <description><![CDATA[Mainly writing about programming]]></description>
        <atom:link href="https://doisinkidney.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 14 Dec 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>Prime Sieves in Agda</title>
    <link>https://doisinkidney.com/posts/2018-12-14-primes-in-agda.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 14, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Prime%20Sieves.html">2-part series on Prime Sieves</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>Prime numbers in Agda are <em>slow</em>. First, they’re Peano-based, so a huge chunk of optimizations we might make in other languages are out of the window. Second, we really often want to <em>prove</em> that they’re prime, so the generation code has to carry verification logic with it (I won’t do that today, though). And third, as always in Agda, you have to convince the compiler of termination. With all of that in mind, let’s try and write a (very slow, very basic) prime sieve in Agda.</p>
<p>First, we can make an “array” of numbers that we cross off as we go.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">  primes <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>List<span class="ot">.</span>tabulate <span class="ot">(</span>just ∘ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    sieve <span class="ot">:</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    sieve <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span>         sieve xs</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    sieve <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> suc x ∷ sieve <span class="ot">(</span>foldr remove <span class="ot">(</span>const []<span class="ot">)</span> xs x<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">      B <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Fin i <span class="ot">→</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">      remove <span class="ot">:</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">→</span> B <span class="ot">→</span> B</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">      remove <span class="ot">_</span> ys zero    <span class="ot">=</span> nothing ∷ ys x</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">      remove y ys <span class="ot">(</span>suc z<span class="ot">)</span> <span class="ot">=</span> y ∷ ys z</a></code></pre></div>
<p>Very simple so far: we run through the list, filtering out the multiples of each prime as we see it. Unfortunately, this won’t pass the termination checker. This recursive call to <code>sieve</code> is the problem:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1">sieve <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> suc x ∷ sieve <span class="ot">(</span>foldr remove <span class="ot">(</span>const []<span class="ot">)</span> xs x<span class="ot">)</span></a></code></pre></div>
<p>Agda can’t see that the argument is strictly smaller. We <em>could</em> write some complicated logic proving that <code>remove</code> maintains the size of the list, or we could just use vectors instead:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>Vec<span class="ot">.</span>tabulate <span class="ot">(</span>just ∘ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  sieve <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  sieve <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span>         sieve xs</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">  sieve <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> suc x ∷ sieve <span class="ot">(</span>Vec<span class="ot">.</span>foldr B remove <span class="ot">(</span>const []<span class="ot">)</span> xs x<span class="ot">)</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    B <span class="ot">=</span> <span class="ot">λ</span> n <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Fin i <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    remove <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">→</span> B n <span class="ot">→</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    remove <span class="ot">_</span> ys zero    <span class="ot">=</span> nothing ∷ ys x</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    remove y ys <span class="ot">(</span>suc z<span class="ot">)</span> <span class="ot">=</span> y       ∷ ys z</a></code></pre></div>
<h1 id="adding-the-squaring-optimization">Adding the Squaring Optimization</h1>
<p>A simple improvement we should be able to make is stopping once we hit the square root of the limit. Since we don’t want to be squaring as we go, we’ll use the following identity:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(n + 1)^2 = n^2 + 2n + 1</annotation></semantics></math></p>
<p>to figure out the square of the next number from the previous. In fact, we’ll just pass in the limit, and reduce it by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n + 1</annotation></semantics></math> each time, until it reaches zero:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="dv">1</span> m <span class="ot">(</span>Vec<span class="ot">.</span>tabulate <span class="ot">(</span>just ∘ Fin<span class="ot">.</span>suc ∘ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  sieve <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  sieve <span class="ot">_</span> zero <span class="ot">=</span> List<span class="ot">.</span>mapMaybe id ∘ Vec<span class="ot">.</span>toList</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  sieve <span class="ot">_</span> <span class="ot">(</span>suc <span class="ot">_)</span> [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  sieve i <span class="ot">(</span>suc l<span class="ot">)</span> <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span>     sieve <span class="ot">(</span>suc i<span class="ot">)</span> <span class="ot">(</span>l ∸ i ∸ i<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  sieve i <span class="ot">(</span>suc l<span class="ot">)</span> <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> x ∷ sieve <span class="ot">(</span>suc i<span class="ot">)</span> <span class="ot">(</span>l ∸ i ∸ i<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">                                       <span class="ot">(</span>Vec<span class="ot">.</span>foldr B remove <span class="ot">(</span>const []<span class="ot">)</span> xs i<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">    B <span class="ot">=</span> <span class="ot">λ</span> n <span class="ot">→</span> ℕ <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb4-15" data-line-number="15"></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    remove <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span> <span class="ot">→</span> B i <span class="ot">→</span> B <span class="ot">(</span>suc i<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">    remove <span class="ot">_</span> ys zero    <span class="ot">=</span> nothing ∷ ys i</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    remove y ys <span class="ot">(</span>suc j<span class="ot">)</span> <span class="ot">=</span> y       ∷ ys j</a></code></pre></div>
<h1 id="finding-prime-factors">Finding Prime Factors</h1>
<p>A slight variation on the code above (the first version) will give us the prime factors of a number:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">primeFactors <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">primeFactors zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">primeFactors <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>Vec<span class="ot">.</span>tabulate <span class="ot">(</span>just ∘ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  sieve <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  sieve <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span> sieve xs</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  sieve <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> Vec<span class="ot">.</span>foldr B remove b xs sieve x</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    B <span class="ot">=</span> <span class="ot">λ</span> n <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">            <span class="ot">→</span> <span class="ot">(</span>Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">            <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">            <span class="ot">→</span> Fin i</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">            <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17"></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    b <span class="ot">:</span> B <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">    b k zero    <span class="ot">=</span> suc x ∷ k []</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    b k <span class="ot">(</span>suc <span class="ot">_)</span> <span class="ot">=</span>         k []</a>
<a class="sourceLine" id="cb5-21" data-line-number="21"></a>
<a class="sourceLine" id="cb5-22" data-line-number="22">    remove <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">→</span> B n <span class="ot">→</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb5-23" data-line-number="23">    remove y ys k zero    <span class="ot">=</span> ys <span class="ot">(</span>k ∘ <span class="ot">(</span>nothing ∷<span class="ot">_))</span> x</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">    remove y ys k <span class="ot">(</span>suc j<span class="ot">)</span> <span class="ot">=</span> ys <span class="ot">(</span>k ∘ <span class="ot">(</span>y ∷<span class="ot">_))</span> j</a></code></pre></div>
<p>Adding the squaring optimization complicates things significantly:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">primeFactors <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">primeFactors zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">primeFactors <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sqr <span class="ot">(</span>suc m<span class="ot">)</span> m suc sieve</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="ot">_</span>2F-<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ℕ <span class="ot">→</span> Fin n <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  x           2F- zero <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  zero        2F- suc y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  suc zero    2F- suc y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  suc <span class="ot">(</span>suc x<span class="ot">)</span> 2F- suc y <span class="ot">=</span> x 2F- y</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  sqr <span class="ot">:</span> <span class="ot">∀</span> n</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">      <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">      <span class="ot">→</span> <span class="ot">(</span>Fin n <span class="ot">→</span> Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">      <span class="ot">→</span> <span class="ot">(∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> i <span class="ot">→</span> ℕ <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  sqr n       zero    f k <span class="ot">=</span> k [] n</a>
<a class="sourceLine" id="cb6-19" data-line-number="19">  sqr zero    <span class="ot">(</span>suc l<span class="ot">)</span> f k <span class="ot">=</span> k [] zero</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">  sqr <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc l<span class="ot">)</span> f k <span class="ot">=</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">    <span class="kw">let</span> x <span class="ot">=</span> f zero</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">    <span class="kw">in</span> sqr n <span class="ot">(</span>l 2F- x<span class="ot">)</span> <span class="ot">(</span>f ∘ suc<span class="ot">)</span> <span class="ot">(</span>k ∘ <span class="ot">(</span>just x ∷<span class="ot">_))</span></a>
<a class="sourceLine" id="cb6-23" data-line-number="23"></a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  sieve <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> ℕ <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-25" data-line-number="25">  sieve xs′ i <span class="ot">=</span> go xs′</a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-27" data-line-number="27">    go <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-28" data-line-number="28">    go [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">    go <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span> go xs</a>
<a class="sourceLine" id="cb6-30" data-line-number="30">    go <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> Vec<span class="ot">.</span>foldr B remove <span class="ot">(</span>b i<span class="ot">)</span> xs x go</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-32" data-line-number="32">      B <span class="ot">=</span> <span class="ot">λ</span> n <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-33" data-line-number="33">              <span class="ot">→</span> Fin i</a>
<a class="sourceLine" id="cb6-34" data-line-number="34">              <span class="ot">→</span> <span class="ot">(</span>Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb6-35" data-line-number="35">              <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-36" data-line-number="36"></a>
<a class="sourceLine" id="cb6-37" data-line-number="37">      b <span class="ot">:</span> ℕ <span class="ot">→</span> B <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-38" data-line-number="38">      b zero    zero    k <span class="ot">=</span> suc x ∷ k []</a>
<a class="sourceLine" id="cb6-39" data-line-number="39">      b zero    <span class="ot">(</span>suc y<span class="ot">)</span> k <span class="ot">=</span> k []</a>
<a class="sourceLine" id="cb6-40" data-line-number="40">      b <span class="ot">(</span>suc n<span class="ot">)</span> zero    k <span class="ot">=</span> b n x k</a>
<a class="sourceLine" id="cb6-41" data-line-number="41">      b <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc y<span class="ot">)</span> k <span class="ot">=</span> b n y k</a>
<a class="sourceLine" id="cb6-42" data-line-number="42"></a>
<a class="sourceLine" id="cb6-43" data-line-number="43">      remove <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">→</span> B n <span class="ot">→</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-44" data-line-number="44">      remove y ys zero    k <span class="ot">=</span> ys x <span class="ot">(</span>k ∘ <span class="ot">(</span>nothing ∷<span class="ot">_))</span></a>
<a class="sourceLine" id="cb6-45" data-line-number="45">      remove y ys <span class="ot">(</span>suc j<span class="ot">)</span> k <span class="ot">=</span> ys j <span class="ot">(</span>k ∘ <span class="ot">(</span>y ∷<span class="ot">_))</span></a></code></pre></div>
<h1 id="infinitude">Infinitude</h1>
<p>The above sieve aren’t “true” in that each <code>remove</code> is linear, so the performance is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> overall. This is the same problem we ran into with the naive infinite sieve in Haskell.</p>
<p>That raises the question: can <em>this</em> sieve be infinite? Agda supports a notion of infinite data, so it would seem like it:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">constructor</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    tail <span class="ot">:</span> Stream A</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">open</span> Stream</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">primes <span class="ot">:</span> Stream ℕ</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">primes <span class="ot">=</span> sieve <span class="dv">1</span> nats</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  nats <span class="ot">:</span> Stream ℕ</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  head nats <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">  tail nats <span class="ot">=</span> nats</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">  sieve <span class="ot">:</span> ℕ <span class="ot">→</span> Stream ℕ <span class="ot">→</span> Stream ℕ</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  head <span class="ot">(</span>sieve i xs<span class="ot">)</span> <span class="ot">=</span> suc i</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  tail <span class="ot">(</span>sieve i xs<span class="ot">)</span> <span class="ot">=</span> remove i <span class="ot">(</span>head xs<span class="ot">)</span> <span class="ot">(</span>tail xs<span class="ot">)</span> <span class="ot">(</span>sieve ∘ suc ∘ <span class="ot">(_</span>+ i<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">    remove <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> Stream ℕ <span class="ot">→</span> <span class="ot">(</span>ℕ <span class="ot">→</span> Stream ℕ <span class="ot">→</span> Stream ℕ<span class="ot">)</span> <span class="ot">→</span> Stream ℕ</a>
<a class="sourceLine" id="cb7-22" data-line-number="22">    remove zero zero zs       k <span class="ot">=</span> remove i <span class="ot">(</span>head zs<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span> <span class="ot">(</span>k ∘ suc<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">    remove zero <span class="ot">(</span>suc z<span class="ot">)</span> zs    k <span class="ot">=</span> remove i z zs <span class="ot">(</span>k ∘ suc<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    remove <span class="ot">(</span>suc y<span class="ot">)</span> zero zs    k <span class="ot">=</span> k zero <span class="ot">(</span>remove y <span class="ot">(</span>head zs<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span> <span class="ot">_</span>◂<span class="ot">_)</span></a>
<a class="sourceLine" id="cb7-25" data-line-number="25">    remove <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">(</span>suc z<span class="ot">)</span> zs k <span class="ot">=</span> remove y z zs <span class="ot">(</span>k ∘ suc<span class="ot">)</span></a></code></pre></div>
<p>But this won’t pass the termination checker. What we actually need to prove to do so is that there are infinitely many primes: <a href="https://gist.github.com/copumpkin/1286093">a nontrivial task in Agda</a>.</p>
]]></description>
    <pubDate>Fri, 14 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-14-primes-in-agda.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Keeping Formal Verification in Bounds</title>
    <link>https://doisinkidney.com/posts/2018-11-20-fast-verified-structures.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>One of the favorite pastimes of both Haskell and Agda programmers alike is verifying data structures. Among my favorite examples are Red-Black trees <span class="citation" data-cites="might_missing_2015 weirich_depending_2014">(Might <a href="#ref-might_missing_2015">2015</a>; Weirich <a href="#ref-weirich_depending_2014">2014</a>, verified for balance)</span>, perfect binary trees <span class="citation" data-cites="hinze_perfect_1999">(Hinze <a href="#ref-hinze_perfect_1999">1999</a>)</span>, square matrices <span class="citation" data-cites="okasaki_fast_1999">(Okasaki <a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, search trees <span class="citation" data-cites="mcbride_how_2014">(McBride <a href="#ref-mcbride_how_2014">2014</a>, verified for balance and order)</span>, and binomial heaps <span class="citation" data-cites="hinze_numerical_1998">(Hinze <a href="#ref-hinze_numerical_1998">1998</a>, verified for structure)</span>.</p>
<p>There are many ways to verify data structures. One technique which has had recent massive success is to convert Haskell code to Coq, and then verify the Coq translation: this was the route taken by <span class="citation" data-cites="breitner_ready_2018-1">Breitner et al. (<a href="#ref-breitner_ready_2018-1">2018</a>)</span> to verify <code>Set</code> and <code>IntSet</code> in containers (a mammoth achievement, in my opinion).</p>
<p>This approach has some obvious advantages: you separate implementation from testing (which is usually a good idea), and your verification language can be different from your implementation language, with each tailored towards its particular domain.</p>
<p>LiquidHaskell <span class="citation" data-cites="bakst_liquidhaskell_2018">(Bakst et al. <a href="#ref-bakst_liquidhaskell_2018">2018</a>)</span> (and other tools like it) adds an extra type system to Haskell tailor-made for verification. The added type system (refinement types) is more automated (the typechecker uses Z3), more suited for “invariant”-like things (it supports subtyping), and has a bunch of domain-specific built-ins (reasoning about sets, equations, etc.). I’d encourage anyone who hasn’t used it to give it a try: especially if you’re experienced writing any kind of proof in a language like Agda or Idris, LiquidHaskell proofs are <em>shockingly</em> simple and easy.</p>
<p>What I’m going to focus on today, though, is writing <em>correct-by-construction</em> data structures, using Haskell and Agda’s own type systems. In particular, I’m going to look at how to write <em>fast</em> verification. In the other two approaches, we don’t really care about the “speed” of the proofs: sure, it’s nice to speed up compilation and so on, but we don’t have to worry about our implementation suffering at runtime because of some complex proof. When writing correct-by-construction code, though, our task is doubly hard: we now have to worry about the time complexity of both the implementation <em>and the proofs</em>.</p>
<p>In this post, I’m going to demonstrate some techniques to write proofs that stay within the complexity bounds of the algorithms they’re verifying (without cheating!). Along the way I’m going to verify some data structures I haven’t seen verified before (a skew-binary random-access list).</p>
<h1 id="technique-1-start-with-an-unverified-implementation-then-index">Technique 1: Start With an Unverified Implementation, then Index</h1>
<p>To demonstrate the first two techniques, we’re going to write a type for modular arithmetic. For a more tactile metaphor, think of the flip clock:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Split-flap_display.jpg" /></p>
<p>Each digit can be incremented <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> times, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is whatever base you’re using (12 for our flip-clock above). Once you hit the limit, it flips the next digit along. We’ll start with just one digit, and then just string them together to get our full type. That in mind, our “digit” type has two requirements:</p>
<ol>
<li>It should be incrementable.</li>
<li>Once it hits its limit, it should flip back to zero, and let us know that a flip was performed.</li>
</ol>
<p>Anyone who’s used a little Agda or Idris will be familiar with the <code>Fin</code> type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> Fin <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  zero <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  suc  <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a></code></pre></div>
<p><code>Fin n</code> is the standard way to encode “numbers smaller than <code>n</code>”. However, for digits they’re entirely unsuitable: since the limit parameter changes on successor, the kind of increment we want is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1">try-suc <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Maybe <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">try-suc <span class="ot">(</span>suc x<span class="ot">)</span> <span class="ot">=</span> Maybe<span class="ot">.</span>map suc <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">try-suc <span class="ot">{</span>suc n<span class="ot">}</span> zero <span class="kw">with</span> n</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> zero <span class="ot">=</span> nothing</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">...</span> <span class="ot">|</span> suc <span class="ot">_</span> <span class="ot">=</span> just <span class="ot">(</span>suc zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Fin n × Bool</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">suc-flip <span class="ot">{</span>suc n<span class="ot">}</span> x <span class="ot">=</span> maybe <span class="ot">(_</span>, false<span class="ot">)</span> <span class="ot">(</span>zero , true<span class="ot">)</span> <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">suc-flip <span class="ot">{</span>zero<span class="ot">}</span> <span class="ot">()</span></a></code></pre></div>
<p>If we keep going down this path with proofs in mind, we might next look at the various <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\leq</annotation></semantics></math> proofs in the Agda standard library (<a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L28">here</a>, <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L117">here</a>, and <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L133">here</a>), and see if we can we can wrangle them into doing what we want.</p>
<p>For me, though, this wasn’t a fruitful approach. Instead, we’ll try and think of how we’d do this without proving anything, and then see if there’s any place in the resulting data structure we can hang some proof.</p>
<p>So, in an unproven way, let’s start with some numbers. Since we’re going to be incrementing, they’d better be unary:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  zero <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  suc <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ</a></code></pre></div>
<p>And then, for the “flippable” type, we’ll just store the limit alongside the value:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    val <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    lim <span class="ot">:</span> ℕ</a></code></pre></div>
<p>We’re not there yet: to check if we’ve gone over the limit, we’ll still have to compare <code>val</code> and <code>lim</code>. Hopefully you can guess the optimization we’ll make: instead of storing the limit, we’ll store the space left:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    space <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    val   <span class="ot">:</span> ℕ</a></code></pre></div>
<p>And we get our flip function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">suc-flip <span class="ot">:</span> Flipper <span class="ot">→</span> Flipper × Bool</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">suc-flip <span class="ot">(</span>zero  &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>suc n &amp; zero <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">suc-flip <span class="ot">(</span>suc m &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>m     &amp; suc n<span class="ot">)</span>, false</a></code></pre></div>
<p>When there’s no space left, the digit must be maximal (9 in decimal, for instance), so it’ll be one less than the base. That lets us stick it in for the base, rather than recalculating. In the other case, we just take one from the space left, and add it to the value.</p>
<p>So, to “prove” this implementation, we might first reach for an equality proof that <code>val + space</code> is equal to your base. Don’t! Both <code>val</code> and <code>space</code> are inductive structures, which could be giving us information on every application of <code>suc</code>! Let’s set our sights on <code>val</code> and see how we can hang our proofs off of it.</p>
<p>We’re going to upgrade our Peano number with some information, which means that our resulting type is going to look an awful lot like a Peano number. In other words, two cases: <code>zero</code> and <code>suc</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  suc-case  <span class="ot">:</span> Val <span class="ot">_</span> <span class="ot">→</span> Val <span class="ot">_</span></a></code></pre></div>
<p>For the <code>suc-case</code>, remember we only want to be allowed to increment it when the space left is more than zero. So let’s encode it:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">→</span> Val <span class="ot">_</span> <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">→</span> Val <span class="ot">_</span> space</a></code></pre></div>
<p>And for the <code>zero-case</code>, the space left is just the base. So let’s stick the base into the type as well:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">(</span>base <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  zero-case <span class="ot">:</span> Val base base</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">→</span> Val base <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">→</span> Val base space</a></code></pre></div>
<p>(We’ve changed around the way “base” works: it’s now one smaller. So to encode base-10 you’d have <code>Val 9 space</code>. You can get back to the other encoding with a simple wrapper, this way just makes things slightly easier from now on).</p>
<p>Finally, our flipper:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">(</span>base <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    space <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    val <span class="ot">:</span> Val base space</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Flipper n <span class="ot">→</span> Flipper n × Bool</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">suc-flip <span class="ot">(</span>zero  &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> &amp;  zero-case<span class="ot">)</span> , true</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">suc-flip <span class="ot">(</span>suc n &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n &amp; suc-case m<span class="ot">)</span> , false</a></code></pre></div>
<p>Great! Everything works.</p>
<p>You may have noticed that the <code>Val</code> type is actually a proof for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≥</mo><annotation encoding="application/x-tex">\geq</annotation></semantics></math> in disguise:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="ot">_</span>≥<span class="ot">_</span> <span class="ot">(</span>m <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  m≥m <span class="ot">:</span> m ≥ m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  m≥p <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> m ≥ suc n <span class="ot">→</span> m ≥ n</a></code></pre></div>
<p>And the flipper itself is just an existential in disguise:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">Flipper <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">Flipper n <span class="ot">=</span> ∃ <span class="ot">(</span>n ≥<span class="ot">_)</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">suc-flip <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Flipper n <span class="ot">→</span> Flipper n × Bool</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">suc-flip <span class="ot">(</span>zero  , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> , m≥m  <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">suc-flip <span class="ot">(</span>suc n , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n , m≥p m<span class="ot">)</span>, false</a></code></pre></div>
<p>Hopefully this explanation will help you understand how to get from the specification to those 8 lines. This technique is going to come in especially handy later when we base data structures off of number systems.</p>
<h1 id="technique-2-once-you-eliminate-the-impossible-whatever-remains-no-matter-how-improbable-must-be-the-truth.">Technique 2: Once you eliminate the impossible, whatever remains, no matter how improbable, must be the truth.</h1>
<p>For this next trick, we’ll add an extra operation to the flipper type above: conversion from a natural number. We want to be able to do it in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> time, and we won’t allow ourselves to change the original type definition. Here’s the type we’re aiming for:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>m≥n <span class="ot">:</span> m ≥ n<span class="ot">)</span> <span class="ot">→</span> Flipper m</a></code></pre></div>
<p>We pass in a proof that the natural number we’re converting from is indeed in range (it’s marked irrelevant so we don’t pay for it). Here’s a non-answer:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">{</span>m≥n <span class="ot">:</span> m ≥ n<span class="ot">}</span> <span class="ot">→</span> Flipper m</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">fromNat n <span class="ot">{</span>m≥n<span class="ot">}</span> <span class="ot">=</span> n , m≥n</a></code></pre></div>
<p>While this looks fine, it’s actually the <em>inverse</em> of what we want. We defined the inductive structure to be indicated by the inequality proof itself. Let’s make the desired output explicit:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">toNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n m<span class="ot">}</span> <span class="ot">→</span> n ≥ m <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">toNat m≥m <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">toNat <span class="ot">(</span>m≥p n≥m<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>toNat n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">fromNat-≡ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">          <span class="ot">→</span> <span class="ot">.(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">          <span class="ot">→</span>  Σ[ n-m ∈ Flipper n ] toNat <span class="ot">(</span>proj₂ n-m<span class="ot">)</span> ≡ m</a></code></pre></div>
<p>And finally we can try an implementation:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1">fromNat-≡ zero    <span class="ot">_</span>   <span class="ot">=</span> <span class="ot">(_</span> , m≥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">fromNat-≡ <span class="ot">(</span>suc m<span class="ot">)</span> n≥m <span class="ot">=</span> ??? <span class="ot">(</span>fromNat-≡ m <span class="ot">(</span>m≥p n≥m<span class="ot">))</span></a></code></pre></div>
<p>In the <code>???</code> there, we want some kind of successor function. The problem is that we would also need to prove that we <em>can</em> do a successor call. Except we don’t want to do that: proving that there’s space left is an expensive operation, and one we can avoid with another trick: first, we <em>assume</em> that there’s space left.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">fromNat-≡ zero    n≥m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , m≥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">fromNat-≡ <span class="ot">(</span>suc n<span class="ot">)</span> n≥m <span class="kw">with</span> fromNat-≡ n <span class="ot">(</span>m≥p n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, x≡m  <span class="ot">=</span> <span class="ot">(</span>space , m≥p n-1<span class="ot">)</span>, cong suc x≡m</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , n-1<span class="ot">)</span>, refl <span class="ot">=</span> ???</a></code></pre></div>
<p>But what about the second case? Well, we have to prove this impossible. What if it’s an extremely complex, expensive proof? It doesn’t matter! It will never be run! In contrast to proving the “happy path” correct, if we can confine all of the ugly complex cases to the unhappy paths, we can spend as long as we want proving them impossible without having to worry about runtime cost. Here’s the full function.</p>
<details>
<p><summary> <code>fromNat</code> implementation </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fromNat-≡ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">          <span class="ot">→</span> <span class="ot">.(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="ot">→</span>  Σ[ n-m ∈ Flipper n ] toNat <span class="ot">(</span>proj₂ n-m<span class="ot">)</span> ≡ m</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">fromNat-≡ zero    n≥m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , m≥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">fromNat-≡ <span class="ot">(</span>suc n<span class="ot">)</span> n≥m <span class="kw">with</span> fromNat-≡ n <span class="ot">(</span>m≥p n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, x≡m  <span class="ot">=</span> <span class="ot">(</span>space , m≥p n-1<span class="ot">)</span>, cong suc x≡m</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , n≥0<span class="ot">)</span>, refl <span class="ot">=</span> Irrel<span class="ot">.</span>⊥-elim <span class="ot">(</span>contra <span class="ot">_</span> zero n≥0 n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">  <span class="kw">import</span> Data<span class="ot">.</span>Nat<span class="ot">.</span>Properties as <span class="dt">Prop</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10"></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  n≱sk+n <span class="ot">:</span> <span class="ot">∀</span> n k <span class="ot">{</span>sk+n<span class="ot">}</span> <span class="ot">→</span> sk+n ≡ suc k ℕ<span class="ot">.</span>+ n <span class="ot">→</span> n ≥ sk+n <span class="ot">→</span> ⊥</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">  n≱sk+n n k wit <span class="ot">(</span>m≥p n≥sk+n<span class="ot">)</span> <span class="ot">=</span> n≱sk+n n <span class="ot">(</span>suc k<span class="ot">)</span> <span class="ot">(</span>cong suc wit<span class="ot">)</span> n≥sk+n</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  n≱sk+n n k wit m≥m <span class="kw">with</span> <span class="dt">Prop</span><span class="ot">.</span>+-cancelʳ-≡ <span class="dv">0</span> <span class="ot">(</span>suc k<span class="ot">)</span> wit</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  <span class="ot">...</span> <span class="ot">|</span> <span class="ot">()</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15"></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  contra <span class="ot">:</span> <span class="ot">∀</span> n m <span class="ot">→</span> <span class="ot">(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span> <span class="ot">→</span> n ≥ suc <span class="ot">(</span>m ℕ<span class="ot">.</span>+ toNat n≥m<span class="ot">)</span> <span class="ot">→</span> ⊥</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  contra n m m≥m n≥st <span class="ot">=</span> n≱sk+n n zero <span class="ot">(</span>cong suc <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-identityʳ n<span class="ot">))</span> n≥st</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">  contra n m <span class="ot">(</span>m≥p n≥m<span class="ot">)</span> n≥st <span class="ot">=</span></a>
<a class="sourceLine" id="cb18-19" data-line-number="19">    contra</a>
<a class="sourceLine" id="cb18-20" data-line-number="20">      n</a>
<a class="sourceLine" id="cb18-21" data-line-number="21">      <span class="ot">(</span>suc m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-22" data-line-number="22">      n≥m</a>
<a class="sourceLine" id="cb18-23" data-line-number="23">      <span class="ot">(</span>subst <span class="ot">(λ</span> x <span class="ot">→</span> n ≥ suc x<span class="ot">)</span> <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-suc m <span class="ot">(</span>toNat n≥m<span class="ot">))</span> n≥st<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-24" data-line-number="24"></a>
<a class="sourceLine" id="cb18-25" data-line-number="25">fromNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> m <span class="ot">→</span> <span class="ot">.(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span> <span class="ot">→</span> Flipper n</a>
<a class="sourceLine" id="cb18-26" data-line-number="26">fromNat m n≥m <span class="ot">=</span> proj₁ <span class="ot">(</span>fromNat-≡ m n≥m<span class="ot">)</span></a></code></pre></div>
</details>
<h1 id="technique-3-make-indices-correct-by-construction">Technique 3: Make Indices Correct-By-Construction</h1>
<p>We’re going to switch into Haskell now, and in particular to functional arrays. These are data structures which aren’t real arrays, but they offer you the kind of interface you’d want from an array in a functional setting. You can’t get better than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> indexing, unfortunately <span class="citation" data-cites="ben-amram_pointers_1992">(Ben-Amram and Galil <a href="#ref-ben-amram_pointers_1992">1992</a>)</span>, but often it’s enough.</p>
<p>The first “functional array” we’re going to be looking at nested binary random-access lists. It has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> indexing, as you might expect, and amortized single-threaded <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>.</p>
<p>It starts out like a binary random-access list (“random-access list” is another name for “functional array”). You can find a full explanation of the structure in your nearest copy of Purely Functional Data Structures <span class="citation" data-cites="okasaki_purely_1999">(Okasaki <a href="#ref-okasaki_purely_1999">1999</a><a href="#ref-okasaki_purely_1999">b</a>)</span>, but briefly: the structure mimics a binary number, in that it’s a list of “bits”. At each set bit, it stores a tree with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>i</mi></msup><annotation encoding="application/x-tex">2^i</annotation></semantics></math> elements, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> is the position in the list. In this way, every binary number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> has an analogous list of “bits” which contains, in total, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements.</p>
<p>The “nested” part refers to how we’re going to implement the trees. It works a little like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> (a,a))</a></code></pre></div>
<p>You might have to squint at that definition for a second to understand it: instead of storing two trees at the <code>Node</code> constructor (which is what you’d usually do), we store a tree with double the elements. This has two advantages: all of the children have the same number of elements (this tree, for instance, is always some power of 2), and it also cuts down on memory use.</p>
<p>For the binary random-access list, we’ll use the nested encoding of trees to encode the contents of each bit. There’s an implementation of this very thing on Hackage <span class="citation" data-cites="komuves_nested-sequence_2016">(Komuves and Divianszky <a href="#ref-komuves_nested-sequence_2016">2016</a>)</span>, and Okasaki himself wrote something very similar to it <span class="citation" data-cites="okasaki_fast_1999">(<a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, but we’re going to go a little further than both of those by indexing the type by its size. Here it is:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="dt">Nil</span><span class="ot">  ::</span>                      <span class="dt">Seq</span> <span class="ch">&#39;[]      a</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">O</span> <span class="fu">:</span> xs) a</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">I</span> <span class="fu">:</span> xs) a</a></code></pre></div>
<p>The operations we’re interested will be <code>cons</code> and <code>uncons</code>: for the indices, they correspond to incrementing and decrementing the numbers, respectively. As such, we’ll need type-level functions for those:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">I</span>]</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> <span class="dt">Inc</span> xs</a></code></pre></div>
<p>And now the <code>cons</code> function:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">cons x <span class="dt">Nil</span>        <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">cons x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Odd</span> x xs</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">cons x (<span class="dt">Odd</span> y ys) <span class="fu">=</span> <span class="dt">Even</span> (cons (x,y) ys)</a></code></pre></div>
<p>However, we’re going to run into trouble if we try to write <code>uncons</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="dt">Dec</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> <span class="dt">Dec</span> xs</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="dt">Dec</span> <span class="ch">&#39;[] = ???</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> ns) a)</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">uncons (<span class="dt">Odd</span> x xs) <span class="fu">=</span> (x, <span class="dt">Even</span> xs)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">uncons (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="kw">case</span> uncons xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Odd</span> y ys)</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<p>We <em>should</em> be able to write this function without returning a <code>Maybe</code>. Because we statically know the size, we can encode “only nonempty sequences”. The problem is that <code>Seq [] a</code> isn’t the only non-empty sequence: there’s also <code>Seq [O] a</code> and <code>Seq [O,O] a</code>, and so on. Our binary number system is redundant, because it contains trailing zeroes.</p>
<p>We could add some kind of proof into the data structure, but that would (again) be expensive. Instead, we can make the index <em>itself</em> correct-by-construction, by choosing a non-redundant representation of binary numbers.</p>
<p>Here’s the trick: instead of having a list of bits, we’re going to have a list of “the distance to the next one”. This eliminates the redundancy, and translates into our data structure like so:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Nest</span> n ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Seq</span>    ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> <span class="dt">Z</span>     ns a</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      (<span class="dt">Nest</span> n ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">S</span> n) ns a</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a</a></code></pre></div>
<p>Lovely! Crucially for our <code>uncons</code>, we now know that any non-empty list of bits is a non-zero list of bits, so we can type “nonempty sequence” easily:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">r ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> r <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">S</span> n) ns       <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="dt">Dec</span> n ns</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">&#39;[]      = &#39;</span>[]</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    <span class="dt">Dec</span> <span class="dt">Z</span>     (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">uncons (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go xs&#39;</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="ot">    go ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    go (<span class="dt">Odd</span> x <span class="dt">Nil</span>) <span class="fu">=</span> (x, <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    go (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)) <span class="fu">=</span> (x, <span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> <span class="kw">case</span> go xs <span class="kw">of</span> ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Cons</span> (<span class="dt">Odd</span> y ys))</a></code></pre></div>
<p>We’re still not done, though: here’s our new type family for incrementing things.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">    <span class="dt">Carry</span> <span class="ch">&#39;[] = &#39;</span>[]</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">    <span class="dt">Carry</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a></code></pre></div>
<p>The <code>Carry</code> there is ugly, and that ugliness carries into the <code>cons</code> function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">cons x&#39; (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go x&#39; xs&#39;</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> (n<span class="fu">:</span>ns)) a</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    go x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs))</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">    go x (<span class="dt">Odd</span> y <span class="dt">Nil</span>) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (x,y) <span class="dt">Nil</span>))</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">    go x (<span class="dt">Odd</span> y (<span class="dt">Cons</span> ys)) <span class="fu">=</span> carry (go (x,y) ys)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">    carry ::</span> <span class="dt">Seq</span> ns (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Carry</span> ns) a</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">    carry <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    carry (<span class="dt">Cons</span> xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> xs)</a></code></pre></div>
<p>To clean it up, we’re going to use another technique.</p>
<h1 id="technique-4-provide-information-on-indices-as-early-as-possible">Technique 4: Provide Information on Indices as Early as Possible</h1>
<p>You occasionally see people wonder about the usual definition of addition on Peano numbers:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">suc n + m <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>It’s very simple, with only two equations. When someone sees the following error, then:</p>
<blockquote>
<p><code>couldn't match type n with n + 0</code></p>
</blockquote>
<p>They might be tempted to add it as an equation to the function:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">zero  + m    <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">n     + zero <span class="ot">=</span> n</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">suc n + m    <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>Similarly, when someone sees the other error commonly found with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>:</p>
<blockquote>
<p><code>couldn't match type S n + m with n + S m</code></p>
</blockquote>
<p>They’ll add that equation in too! In fact, that particular equation will provide a valid definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">suc n + m <span class="ot">=</span> n + suc m</a></code></pre></div>
<p>So why is the first definition of + the one almost always used? Because it <em>maximizes output information from minimal input</em>. Take the second implementation above, the one with the zero on the right. In this function, we have to look at the second argument in the second clause: in other words, we don’t get to find out about the output until we’ve looked at both <code>n</code> and <code>m</code>. In the usual definition, if you know the first argument is <code>suc</code> something, you also know the <em>output</em> must be <code>suc</code> something.</p>
<p>Similarly with the third implementation: we have to examine the first argument in its <em>entirety</em> before we wrap the output in a constructor. Yes, we can of course prove that they’re all equivalent, but remember: proofs are expensive, and we’re looking for speed here. So the first definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math> is our best bet, since it tells us the most without having to prove anything.</p>
<p>Looking back at our definition of <code>Inc</code>, we can actually provide more information a little sooner:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a></code></pre></div>
<p>In all of the outputs, the list is non-empty. We can encode that, by having two different functions for the head and tail of the list:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">IncHead</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="dt">IncHead</span> <span class="ch">&#39;[] = Z</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="dt">IncHead</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncHead&#39;</span> n ns</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">type</span> family <span class="dt">IncHead&#39;</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    <span class="dt">IncHead&#39;</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    <span class="dt">IncHead&#39;</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">IncHead</span> ns)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="kw">type</span> family <span class="dt">IncTail</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">    <span class="dt">IncTail</span> <span class="ch">&#39;[] = &#39;</span>[]</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">    <span class="dt">IncTail</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncTail&#39;</span> n ns</a>
<a class="sourceLine" id="cb32-12" data-line-number="12"></a>
<a class="sourceLine" id="cb32-13" data-line-number="13"><span class="kw">type</span> family <span class="dt">IncTail&#39;</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    <span class="dt">IncTail&#39;</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb32-15" data-line-number="15">    <span class="dt">IncTail&#39;</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">IncTail</span> ns</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17"><span class="kw">type</span> <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> <span class="dt">IncHead</span> ns <span class="fu">:</span> <span class="dt">IncTail</span> ns</a></code></pre></div>
<p>This tells the typechecker that we’re not returning an empty sequence right away, so we don’t have to pattern-match to prove it later, giving us a more efficient function.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">cons x&#39; xs&#39; <span class="fu">=</span> <span class="dt">Cons</span> (go x&#39; xs&#39;)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">IncHead</span> ns) (<span class="dt">IncTail</span> ns) a</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">    go x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">    go x (<span class="dt">Cons</span> (<span class="dt">Even</span>  xs)) <span class="fu">=</span> <span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">    go x (<span class="dt">Cons</span> (<span class="dt">Odd</span> y ys)) <span class="fu">=</span> <span class="dt">Even</span> (go (x,y) ys)</a></code></pre></div>
<h1 id="technique-5-lazy-proofs">Technique 5: Lazy Proofs</h1>
<p>Briefly after introducing the binary random-access list, Okasaki describes the <em>skew-binary</em> random-access list. As well as having the same indexing cost as the type above, it supports <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>. But wait—didn’t the previous structure have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>? Not really. Unfortunately, in a pure functional setting, imperative-style amortization measurements aren’t always valid. Say we perform a <code>cons</code> in the worst case, and it takes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> time. In an imperative setting, that’s no problem, because all of the rest of the operations are not going to be on the worst-case. In a pure setting, though, the old structure is still sitting around. You can still access it, and you can still get that awful worst-case time.</p>
<p>This is where the skew binary tree comes in. It’s based on the <a href="https://en.wikipedia.org/wiki/Skew_binary_number_system">skew binary numbers</a>: these work similarly to binary, but you’re allowed have (at most) a single 2 digit before any ones. This gives you <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> incrementing and decrementing, which is what we need here. Let’s get started.</p>
<p>First, our type-level numbers. We’re going to use the sparse encoding as above, but we need some way to encode “you’re only allowed one 2”. The most lightweight way to do it I can think of is by implicitly assuming the second number in the list of gaps is one less than the others. In other words, we encode a 2 with <code>[n, 0, m]</code>. That <code>0</code> means that at position <code>n</code> there’s a 2, not a 1.</p>
<p>The corresponding type families for increment and decrement are clearly <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[]              = Z   : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="ch">&#39;[])       = Z   : x  : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="dt">Z</span>    <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="dt">Inc</span> (x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">Z</span>   <span class="fu">:</span> x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-6" data-line-number="6"></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">    <span class="dt">Dec</span> (<span class="dt">S</span> x)  xs            <span class="fu">=</span> x  <span class="fu">:</span> <span class="dt">Z</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">&#39;[]            = &#39;</span>[]</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x  <span class="fu">:</span> <span class="ch">&#39;[])     = x  : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs</a></code></pre></div>
<p>We don’t need to split this into head and tail families as we did before because there’s no recursive call: we know all we’re ever going to know about the output following <em>any</em> match on the input.</p>
<p>There’s another problem before we write the implementation: we can’t use the <code>Nest</code> construction that we had before, because then the head would be buried in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> constructors (or thereabouts). Instead, we’re going to have to use GADTs to encode the “gap” type, alongside the relevant tree. This gap type is going to be very similar to the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≥</mo><annotation encoding="application/x-tex">\geq</annotation></semantics></math> proof we had for the modular counters, but with an extra parameter:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Gap</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">g ::</span> <span class="dt">N</span>) (<span class="ot">m ::</span> <span class="dt">N</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n <span class="dt">Z</span> n</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> n (<span class="dt">S</span> g) (<span class="dt">S</span> m)</a></code></pre></div>
<p><code>Gap n g m</code> means there is a gap of <code>g</code> between <code>n</code> and <code>m</code>. Or, stated another way, it means <code>n + g = m</code>. Its inductive structure mimics the <code>g</code> parameter (it’s basically the <code>g</code> parameter itself with some added information).</p>
<p>With all of that together, here’s the definition of the array itself:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Tree</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">    <span class="dt">Tree</span> <span class="dt">Z</span> a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    <span class="dt">Tree</span> (<span class="dt">S</span> n) a <span class="fu">=</span> <span class="dt">Node</span> n a</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"></a>
<a class="sourceLine" id="cb36-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Node</span> n a <span class="fu">=</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> n a) (<span class="dt">Tree</span> n a)</a>
<a class="sourceLine" id="cb36-6" data-line-number="6"></a>
<a class="sourceLine" id="cb36-7" data-line-number="7"><span class="kw">data</span> <span class="dt">SeqTail</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    <span class="dt">NilT</span><span class="ot">  ::</span> <span class="dt">SeqTail</span> n <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb36-9" data-line-number="9">    <span class="dt">ConsT</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">          <span class="ot">-&gt;</span> <span class="dt">Tree</span> m a</a>
<a class="sourceLine" id="cb36-11" data-line-number="11">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> (<span class="dt">S</span> m) ms a</a>
<a class="sourceLine" id="cb36-12" data-line-number="12">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n (g <span class="fu">:</span> ms) a</a>
<a class="sourceLine" id="cb36-13" data-line-number="13"></a>
<a class="sourceLine" id="cb36-14" data-line-number="14"><span class="kw">data</span> <span class="dt">Seq</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-15" data-line-number="15">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb36-16" data-line-number="16">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Gap</span> <span class="dt">Z</span> g n</a>
<a class="sourceLine" id="cb36-17" data-line-number="17">         <span class="ot">-&gt;</span> <span class="dt">Tree</span> n a</a>
<a class="sourceLine" id="cb36-18" data-line-number="18">         <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n ns a</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">         <span class="ot">-&gt;</span> <span class="dt">Seq</span> (g <span class="fu">:</span> ns) a</a></code></pre></div>
<p>The <code>cons</code> operation again mimics the increment function, but there’s one final snag before it’ll typecheck:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span>(<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> <span class="fu">???</span> y2 ys))</a></code></pre></div>
<p>On the final line, the <code>???</code> is missing. In the unverified version, <code>nm</code> would slot right in there. Here, though, if we try it we get an error, which basically amounts to:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="dt">Gap</span> n g m <span class="fu">/=</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a></code></pre></div>
<p>At this point, I’d usually throw out the inductive-style proof, and replace it with a proof of equality, which I’d aggressively erase in all of the functions. I said at the beginning I wouldn’t cheat, though, so here’s what I’ll do instead:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">gapr ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a>
<a class="sourceLine" id="cb39-2" data-line-number="2">gapr <span class="dt">Zy</span>       <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">gapr (<span class="dt">Sy</span> pnm) <span class="fu">=</span> <span class="dt">Sy</span> (gapr pnm)</a>
<a class="sourceLine" id="cb39-4" data-line-number="4"></a>
<a class="sourceLine" id="cb39-5" data-line-number="5"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb39-7" data-line-number="7">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> (gapr nm) y2 ys))</a></code></pre></div>
<p>At first glance, we’ve lost the complexity bounds. That <code>gapr</code> operation is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> (or something), and we’re performing it pretty frequently. We might keep the amortized bounds, but isn’t that not really worthy in a pure setting?</p>
<p>That would all be true, if it weren’t for laziness. Because we <em>delay</em> the evaluation of <code>gapr</code>, we won’t have to pay for it all in one big thunk. In fact, because it’s basically a unary number, we only have to pay for one part of it at a time. I haven’t yet fully worked out the proofs, but I’m pretty sure we’re guaranteed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> worst-case time here too.</p>
<h1 id="technique-6-when-all-else-fails-prove-it-later">Technique 6: When All Else Fails, Prove it Later</h1>
<p>About a year ago, I <a href="/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html">tried</a> to write a verified version of binomial heaps, which could then be used for sorting traversable containers. Unfortunately, I couldn’t figure out how to write delete-min, and gave up. I <em>did</em> recognize that the redundancy of the binary representation was a problem, but I couldn’t figure out much more than that.</p>
<p>Now, though, we have a new non-redundant representation of binary numbers, and some handy techniques to go along with it.</p>
<p>Unfortunately, I ran into a similar roadblock in the implementation. Here’s the point where I was stuck:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"></a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb40-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb40-5" data-line-number="5"></a>
<a class="sourceLine" id="cb40-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> unZipper (go xs&#39;)</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb40-10" data-line-number="10"></a>
<a class="sourceLine" id="cb40-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb40-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb40-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb40-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t&#39; <span class="fu">:&lt;</span> _) hs)</a>
<a class="sourceLine" id="cb40-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb40-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb40-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb40-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb40-22" data-line-number="22">                           <span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;)))</a></code></pre></div>
<p>The last two lines don’t typecheck! The errors were complex, but effectively they stated:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> [<span class="dt">Z</span>]</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> []</code></p>
</blockquote>
</blockquote>
<p>and:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> y <span class="fu">:</span> ys</code></p>
</blockquote>
</blockquote>
<p>The thing is, all of those look pretty provable. So, for this technique, we first figure out what proofs we need, and <em>assume</em> we have them. This means changing <code>minView</code> to the following:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb41-5" data-line-number="5"></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> unZipper (go xs&#39;)</a>
<a class="sourceLine" id="cb41-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb41-10" data-line-number="10"></a>
<a class="sourceLine" id="cb41-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb41-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb41-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t&#39; <span class="fu">:&lt;</span> _) (<span class="ot">hs ::</span> <span class="dt">Binomial</span> (<span class="dt">S</span> n) (<span class="dt">Decr</span> y ys) a))</a>
<a class="sourceLine" id="cb41-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb41-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb41-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb41-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-22" data-line-number="22">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb41-23" data-line-number="23">                           <span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-24" data-line-number="24">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;)))</a></code></pre></div>
<p>And writing in the templates for our lemmas:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">&#39;[] -&gt; x : xs :~: Z : &#39;</span>[]</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">lemma1 <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb42-3" data-line-number="3"></a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="ot">lemma2 ::</span> forall x xs y ys<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">lemma2 <span class="fu">=</span> _</a></code></pre></div>
<p>We now need to provide the <em>implementations</em> for <code>lemma1</code> and <code>lemma2</code>. With this approach, even if we fail to do the next steps, we can cop out here and sub in <code>unsafeCoerce Refl</code> in place of the two proofs, maintaining the efficiency. We won’t need to, though!</p>
<p>Unlike in Agda, the types for those proofs won’t be around at runtime, so we won’t have anything to pattern match on. We’ll need to look for things in the surrounding area which could act like singletons for the lemmas.</p>
<p>It turns out that the <code>xs</code> and <code>hs'</code> floating around can do exactly that: they tell us about the type-level <code>y</code> and <code>x</code>. So we just pass them to the lemmas (where they’re needed). This changes the last 4 lines of <code>minView</code> to:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="dt">Refl</span> xs)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="dt">Refl</span> xs hs&#39;)</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">    <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;))</a></code></pre></div>
<p>Now, we just have to fill in the lemmas! If we were lucky, they’d actually be constant-time.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs n a<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">       <span class="ot">-&gt;</span>  <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">lemma1 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-5" data-line-number="5"></a>
<a class="sourceLine" id="cb44-6" data-line-number="6"><span class="ot">lemma2 ::</span> forall x xs y ys n a<span class="fu">.</span></a>
<a class="sourceLine" id="cb44-7" data-line-number="7">          <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n y ys a</a>
<a class="sourceLine" id="cb44-10" data-line-number="10">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb44-11" data-line-number="11">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>)) (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-12" data-line-number="12">lemma2 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> _)) (<span class="dt">Even</span> _) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-13" data-line-number="13">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> xs) (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb44-14" data-line-number="14">  gcastWith (lemma2 <span class="dt">Refl</span> xs ys) <span class="dt">Refl</span></a></code></pre></div>
<p>If they <em>had</em> been constant-time, that would have let us throw them out: each proof would essentially show you what cases needed to be scrutinized to satisfy the typechecker. You then just scrutinize those cases in the actual function, and it should all typecheck.</p>
<p>As it is, <code>lemma2</code> is actually ok. It does cost <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>, but so does <code>carryOneNest</code>: we’ve maintained the complexity! We <em>could</em> stop here, satisfied.</p>
<p>There’s another option, though, one that I picked up from Stephanie Weirich’s talk <span class="citation" data-cites="weirich_dependent_2017">(<a href="#ref-weirich_dependent_2017">2017</a>)</span>: you thread the requirement through the function as an equality constraint. It won’t always work, but when your function’s call graph matches that of the proof, the constraint will indeed be satisfied, with no runtime cost. In this case, we can whittle down the proof obligation to the following:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
<p>Now we change the recursive <code>go</code> into continuation-passing style, and add that constraint to its signature, and everything works!</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go xs&#39; \(<span class="dt">Zipper</span> x _ xs) <span class="ot">-&gt;</span> (x,xs)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="ot">    go ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">       <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">       <span class="ot">-&gt;</span> (<span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs) <span class="ot">=&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">    go (<span class="dt">Even</span> xs) k <span class="fu">=</span> go xs \(<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="ot">-&gt;</span> k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs)))</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) k <span class="fu">=</span> k (<span class="dt">Zipper</span> x ts <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x cs) (<span class="dt">Cons</span> xs)) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb46-10" data-line-number="10">        go xs</a>
<a class="sourceLine" id="cb46-11" data-line-number="11">            \<span class="kw">case</span></a>
<a class="sourceLine" id="cb46-12" data-line-number="12">                <span class="dt">Zipper</span> m _ _ <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-13" data-line-number="13">                    k (<span class="dt">Zipper</span> x cs (<span class="dt">Cons</span> (<span class="dt">Even</span> xs)))</a>
<a class="sourceLine" id="cb46-14" data-line-number="14">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) <span class="dt">Empty</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-15" data-line-number="15">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t) <span class="dt">Empty</span>))))</a>
<a class="sourceLine" id="cb46-16" data-line-number="16">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) (<span class="dt">Cons</span> hs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-17" data-line-number="17">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t) hs))))</a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>As I mentioned in the beginning, a huge amount of this stuff is <em>much</em> easier using other systems. On top of that, there’s currently a lot of work being done on dependent type erasure, so that proofs like the above don’t even exist at runtime. In other words, there’s a chance that all of these techniques will soon be useless!</p>
<p>Efficient proof-carrying code makes for an interesting puzzle, though, even if it is a bit of a hair shirt.</p>
<h1 id="code">Code</h1>
<p>Fuller implementations of the structures here are in <a href="https://github.com/oisdk/pure-arrays">this</a> git repository.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bakst_liquidhaskell_2018">
<p>Bakst, Alexander, Ranjit Jhala, Ming Kawaguchi, Patrick Rondon, Eric Seidel, Michael Smith, Anish Tondwalkar, Chris Tetreault, and Niki Vazou. 2018. “LiquidHaskell: Liquid Types For Haskell.” ucsd-progsys. <a href="https://github.com/ucsd-progsys/liquidhaskell" class="uri">https://github.com/ucsd-progsys/liquidhaskell</a>.</p>
</div>
<div id="ref-ben-amram_pointers_1992">
<p>Ben-Amram, Amir M., and Zvi Galil. 1992. “On Pointers Versus Addresses.” <em>J. ACM</em> 39 (3) (July): 617–648. doi:<a href="https://doi.org/10.1145/146637.146666">10.1145/146637.146666</a>. <a href="http://doi.acm.org/10.1145/146637.146666" class="uri">http://doi.acm.org/10.1145/146637.146666</a>.</p>
</div>
<div id="ref-breitner_ready_2018-1">
<p>Breitner, Joachim, Antal Spector-Zabusky, Yao Li, Christine Rizkallah, John Wiegley, and Stephanie Weirich. 2018. “Ready, Set, Verify! Applying Hs-to-coq to Real-world Haskell Code (Experience Report).” <em>Proc. ACM Program. Lang.</em> 2 (ICFP) (July): 89:1–89:16. doi:<a href="https://doi.org/10.1145/3236784">10.1145/3236784</a>. <a href="http://doi.acm.org/10.1145/3236784" class="uri">http://doi.acm.org/10.1145/3236784</a>.</p>
</div>
<div id="ref-hinze_numerical_1998">
<p>Hinze, Ralf. 1998. <em>Numerical Representations as Higher-Order Nested Datatypes</em>. Institut für Informatik III, Universität Bonn. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5</a>.</p>
</div>
<div id="ref-hinze_perfect_1999">
<p>———. 1999. <em>Perfect Trees and Bit-reversal Permutations</em>.</p>
</div>
<div id="ref-komuves_nested-sequence_2016">
<p>Komuves, Balazs, and Peter Divianszky. 2016. “Nested-sequence: List-like data structures with O(Log(n)) random access.” <a href="http://hackage.haskell.org/package/nested-sequence" class="uri">http://hackage.haskell.org/package/nested-sequence</a>.</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. “How to Keep Your Neighbours in Order.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297–309. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>. <a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf" class="uri">https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf</a>.</p>
</div>
<div id="ref-might_missing_2015">
<p>Might, Matthew. 2015. “Missing method: How to delete from Okasaki’s red-black trees.” <em>matt.might.net</em>. <a href="http://matt.might.net/articles/red-black-delete/" class="uri">http://matt.might.net/articles/red-black-delete/</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999a. “From Fast Exponentiation to Square Matrices: An Adventure in Types.” In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP’99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf</a>.</p>
</div>
<div id="ref-okasaki_purely_1999">
<p>———. 1999b. <em>Purely Functional Data Structures</em>. Cambridge University Press.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. “Depending on Types.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241–241. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>. <a href="https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf" class="uri">https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf</a>.</p>
</div>
<div id="ref-weirich_dependent_2017">
<p>———. 2017. “Dependent Types in Haskell.” St. Louis, MO, USA. <a href="https://www.youtube.com/watch?v=wNa3MMbhwS4" class="uri">https://www.youtube.com/watch?v=wNa3MMbhwS4</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Tue, 20 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-11-20-fast-verified-structures.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Very Simple Prime Sieve in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-11-10-a-very-simple-prime-sieve.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 10, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Prime%20Sieves.html">2-part series on Prime Sieves</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>A few days ago, the <a href="https://www.youtube.com/user/Computerphile">Computerphile YouTube channel</a> put up a video about infinite lists in Haskell <span class="citation" data-cites="haran_infinity_2018">(Haran <a href="#ref-haran_infinity_2018">2018</a>)</span>. It’s pretty basic, but finishes up with a definition of an infinite list of prime numbers. The definition was something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">primes <span class="fu">=</span> sieve [<span class="dv">2</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve [ x <span class="fu">|</span> x <span class="ot">&lt;-</span> ps, mod x p <span class="fu">/=</span> <span class="dv">0</span> ]</a></code></pre></div>
<p>Unfortunately, and contrary to what’s stated in the video, this <em>isn’t</em> a genuine <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of Eratosthenes</a>. For one thing, it uses trial division where the sieve will only use addition and multiplication, and for another, every single new number is tested against every previous prime (until it finds a divisor).</p>
<p>While obviously this isn’t super important (no-one is using this algorithm to generate primes efficiently (I hope)), it still pops up from time to time on the internet as an example of “Haskell programmers overselling their language”. What’s more, people will then point to the famous <em>genuine</em> sieve of Eratosthenes in Haskell <span class="citation" data-cites="oneill_genuine_2009">(O’Neill <a href="#ref-oneill_genuine_2009">2009</a>)</span>, and say something to the effect of “Haskell is so difficult a simple prime sieve took a journal paper to implement properly”.</p>
<p>I think this is mainly silly: the example implementation is meant to showcase how well Haskell does recursion, list processing, and lazy evaluation. What’s more, the “genuine” prime sieve is difficult not because we’re working in Haskell, but because we’re working to generate <em>infinite primes</em>. The “simple” implementation of a prime sieve in something like Python will assume a fixed upper bound, and work with finite arrays and so on. Figuring out an efficient implementation for an infinite prime sieve there is even <em>more</em> difficult than it was in Haskell.</p>
<p>Anyway, I’m going to try today to show a very simple prime sieve that (hopefully) rivals the simplicity of the definition above.</p>
<h1 id="a-first-attempt">A First Attempt</h1>
<p>Visualizations of the sieve of Eratosthenes often rely on metaphors of “crossing out” on some large table. Once you hit a prime, you cross off all of its multiples in the rest of the table, and then you move to the next crossed-off number.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/0/0b/Sieve_of_Eratosthenes_animation.svg" alt="Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons" /><figcaption>Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons</figcaption>
</figure>
<p>Working with a finite array, it should be easy to see that this is extremely efficient. You’re crossing off every non-prime exactly once, only using addition and squaring.</p>
<p>To extend it to infinite lists, we will use the following function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">[] \\ ys <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">xs \\ [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">(x<span class="fu">:</span>xs) \\ (y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">case</span> compare x y <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="dt">LT</span> <span class="ot">-&gt;</span> x <span class="fu">:</span> xs \\ (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="dt">EQ</span> <span class="ot">-&gt;</span> xs \\ ys</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="dt">GT</span> <span class="ot">-&gt;</span> (x<span class="fu">:</span>xs) \\ ys</a></code></pre></div>
<p>We’re “subtracting” the right list from the left. Crucially, it works with infinite lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> take <span class="dv">10</span> ([<span class="dv">1</span><span class="fu">..</span>] \\ [<span class="dv">2</span>,<span class="dv">4</span><span class="fu">..</span>])</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</a></code></pre></div>
<p>Finally, it only works if both lists are ordered and don’t contain duplicates, but our sieve does indeed satisfy that requirement. Using this, we’ve already got a sieve:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve (ps \\ [p<span class="fu">*</span>p, p<span class="fu">*</span>p<span class="fu">+</span>p<span class="fu">..</span>])</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<p>No division, just addition and squaring, as promised. Unfortunately, though, this doesn’t have the time complexity we want. See, in the <code>(\\)</code> operation, we have to test every entry in the sieve against the prime factor: when we’re crossing off from an array, we just jump to the next composite number.</p>
<h1 id="using-a-queue">Using a Queue</h1>
<p>The way we speed up the “crossing-off” section of the algorithms is by using a priority queue: this was the optimization provided in <span class="citation" data-cites="oneill_genuine_2009">O’Neill (<a href="#ref-oneill_genuine_2009">2009</a>)</span>. Before we go any further, then, let’s put one together:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Queue</span> a b <span class="fu">=</span> <span class="dt">Queue</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    {<span class="ot"> minKey ::</span> <span class="fu">!</span>a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    ,<span class="ot"> minVal ::</span> b</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    ,<span class="ot"> rest   ::</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">data</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="fu">|</span> (<span class="fu">:-</span>) <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Queue</span> a b)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">           (<span class="dt">List</span> a b)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"></a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="ot">(&lt;+&gt;) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">(<span class="fu">&lt;+&gt;</span>) q1<span class="fu">@</span>(<span class="dt">Queue</span> x1 y1 ts1) q2<span class="fu">@</span>(<span class="dt">Queue</span> x2 y2 ts2)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="fu">|</span> x1 <span class="fu">&lt;=</span> x2 <span class="fu">=</span> <span class="dt">Queue</span> x1 y1 (q2 <span class="fu">:-</span> ts1)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Queue</span> x2 y2 (q1 <span class="fu">:-</span> ts2)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18"></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="ot">mergeQs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">List</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">mergeQs (t <span class="fu">:-</span> <span class="dt">Nil</span>)        <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">mergeQs (t1 <span class="fu">:-</span> t2 <span class="fu">:-</span> <span class="dt">Nil</span>) <span class="fu">=</span> t1 <span class="fu">&lt;+&gt;</span> t2</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">mergeQs (t1 <span class="fu">:-</span> t2 <span class="fu">:-</span> ts)  <span class="fu">=</span> (t1 <span class="fu">&lt;+&gt;</span> t2) <span class="fu">&lt;+&gt;</span> mergeQs ts</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">mergeQs <span class="dt">Nil</span>               <span class="fu">=</span> errorWithoutStackTrace <span class="st">&quot;tried to merge empty list&quot;</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24"></a>
<a class="sourceLine" id="cb5-25" data-line-number="25"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">insert <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>) (singleton k v)</a>
<a class="sourceLine" id="cb5-27" data-line-number="27"></a>
<a class="sourceLine" id="cb5-28" data-line-number="28"><span class="ot">singleton ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">singleton <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> <span class="dt">Queue</span> k v <span class="dt">Nil</span></a></code></pre></div>
<p>These are pairing heaps: I’m using them here because they’re relatively simple and very fast. A lot of their speed comes from the fact that the top-level constructor (<code>Queue</code>) is <em>non-empty</em>. Since, in this algorithm, we’re only actually going to be working with non-empty queues, this saves us a pattern match on pretty much every function. They’re also what’s used in <a href="https://github.com/haskell/containers/blob/master/Data/Sequence/Internal/sorting.md#sorting">Data.Sequence for sorting</a>.</p>
<p>With that, we can write our proper sieve:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">insertPrime x xs <span class="fu">=</span> insert (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">adjust x q<span class="fu">@</span>(<span class="dt">Queue</span> y (z<span class="fu">:</span>zs) qs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="fu">|</span> y <span class="fu">&lt;=</span> x <span class="fu">=</span> adjust x (insert z zs (mergeQs qs))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">sieve (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> sieve&#39; xs (singleton (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    sieve&#39; (x<span class="fu">:</span>xs) table</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      <span class="fu">|</span> minKey table <span class="fu">&lt;=</span> x <span class="fu">=</span> sieve&#39; xs (adjust x table)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">      <span class="fu">|</span> otherwise <span class="fu">=</span> x <span class="fu">:</span> sieve&#39; xs (insertPrime x xs table)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">      </a>
<a class="sourceLine" id="cb6-13" data-line-number="13">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<h1 id="simplifying">Simplifying</h1>
<p>The priority queue stores lists alongside their keys: what you might notice is that those lists are simply sequences of the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>,</mo><mn>2</mn><mi>x</mi><mo>,</mo><mn>3</mn><mi>x</mi><mo>,</mo><mn>4</mn><mi>x</mi><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[x, 2x, 3x, 4x...]</annotation></semantics></math> and so on. Rather than storing the whole list, we can instead store just the head and the step. This also simplifies (and greatly speeds up) the expensive <code>map (*x)</code> operation to just <em>two</em> multiplications. If you wanted, you could just sub in this representation of streams for all the lists above:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="fu">=</span> <span class="dt">Stepper</span> {<span class="ot"> start ::</span> a,<span class="ot"> step ::</span> a }</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">nextStep ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> (a, <span class="dt">Stepper</span> a)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">(^*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="dt">Stepper</span> x y <span class="fu">^*</span> f <span class="fu">=</span> <span class="dt">Stepper</span> (x <span class="fu">*</span> f) (y <span class="fu">*</span> f)</a></code></pre></div>
<p>If you were so inclined, you could even make it conform to <code>Foldable</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="dt">Stepper</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Stepper</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    foldr f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldr f b xs)</a></code></pre></div>
<p>But that’s overkill for what we need here.</p>
<p>Second observation is that if we remove the wheel (from 2), the “start” is simply the <em>key</em> in the priority queue, again cutting down on space.</p>
<p>Finally, we get the implementation:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve <span class="dv">3</span> (singleton <span class="dv">4</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    adjust x q<span class="fu">@</span>(<span class="dt">Queue</span> y z qs)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="fu">|</span> x <span class="fu">&lt;</span> y <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> adjust x (insert (y <span class="fu">+</span> z) z (mergeQs qs))</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    sieve x q</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">        <span class="fu">|</span> x <span class="fu">&lt;</span> minKey q <span class="fu">=</span> x <span class="fu">:</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (insert (x <span class="fu">*</span> x) x q)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">        <span class="fu">|</span> otherwise <span class="fu">=</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (adjust x q)</a></code></pre></div>
<p>8 lines for a lazy prime sieve isn’t bad!</p>
<p>I haven’t tried a huge amount to optimize the function, but it might be worth looking in to how to add back the wheels. I noticed that for no wheels, the queue contains only two elements per key; for one (the 2 wheel), we needed 3. I wonder if this pattern continues: possibly we could represent wheels as finite lists at each key in the queue. Maybe in a later post.</p>
<div id="refs" class="references">
<div id="ref-haran_infinity_2018">
<p>Haran, Brady. 2018. “To Infinity &amp; Beyond - Computerphile.” <a href="https://www.youtube.com/watch?v=bnRNiE_OVWA\&amp;feature=youtu.be" class="uri">https://www.youtube.com/watch?v=bnRNiE_OVWA\&amp;feature=youtu.be</a>.</p>
</div>
<div id="ref-oneill_genuine_2009">
<p>O’Neill, Melissa E. 2009. “The Genuine Sieve of Eratosthenes.” <em>Journal of Functional Programming</em> 19 (01) (January): 95. doi:<a href="https://doi.org/10.1017/S0956796808007004">10.1017/S0956796808007004</a>. <a href="https://pdfs.semanticscholar.org/b7d6/7986e54f852de25e2d803472f31fb53184d5.pdf" class="uri">https://pdfs.semanticscholar.org/b7d6/7986e54f852de25e2d803472f31fb53184d5.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 10 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-11-10-a-very-simple-prime-sieve.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Total Combinations</title>
    <link>https://doisinkidney.com/posts/2018-10-16-total-combinations.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 16, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Total%20Combinatorics.html">1-part series on Total Combinatorics</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Here’s a quick puzzle: from a finite alphabet, produce an infinite list of infinite strings, each of them unique.</p>
<p>It’s not a super hard problem, but here are some examples of what you might get. Given the alphabet of <code>0</code> and <code>1</code>, for instance, you could produce the following:</p>
<pre><code>0000000...
1000000...
0100000...
1100000...
0010000...
1010000...
0110000...
1110000...
0001000...</code></pre>
<p>In other words, the enumeration of the binary numbers (least-significant-digit first). We’ll just deal with bits first:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    showsPrec _ <span class="dt">O</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">&#39;0&#39;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    showsPrec _ <span class="dt">I</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">&#39;1&#39;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    showList xs s <span class="fu">=</span> foldr f s xs</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        f <span class="dt">O</span> a <span class="fu">=</span> <span class="ch">&#39;0&#39;</span> <span class="fu">:</span> a</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        f <span class="dt">I</span> a <span class="fu">=</span> <span class="ch">&#39;1&#39;</span> <span class="fu">:</span> a</a></code></pre></div>
<p>Thinking recursively, we can see that the tail of each list is actually the original sequence, doubled-up:</p>
<p><code class="sourceCode"> 0<span class="er">000000</span>... <br/> 1<span class="er">000000</span>... <br/> 0<span class="er">100000</span>... <br/> 1<span class="er">100000</span>... <br/> 0<span class="er">010000</span>... <br/> 1<span class="er">010000</span>... <br/> 0<span class="er">110000</span>... <br/> 1<span class="er">110000</span>... <br/> 0<span class="er">001000</span>... <br/> </code></p>
<p>As it happens, we get something like this pattern with the monad instance for lists <em>anyway</em>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;*&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[(<span class="dv">0</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;c&#39;</span>)]</a></code></pre></div>
<p>Well, actually it’s the wrong way around. We want to loop through the <em>first</em> list the quickest, incrementing the second slower. No worries, we can just use a flipped version of <code>&lt;*&gt;</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">&lt;&lt;&gt;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">(&lt;&lt;&gt;) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">fs <span class="fu">&lt;&lt;&gt;</span> xs <span class="fu">=</span> flip (<span class="fu">$</span>) <span class="fu">&lt;$&gt;</span> xs <span class="fu">&lt;*&gt;</span> fs</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">[(<span class="dv">0</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;c&#39;</span>)]</a></code></pre></div>
<p>Brilliant! So we can write our function now, yes?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> bins</a></code></pre></div>
<p>Nope! That won’t ever produce an answer, unfortunately.</p>
<h1 id="productivity">Productivity</h1>
<p>The issue with our definition above is that it’s not lazy enough: it demands information that it hasn’t produced yet, so it gets caught in an infinite loop before it can do anything!</p>
<p>We need to kick-start it a little, so it can produce output <em>before</em> it asks itself for more. Because we know what the first line is going to be, we can just tell it that:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> (repeat <span class="dt">O</span> <span class="fu">:</span> tail bins)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> mapM_ print (take <span class="dv">8</span> (map (take <span class="dv">3</span>) bins))</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="dv">000</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="dv">100</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="dv">010</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="dv">110</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="dv">001</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="dv">101</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="dv">011</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dv">111</span></a></code></pre></div>
<p>The property that this function has that the previous didn’t is <em>productivity</em>: the dual of termination. See, we want to avoid a <em>kind</em> of infinite loops in <code>bins</code>, but we don’t want to avoid infinite things altogether: the list it produces is meant to be infinite, for goodness’ sake. Instead, what it needs to do is produce every new value in <em>finite</em> time.</p>
<h1 id="checking-productivity">Checking Productivity</h1>
<p>In total languages, like Agda, termination checking is a must. To express computation like that above, though, you often also want a <em>productivity</em> checker. Agda can do that, too.</p>
<p>Let’s get started then. First, a stream:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    tail <span class="ot">:</span> Stream A</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>In Haskell, there was no need to define a separate stream type: the type of lists contains both finite and infinite lists.</p>
<p>Agda can get a little more specific: here, we’ve used the <code>coinductive</code> keyword, which means we’re free to create infinite <code>Stream</code>s. Rather than the usual termination checking (which would kick in when we consume a recursive, inductive type), we now get productivity checking: when creating a <code>Stream</code>, the <code>tail</code> must always be available in finite time. For a finite type, we’d have used the <code>inductive</code> keyword instead; this wouldn’t be much use, though, since there’s no way to create a finite <code>Stream</code> without a nil constructor!<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>One of the interesting things about working with infinite data (when you’re forced to notice that it’s infinite, as you are in Agda) is that <em>everything</em> gets flipped. So you have to prove productivity, not totality; you use product types, rather than sums; and to define functions, you use <em>co</em>patterns, rather than patterns.</p>
<h1 id="copatterns">Copatterns</h1>
<p>Copatterns are a handy syntactic construct for writing functions about record types. Let’s start with an example, and then I’ll try explain a little:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Stream A</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Here, we’re defining <code>pure</code> on streams: <code>pure x</code> produces an infinite stream of <code>x</code>. Its equivalent would be repeat in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">repeat<span class="ot"> ::</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">repeat x <span class="fu">=</span> x <span class="fu">:</span> repeat x</a></code></pre></div>
<p>Except instead of describing what it <em>is</em>, you describe how it <em>acts</em> (it’s kind of an intensional vs. extensional thing). In other words, if you want to make a stream <code>xs</code>, you have to answer the questions “what’s the head of <code>xs</code>?” and “what’s the tail of <code>xs</code>?”</p>
<p>Contrast this with pattern-matching: we’re producing (rather than consuming) a value, and in pattern matching, you have to answer a question for each <em>case</em>. If you want to consume a list <code>xs</code>, you have to answer the questions “what do you do when it’s nil?” and “what do you do when it’s cons?”</p>
<p>Anyway, I think the symmetry is kind of cool. Let’s get back to writing our functions.</p>
<h1 id="sized-types">Sized Types</h1>
<p>Unfortunately, we don’t have enough to prove productivity yet. As an explanation why, let’s first try produce the famous <code>fibs</code> list. Written here in Haskell:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</a></code></pre></div>
<p>Instead of <code>zipWith</code>, let’s define <code>&lt;*&gt;</code>. That will let us use <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/syntactic-sugar.html#idiom-brackets">idiom brackets</a>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">      <span class="ot">→</span> Stream <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">      <span class="ot">→</span> Stream A</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">      <span class="ot">→</span> Stream B</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>And here’s <code>fibs</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">fibs <span class="ot">:</span> Stream ℕ</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> ⦇ fibs + tail fibs ⦈</a></code></pre></div>
<p>But it doesn’t pass the productivity checker! Because we use a higher-order function (<code>&lt;*&gt;</code>), Agda won’t look at how much it dips into the infinite supply of values. This is a problem: we need it to know that <code>&lt;*&gt;</code> only needs the heads of its arguments to produce a head, and so on. The solution? Encode this information in the types.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>i <span class="ot">:</span> Size<span class="ot">}</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    tail <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>j <span class="ot">:</span> Size&lt; i<span class="ot">}</span> <span class="ot">→</span> Stream <span class="ot">{</span>j<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>Now, <code>Stream</code> has an implicit <em>size</em> parameter. Basically, <code>Stream {i} A</code> can produce <code>i</code> more values. So <code>cons</code>, then, gives a stream one extra value to produce:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">cons <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A <span class="ot">→</span> Stream <span class="ot">{</span>↑ i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">head <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">tail <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> xs</a></code></pre></div>
<p>Conversely, we can write a different definition of <code>tail</code> that consumes one value<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">tail′ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> Stream <span class="ot">{</span>↑ i<span class="ot">}</span> A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">tail′ <span class="ot">{</span>i<span class="ot">}</span> xs <span class="ot">=</span> tail xs <span class="ot">{</span>i<span class="ot">}</span></a></code></pre></div>
<p>For <code>&lt;*&gt;</code>, we want to show that its result can produce just as much values as its inputs can:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">      <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">      <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">      <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> B</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>How does this help the termination/productivity checker? Well, for terminating functions, we have to keep giving the <code>tail</code> field smaller and smaller sizes, meaning that we’ll eventually hit zero (and terminate). For productivity, we now have a way to talk about “definedness” in types, so we can make sure that a recursive call doesn’t dip into a supply it hasn’t produced yet.</p>
<p>One more thing: <code>Size</code> types have strange typing rules, mainly for ergonomic purposes (this is why we’re not just using an <code>ℕ</code> parameter). One of them is that if you don’t specify the size, it’s defaulted to <code>∞</code>, so functions written without size annotations don’t have to be changed with this new definition:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Stream A</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Finally <code>fibs</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fibs <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> ℕ</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> ⦇ fibs + tail fibs ⦈</a></code></pre></div>
<h1 id="bugs">Bugs!</h1>
<p>Before I show the Agda solution, I’d like to point out some bugs that were revealed in the Haskell version by trying to implement it totally. First of all, the function signature. “Takes an alphabet and produces unique strings” seems like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">strings ::</span> [a] <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>But what should you produce in this case:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">strings []</a></code></pre></div>
<p>So it must be a non-empty list, giving us the following type and definition:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">strings ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">strings (x <span class="fu">:|</span> xs) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> (x<span class="fu">:</span>xs) <span class="fu">&lt;&lt;&gt;</span> (repeat x <span class="fu">:</span> tail (strings (x <span class="fu">:|</span> xs)))</a></code></pre></div>
<p>But this has a bug too! What happens if we pass in the following:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">strings (x <span class="fu">:|</span> [])</a></code></pre></div>
<p>So this fails the specification: there is only one unique infinite string from that alphabet (<code>pure x</code>). Interestingly, though, our implementation above also won’t produce any output beyond the first element. I suppose, in a way, these things cancel each other out: our function does indeed produce all of the unique strings, it’s just a pity that it goes into an infinite loop to do so!</p>
<h1 id="bringing-it-all-together">Bringing it all Together</h1>
<p>Finally, we have our function:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A × A × List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_</span> , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>x₁ , x₂ , xt<span class="ot">))</span> <span class="ot">=</span> go x₂ xt <span class="ot">(</span>strings xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go x₁ <span class="ot">(</span>x₂ ∷ xt<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y ∷ ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>As you can see, we do need to kick-start it without a recursive call (the first line is <code>pure x</code>). Then, <code>go</code> takes as a third argument the “tails” argument, and does the kind of backwards Cartesian product we want. However, since we’re into the second element of the stream now, we want to avoid repeating what we already said, which is why we have to give <code>go</code> <code>x₂</code>, rather than <code>x₁</code>. This is what forces us to take at least two elements, rather than at least one, also: we can’t just take the tail of the call to <code>go</code> (this is what we did in the Haskell version of <code>strings</code> with the <code>NonEmpty</code> list), as the recursive call to strings then doesn’t decrease in size:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb24-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A × List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>x , xt<span class="ot">))</span> <span class="ot">=</span> tail <span class="ot">(</span>go x xt <span class="ot">(</span>strings xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go x xt <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y ∷ ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>Agda will warn about termination on this function. Now, if you slap a pragma on it, it <em>will</em> produce the correct results for enough arguments, but give it one and you’ll get an infinite loop, just as you were warned!</p>
<h1 id="further-work">Further Work</h1>
<p>I’m having a lot of fun with copatterns for various algorithms (especially combinatorics). I’m planning on working on two particular tasks with them for the next posts in this series:</p>
<dl>
<dt>Proving <code>strings</code></dt>
<dd><p>I’d like to prove that <code>strings</code> does indeed produce a stream of unique values. Following from that, it would be cool to do a Cantor diagonalisation on its output.</p>
</dd>
<dt>Permutations</dt>
<dd><p>Haskell’s <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#permutations">permutations implementation in Data.List</a> does some interesting tricks to make it as lazy as possible. It would be great to write an implementation that is verified to be as lazy as possible: the pattern of “definedness” is complex, though, so I don’t know if it’s possible with Agda’s current sized types.</p>
</dd>
</dl>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Thanks to <a href="http://gelisam.blogspot.com/">gelisam</a> for pointing out the poor phrasing here. Updated on 2018/10/16<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>You might wonder why the definition of <code>tail</code> doesn’t have this signature to begin with. The reason is that our record type must be <em>parameterized</em> (not indexed) over its size (as it’s a record type), so we use a less-than proof instead.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 16 Oct 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-10-16-total-combinations.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Agda Beginner(-ish) Tips, Tricks, & Pitfalls</title>
    <link>https://doisinkidney.com/posts/2018-09-20-agda-tips.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>I’m in the middle of quite a large Agda project at the moment, and I’ve picked up a few tips and tricks in the past few weeks. I’d imagine a lot of these are quite obvious once you get to grips with Agda, so I’m writing them down before I forget that they were once confusing stumbling blocks. Hopefully this helps other people trying to learn the language!</p>
<h1 id="parameterized-modules-strangeness">Parameterized Modules Strangeness</h1>
<p>Agda lets you parameterize modules, just as you can datatypes, with types, values, etc. It’s extremely handy for those situations where you want to be generic over some type, but that type won’t change inside the generic code. The keys to dictionaries is a good example: you can start the module with:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> Map <span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>Ordering <span class="ot">:</span> Ord Key<span class="ot">)</span> <span class="kw">where</span></a></code></pre></div>
<p>And now, where in Haskell you’d have to write something like <code>Ord a =&gt; Map a</code>… in pretty much any function signature, you can just refer to <code>Key</code>, and you’re good to go. It’s kind of like a dynamic type synonym, in that way.</p>
<p>Here’s the strangeness, though: what if you don’t supply one of the arguments?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span> Map</a></code></pre></div>
<p>This won’t give you a type error, strange as it may seem. This will perform <em>lambda lifting</em>, meaning that now, every function exported by the module will have the type signature:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>Ordering <span class="ot">:</span> Ord Key<span class="ot">)</span> <span class="ot">...</span></a></code></pre></div>
<p>Preceding its normal signature. In other words, it changes it into what you would have had to write in Haskell.</p>
<p>This is a powerful feature, but it can also give you some confusing errors if you don’t know about it (especially if the module has implicit arguments).</p>
<h1 id="auto">Auto</h1>
<p>If you’ve got a hole in your program, you can put the cursor in it and press <code>SPC-m-a</code> (in spacemacs), and Agda will try and find the automatic solution to the problem. For a while, I didn’t think much of this feature, as rare was the program which Agda could figure out. Turns out I was just using it wrong! Into the hole you should type the options for the proof search: enabling case-splitting (<code>-c</code>), enabling the use of available definitions (<code>-r</code>), and listing possible solutions (<code>-l</code>).</p>
<h1 id="well-founded-recursion">Well-Founded Recursion</h1>
<p>Often, a program will not be obviously terminating (according to Agda’s termination checker). The first piece of advice is this: <em>don’t</em> use well-founded recursion. It’s a huge hammer, and often you can get away with fiddling with the function (try inlining definitions, rewriting generic functions to monomorphic versions, or replacing with-blocks with helper functions), or using one of the <a href="https://gallais.github.io/blog/termination-tricks.html">more lightweight techniques</a> out there.</p>
<p>However, sometimes it really is the best option, so you have to grit your teeth and use it. What I expected (and what I used originally) was a recursion combinator, with a type something like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">wf-rec <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">       <span class="ot">→</span> <span class="ot">((</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> <span class="ot">((</span>y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> y &lt; x <span class="ot">→</span> B<span class="ot">)</span> <span class="ot">→</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">       <span class="ot">→</span> A <span class="ot">→</span> B</a></code></pre></div>
<p>So we’re trying to generate a function of type <code>A → B</code>, but there’s a hairy recursive call in there somewhere. Instead we use this function, and pass it a version of our function that uses the supplied function rather than making a recursive call:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">terminating <span class="ot">:</span> A <span class="ot">→</span> B</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">terminating <span class="ot">=</span> wf-rec <span class="ot">(λ</span> x recursive-call <span class="ot">→</span> <span class="ot">...)</span></a></code></pre></div>
<p>In other words, instead of calling the function itself, you call <code>recursive-call</code> above. Along with the argument, you supply a proof that it’s smaller than the outer argument (<code>y &lt; x</code>; assume for now that the definition of <code>&lt;</code> is just some relation like <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Data/Nat/Base.agda#L31"><code>_&lt;_</code> in Data.Nat</a>).</p>
<p>But wait! You don’t have to use it! Instead of all that, you can just pass the <code>Acc _&lt;_ x</code> type as a parameter to your function. In other words, if you have a dangerous function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">f <span class="ot">:</span> A <span class="ot">→</span> B</a></code></pre></div>
<p>Instead write:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1">f-step <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> Acc <span class="ot">_</span>&lt;<span class="ot">_</span> x <span class="ot">→</span> B</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">f-step <span class="ot">=</span> <span class="ot">...</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">f <span class="ot">:</span> A <span class="ot">→</span> B</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">f x <span class="ot">=</span> f-step x <span class="ot">...</span></a></code></pre></div>
<p>Once you pattern match on the accessibility relation, the termination checker is satisfied. This is much easier to understand (for me anyway), and made it <em>much</em> easier to write proofs about it.</p>
<p>Thanks to <a href="http://oleg.fi">Oleg Grenrus (phadej)</a> on irc for helping me out with this! Funnily enough, he actually recommended the <code>Acc</code> approach, and I instead originally went with the recursion combinator. Would have saved a couple hours if I’d just listened! Also worth mentioning is the approach recommended by <a href="https://gallais.github.io">Guillaume Allais (gallais)</a>, detailed <a href="https://gallais.github.io/agdarsec/Induction.Nat.Strong.html">here</a>. Haven’t had time to figure it out, so this article may be updated to recommend it instead in the future.</p>
<h1 id="dont-touch-the-green-slime">Don’t Touch The Green Slime!</h1>
<p>This one is really important. If I hadn’t read the exact explanation <a href="https://twitter.com/pigworker/status/1013535783234473984">here</a> I think I may have given up with Agda (or at the very least the project I’m working on) out of frustration.</p>
<p>Basically the problem arises like this. Say you’re writing a function to split a vector in two. You can specify the type pretty precisely:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">split <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a n m<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> Vec A <span class="ot">(</span>n + m<span class="ot">)</span> <span class="ot">→</span> Vec A n × Vec A m</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">split xs <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>Try to pattern-match on <code>xs</code>, though, and you’ll get the following error:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1">I&#39;m not sure if there should be a case for the <span class="kw">constructor</span> [],</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">because I get stuck when trying <span class="kw">to</span> solve the following unification</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">problems <span class="ot">(</span>inferred index ≟ expected index<span class="ot">):</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  zero ≟ n + m</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">when checking that the expression ? has type Vec <span class="ot">.</span>A <span class="ot">.</span>n × Vec <span class="ot">.</span>A <span class="ot">.</span>m</a></code></pre></div>
<p>What?! That’s weird. Anyway, you fiddle around with the function, end up pattern matching on the <code>n</code> instead, and continue on with your life.</p>
<p>What about this, though: you want to write a type for proofs that one number is less than or equal to another. You go with something like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>≤<span class="ot">_</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="ot">_</span>≤<span class="ot">_</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  proof <span class="ot">:</span> <span class="ot">∀</span> k <span class="ot">→</span> n ≤ n + k</a></code></pre></div>
<p>And you want to use it in a proof. Here’s the example we’ll be using: if two numbers are less than some limit <code>u</code>, then their maximum is also less than that limit:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1">max <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">max zero m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">max <span class="ot">(</span>suc n<span class="ot">)</span> zero <span class="ot">=</span> suc n</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">max <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc m<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>max n m<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">max-≤ <span class="ot">:</span> <span class="ot">∀</span> n m <span class="ot">{</span>u<span class="ot">}</span> <span class="ot">→</span> n ≤ u <span class="ot">→</span> m ≤ u <span class="ot">→</span> max n m ≤ u</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">max-≤ n m <span class="ot">(</span>proof k<span class="ot">)</span> m≤u <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>It won’t let you match on <code>m≤u</code>! Here’s the error:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">I&#39;m not sure if there should be a case for the <span class="kw">constructor</span> proof,</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">because I get stuck when trying <span class="kw">to</span> solve the following unification</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">problems <span class="ot">(</span>inferred index ≟ expected index<span class="ot">):</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  m₁ + k₂ ≟ n₁ + k₁</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">when checking that the expression ? has type max n m ≤ n + k</a></code></pre></div>
<p>What do you <em>mean</em> you’re not sure if there’s a case for the constructor <code>proof</code>: it’s the <em>only</em> case!</p>
<p>The problem is that Agda is trying to <em>unify</em> two types who both have calls to user-defined functions in them, which is a hard problem. As phrased by Conor McBride:</p>
<blockquote>
<p>When combining prescriptive and descriptive indices, ensure both are in constructor form. Exclude defined functions which yield difficult unification problems.</p>
</blockquote>
<p>So if you ever get the “I’m not sure if…” error, try either to:</p>
<ol>
<li>Redefine the indices so they use constructors, not functions.</li>
<li>Remove the index, instead having a proof inside the type of equality. What does that mean? Basically, transform the definition of <code>≤</code> above into <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Data/Nat/Base.agda#L72-L76">the one in Data.Nat</a>.</li>
</ol>
<h1 id="inspect">Inspect</h1>
<p>The use-case I had for this is a little long, I’m afraid (too long to include here), but it <em>did</em> come in handy. Basically, if you’re trying to prove something about a function, you may well want to <em>run</em> that function and pattern match on the result.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">f-is-the-same-as-g <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> f x ≡ g x</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">f-is-the-same-as-g x <span class="kw">with</span> f x</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">f-is-the-same-as-g x <span class="ot">|</span> y <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>This is a little different from the normal way of doing things, where you’d pattern match on the argument. It is a pattern you’ll sometimes need to write, though. And here’s the issue: that <code>y</code> has nothing to do with <code>f x</code>, as far as Agda is concerned. All you’ve done is introduced a new variable, and that’s that.</p>
<p>This is exactly the problem <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Relation/Binary/PropositionalEquality.agda#L111-L113"><code>inspect</code></a> solves: it runs your function, giving you a result, but <em>also</em> giving you a proof that the result is equal to running the function. You use it like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">f-is-the-same-as-g <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> f x ≡ g x</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">f-is-the-same-as-g x <span class="kw">with</span> f x <span class="ot">|</span> inspect f x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">f-is-the-same-as-g x <span class="ot">|</span> y <span class="ot">|</span> [ fx≡y ] <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<h1 id="spc-g-g">SPC-G-G</h1>
<p>Because the Agda standard library is a big fan of type synonyms (<code>Op₂ A</code> instead of <code>A → A → A</code> for example), it’s handy to know that pressing <code>SPC-G-G</code> (in spacemacs) over any identifier will bring you to the definition. Also, you can normalize a type with <code>SPC-m-n</code>.</p>
<h1 id="irrelevance">Irrelevance</h1>
<p>This one is a little confusing, because Agda’s notion of “irrelevance” is different from Idris’, or Haskell’s. In all three languages, irrelevance is used for performance: it means that a value doesn’t need to be around at runtime, so the compiler can elide it.</p>
<p>That’s where the similarities stop though. In Haskell, <em>all</em> types are irrelevant: they’re figments of the typechecker’s imagination. You can’t get a type at runtime full stop.</p>
<p>In dependently typed languages, this isn’t a distinction we can rely on. The line between runtime entities and compile-time entities is drawn elsewhere, so quite often types <em>need</em> to exist at runtime. As you might guess, though, they don’t always need to. The length of a length-indexed vector, for instance, is completely determined by the structure of the vector: why would you bother storing all of that information at runtime? This is what Idris recognizes, and what it tries to remedy: it analyses code for these kinds of opportunities for elision, and does so when it can. Kind of like Haskell’s fusion, though, it’s an invisible optimization, and there’s no way to make Idris throw a type error when it can’t elide something you want it to elide.</p>
<p>Agda is totally different. Something is irrelevant in Agda if it’s <em>unique</em>. Or, rather, it’s irrelevant if all you rely on is its existence. It’s used for proofs that you carry around with you: in a rational number type, you might use it to say that the numerator and denominator have no common factors. The only information you want from this proof is whether it holds or not, so it’s the perfect candidate for irrelevance.</p>
<p>Weirdly, this means it’s useless for the length-indexed vector kind of stuff mentioned above. In fact, it doe exactly the opposite of what you might expect: if the length parameter is marked as irrelevant, the the types <code>Vec A n</code> and <code>Vec A (suc n)</code> are the same!</p>
<p>The way you <em>can</em> use it is to pattern-match if it’s impossible. Again, it’s designed for eliding proofs that you may carry with you otherwise.</p>
<h1 id="future-tips">Future Tips</h1>
<p>Once I’m finished the project, I’ll try write up a guide on how to do literate Agda files. There were a couple of weird nuances that I had to pick up on the way, mainly to do with getting unicode to work.</p>
]]></description>
    <pubDate>Thu, 20 Sep 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-09-20-agda-tips.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Verified AVL Trees in Haskell and Agda</title>
    <link>https://doisinkidney.com/posts/2018-07-30-verified-avl.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 30, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>I’ve been writing a lot of Agda recently, and had the occasion to write a <a href="https://en.wikipedia.org/wiki/Fenwick_tree">Fenwick tree</a> that did some rebalancing. I went with <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL</a>-style rebalancing (rather than <a href="https://en.wikipedia.org/wiki/Red–black_tree">red-black</a> or <a href="https://en.wikipedia.org/wiki/Weight-balanced_tree">trees of bounded balance</a>). I’d written pretty full implementations of the other two before, and the Agda standard library <span class="citation" data-cites="danielsson_agda_2018">(Danielsson <a href="#ref-danielsson_agda_2018">2018</a>)</span> has an implementation already that I was able to use as a starting point. Also, apparently, AVL trees seem to perform better than red-black trees in practice <span class="citation" data-cites="pfaff_performance_2004">(Pfaff <a href="#ref-pfaff_performance_2004">2004</a>)</span>.</p>
<p>This post will be similar in style to Stephanie Weirich’s talk <span class="citation" data-cites="weirich_depending_2014">(<a href="#ref-weirich_depending_2014">2014</a>)</span>, which compares an Agda implementation of verified red-black trees to a Haskell one. When there’s two columns of code side-by-side, the left-hand side is Haskell, the right Agda.</p>
<p>The method of constructing the ordering proof is taken from “How to Keep Your Neighbours in Order” <span class="citation" data-cites="mcbride_how_2014">(<a href="#ref-mcbride_how_2014">2014</a>)</span> by Conor McBride; the structural proofs are somewhat inspired by the implementation in the Agda standard library, but are mainly my own.</p>
<h1 id="height">Height</h1>
<p>AVL trees are more strictly balanced than red-black trees: the height of neighboring subtrees can differ by at most one. To store the height, we will start as every dependently-typed program does: with Peano numbers.</p>
<style>
.column {
    float: left;
    width: 50%;
}
.row:after {
    content: "";
    display: table;
    clear: both;
}
</style>
<div class="row">
<div class="column">
<p>Haskell</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a></code></pre></div>
</div>
<div class="column">
<p>Agda</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  zero <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  suc  <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ</a></code></pre></div>
</div>
</div>
<p>The trees will be balanced one of three possible ways: left-heavy, right-heavy, or even. We can represent these three cases in a GADT in the case of Haskell, or an indexed datatype in the case of Agda:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Balance</span><span class="ot"> ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">      <span class="dt">L</span><span class="ot"> ::</span> <span class="dt">Balance</span> (<span class="dt">S</span> n) n    (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">      <span class="dt">O</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n    n     n</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">      <span class="dt">R</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n   (<span class="dt">S</span> n) (<span class="dt">S</span> n)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> ⟨<span class="ot">_</span>⊔<span class="ot">_</span>⟩≡<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  ◿  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ⟨ suc  n ⊔      n ⟩≡ suc  n</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  ▽  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ⟨      n ⊔      n ⟩≡      n</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  ◺  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ⟨      n ⊔ suc  n ⟩≡ suc  n</a></code></pre></div>
</div>
</div>
<p>Those unfamiliar with Agda might be a little intimidated by the mixfix operator in the balance definition: we’re using it here because the type can be seen of a proof that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">max(x,y) = z</annotation></semantics></math></p>
<p>Or, using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊔</mo><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math> operator:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>⊔</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">(x \sqcup y) = z</annotation></semantics></math></p>
<p>We’ll use this proof in the tree itself, as we’ll need to know the maximum of the height of a node’s two subtrees to find the height of the node. Before we do that, we’ll need a couple helper functions for manipulating the balance:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">balr ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> z x z</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">balr <span class="dt">L</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">balr <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">balr <span class="dt">R</span> <span class="fu">=</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">ball ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> y z z</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">ball <span class="dt">L</span> <span class="fu">=</span> <span class="dt">R</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">ball <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">ball <span class="dt">R</span> <span class="fu">=</span> <span class="dt">O</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">⃕ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">→</span> ⟨ x ⊔ y ⟩≡ z <span class="ot">→</span> ⟨ z ⊔ x ⟩≡ z</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">⃕  ◿  <span class="ot">=</span> ▽</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">⃕  ▽  <span class="ot">=</span> ▽</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">⃕  ◺  <span class="ot">=</span> ◿</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">⃔ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">→</span> ⟨ x ⊔ y ⟩≡ z <span class="ot">→</span> ⟨ y ⊔ z ⟩≡ z</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">⃔  ◿  <span class="ot">=</span> ◺</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">⃔  ▽  <span class="ot">=</span> ▽</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">⃔  ◺  <span class="ot">=</span> ▽</a></code></pre></div>
</div>
</div>
<h1 id="ordering">Ordering</h1>
<p>Along with the verification of the structure of the tree, we will also want to verify that its contents are ordered correctly. Unfortunately, this property is a little out of reach for Haskell, but it’s 100% doable in Agda. First, we’ll need a way to describe orders on a data type. In Haskell, we might write:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Ord</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">  (&lt;)  ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
</div>
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
</div>
<p>That <code class="sourceCode haskell"><span class="dt">Bool</span></code> throws away any information gained in the comparison, though: we want to supply a proof with the result of the comparison. First, equality:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">infix <span class="dv">4</span> <span class="fu">==</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">data</span><span class="ot"> (==) ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">          <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="dt">Refl</span><span class="ot"> ::</span> x <span class="fu">==</span> x</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>≡<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">data</span> <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">         <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">         <span class="ot">:</span> A <span class="ot">→</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  refl <span class="ot">:</span> x ≡ x</a></code></pre></div>
</div>
</div>
<p>This is one of the many ways to describe equality in Agda. It’s a type with only one constructor, and it can only be constructed when its two arguments are the same. When we pattern match on the constructor, then, we’re given a proof that whatever things those arguments refer to must be the same.</p>
<p>Next, we need to describe an order. For this, we’ll need two types: the empty type, and the unit type.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Void</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Unit</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span> <span class="dt">Unit</span><span class="ot"> ::</span> <span class="dt">Unit</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> ⊥ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">data</span> ⊤ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span> ⟨⟩ <span class="ot">:</span> ⊤</a></code></pre></div>
</div>
</div>
<p>These are kind of like type-level Bools, with one extra, powerful addition: they keep their proof after construction. Because <code class="sourceCode agda">⊥</code> has no constructors, if someone tells you they’re going to give you one, you can be pretty sure they’re lying. How do we use this? Well, first, on the numbers:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">type</span> family (<span class="ot">n ::</span> <span class="dt">N</span>) <span class="fu">&lt;</span> (<span class="ot">m ::</span> <span class="dt">N</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  x   <span class="fu">&lt;</span> <span class="dt">Z</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="dt">Z</span>   <span class="fu">&lt;</span> <span class="dt">S</span> y <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="dt">S</span> x <span class="fu">&lt;</span> <span class="dt">S</span> y <span class="fu">=</span> x <span class="fu">&lt;</span> y</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">_</span>ℕ&lt;<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">x     ℕ&lt; zero  <span class="ot">=</span> ⊥</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">zero  ℕ&lt; suc y <span class="ot">=</span> ⊤</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">suc x ℕ&lt; suc y <span class="ot">=</span> x ℕ&lt; y</a></code></pre></div>
</div>
</div>
<p>Therefore, if we ask for something of type <code class="sourceCode agda">x ℕ&lt; y</code> (for some <code>x</code> and <code>y</code>), we know that it only exists when <code>x</code> really is less than <code>y</code> (according to the definition above).</p>
<p>For our actual code, we’ll parameterize the whole thing over some abstract key type. We’ll do this using a module (a feature recently added to Haskell, as it happens). That might look something like this:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">signature <span class="dt">Key</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">import</span> <span class="dt">Data.Kind</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">data</span> <span class="dt">Key</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="kw">type</span> family (<span class="ot">n ::</span> <span class="dt">Key</span>) <span class="fu">&lt;</span> (<span class="ot">m ::</span> <span class="dt">Key</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="ot">    ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">module</span> <span class="dt">AVL</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  <span class="kw">import</span> <span class="dt">Key</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">module</span> AVL</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="ot">{</span>k r<span class="ot">}</span> <span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span> k<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="ot">{_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> Rel Key r<span class="ot">}</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="ot">(</span>isStrictTotalOrder</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   <span class="ot">:</span> IsStrictTotalOrder <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">_</span>&lt;<span class="ot">_)</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">open</span> IsStrictTotalOrder isStrictTotalOrder</a></code></pre></div>
</div>
</div>
<p>(the <code class="sourceCode agda">k</code> and <code class="sourceCode agda">r</code> here, as well as the <code class="sourceCode agda">Lift</code>ing noise below, are to do with Agda’s universe system, which I’ll try explain in a bit)</p>
<p>Now, the trick for the ordering is to keep a proof that two neighboring values are ordered correctly in the tree at each leaf (as there’s a leaf between every pair of nodes, this is exactly the place you <em>should</em> store such a proof). A problem arises with the extremal leaves in the tree (leftmost and rightmost): each leaf is missing one neighboring value, so how can it store a proof of order? The solution is to affix two elements to our key type which we define as the greatest and least elements of the set.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Bound</span> <span class="fu">=</span> <span class="dt">LB</span> <span class="fu">|</span> <span class="dt">IB</span> <span class="dt">Key</span> <span class="fu">|</span> <span class="dt">UB</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">infix <span class="dv">4</span> <span class="fu">&lt;:</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="kw">type</span> family (<span class="ot">x ::</span> <span class="dt">Bound</span>) <span class="fu">&lt;:</span> (<span class="ot">y ::</span> <span class="dt">Bound</span>)</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="ot">    ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">LB</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">UB</span>   <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">IB</span> _ <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">  <span class="dt">UB</span>   <span class="fu">&lt;:</span> _    <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-15" data-line-number="15">  <span class="dt">IB</span> _ <span class="fu">&lt;:</span> <span class="dt">LB</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">  <span class="dt">IB</span> _ <span class="fu">&lt;:</span> <span class="dt">UB</span>   <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-17" data-line-number="17">  <span class="dt">IB</span> x <span class="fu">&lt;:</span> <span class="dt">IB</span> y <span class="fu">=</span> x <span class="fu">&lt;</span> y</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">5</span> [<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">data</span> [∙] <span class="ot">:</span> <span class="dt">Set</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  ⌊⌋ ⌈⌉ <span class="ot">:</span> [∙]</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  [<span class="ot">_</span>]   <span class="ot">:</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span> <span class="ot">→</span> [∙]</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>[&lt;]<span class="ot">_</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"><span class="ot">_</span>[&lt;]<span class="ot">_</span> <span class="ot">:</span> [∙] <span class="ot">→</span> [∙] <span class="ot">→</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">⌊⌋     [&lt;] ⌊⌋    <span class="ot">=</span> Lift r ⊥</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">⌊⌋     [&lt;] ⌈⌉    <span class="ot">=</span> Lift r ⊤</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">⌊⌋     [&lt;] [ <span class="ot">_</span> ] <span class="ot">=</span> Lift r ⊤</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">⌈⌉     [&lt;] <span class="ot">_</span>     <span class="ot">=</span> Lift r ⊥</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">[ <span class="ot">_</span> ]  [&lt;] ⌊⌋    <span class="ot">=</span> Lift r ⊥</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">[ <span class="ot">_</span> ]  [&lt;] ⌈⌉    <span class="ot">=</span> Lift r ⊤</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">[ x ]  [&lt;] [ y ] <span class="ot">=</span> x &lt; y</a></code></pre></div>
</div>
</div>
<h1 id="the-tree-type">The Tree Type</h1>
<p>After all that, we can get bring back Haskell into the story, and define or tree types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Tree</span><span class="ot"> ::</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">          <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Tree</span> <span class="dt">Z</span> k v</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  <span class="dt">Node</span><span class="ot"> ::</span> k</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">       <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Balance</span> lh rh h</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> lh k v</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> h) k v</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> Tree <span class="ot">{</span>v<span class="ot">}</span> </a>
<a class="sourceLine" id="cb19-2" data-line-number="2">          <span class="ot">(</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">          <span class="ot">(</span>l u <span class="ot">:</span> [∙]<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">          <span class="dt">Set</span> <span class="ot">(</span>k ⊔ v ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  leaf  <span class="ot">:</span> <span class="ot">(</span>l&lt;u <span class="ot">:</span> l [&lt;] u<span class="ot">)</span> <span class="ot">→</span> Tree V l u <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  node  <span class="ot">:</span> <span class="ot">∀</span>  <span class="ot">{</span>h lh rh<span class="ot">}</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">             <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">             <span class="ot">(</span>v <span class="ot">:</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">             <span class="ot">(</span>bl <span class="ot">:</span> ⟨ lh ⊔ rh ⟩≡ h<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">             <span class="ot">(</span>lk <span class="ot">:</span> Tree V l [ k ] lh<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">             <span class="ot">(</span>ku <span class="ot">:</span> Tree V [ k ] u rh<span class="ot">)</span> <span class="ot">→</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">             Tree V l u <span class="ot">(</span>suc h<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<p>The two definitions are similar, but have a few obvious differences. The Agda version stores the ordering proof at the leaves, as well as the bounds as indices. Its <a href="https://pigworker.wordpress.com/2015/01/09/universe-hierarchies/"><em>universe</em></a> is also different: briefly, universes are one of the ways to avoid Russell’s paradox when you’re dealing with dependent types.</p>
<p>In normal, standard Haskell, we think of types as things that describe values (how quaint!). When you’ve got a list, everything in the list has the same type, and that is good and right.</p>
<p>These days, though, we’re not so constrained:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">List</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">  (:-) ::</span> x</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">       <span class="ot">-&gt;</span> <span class="dt">List</span> xs</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">       <span class="ot">-&gt;</span> <span class="dt">List</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>፦<span class="ot">_</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="kw">data</span> List′ <span class="ot">:</span> List <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  nil <span class="ot">:</span> List′ []</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="ot">_</span>፦<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>x xs<span class="ot">}</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">      <span class="ot">→</span> x </a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      <span class="ot">→</span> List′ xs </a>
<a class="sourceLine" id="cb21-7" data-line-number="7">      <span class="ot">→</span> List′ <span class="ot">(</span>x ∷ xs<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<p>This can quite happily store elements of different types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">example ::</span> <span class="dt">List</span> [<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">example <span class="fu">=</span> <span class="dt">True</span> <span class="fu">:-</span> <span class="st">&quot;true&quot;</span> <span class="fu">:-</span> <span class="dv">1</span> <span class="fu">:-</span> <span class="dt">Nil</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">example <span class="ot">:</span> List′ <span class="ot">(</span>Bool ∷ String ∷ ℕ ∷ []<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">example <span class="ot">=</span> true ፦ <span class="st">&quot;true&quot;</span> ፦ <span class="dv">1</span> ፦ nil</a></code></pre></div>
</div>
</div>
<p>And look at that bizarre-looking list on the wrong side of “<code class="sourceCode haskell"><span class="ot">::</span></code>”! Types aren’t just describing values, they’re acting like values themselves. What type does <code class="sourceCode haskell">[<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</code> even have, anyway? Why, <code class="sourceCode haskell">[<span class="dt">Type</span>]</code> of course!</p>
<p>So we see that types can be put in lists, and types have types: the natural question then is:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="fu">???</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="dt">Set</span> <span class="ot">:</span> ???</a></code></pre></div>
</div>
</div>
<p>And this is where Haskell and Agda diverge: in Haskell, we say <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> (as the old extension <code class="sourceCode haskell"><span class="dt">TypeInType</span></code> implied), and that’s that. From a certain point of view, we’ve opened the door to Russell’s paradox (we’ve allowed a set to be a member of itself). This isn’t an issue in Haskell, though, as the type-level language was already inconsistent.</p>
<p>Agda goes another way, saying that <code class="sourceCode agda"><span class="dt">Set</span></code> (Agda’s equivalent for <code class="sourceCode haskell"><span class="dt">Type</span></code>) has the type <code class="sourceCode agda"><span class="dt">Set₁</span></code>, and <code class="sourceCode agda"><span class="dt">Set₁</span></code> has the type <code class="sourceCode agda"><span class="dt">Set₂</span></code>, and so on<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. These different sets are called “universes” and their numbers “levels”. When we write <code class="sourceCode agda">k ⊔ v ⊔ r</code>, we’re saying we want to take the greatest universe level from those three possible levels: the level of the key, the value, and the relation, respectively.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb27"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="dt">Set</span> <span class="ot">:</span> <span class="dt">Set₁</span></a></code></pre></div>
</div>
</div>
<h1 id="rotations">Rotations</h1>
<p>AVL trees maintain their invariants through relatively simple rotations. We’ll start with the right rotation, which fixes an imbalance of two on the left. Because the size of the tree returned might change, we’ll need to wrap it in a datatype:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span><span class="ot"> (++?) ::</span> (<span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">           <span class="ot">-&gt;</span> (<span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">           <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="dt">Stay</span><span class="ot"> ::</span> t n     <span class="ot">-&gt;</span> t <span class="fu">++?</span> n</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">  <span class="dt">Incr</span><span class="ot"> ::</span> t (<span class="dt">S</span> n) <span class="ot">-&gt;</span> t <span class="fu">++?</span> n</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1"></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="ot">_</span>1?+⟨<span class="ot">_</span>⟩ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>𝓁<span class="ot">}</span> <span class="ot">(</span>T <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> 𝓁<span class="ot">)</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> 𝓁</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">T 1?+⟨ n ⟩ <span class="ot">=</span> ∃[ inc? ] T <span class="ot">(</span>if inc?</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">                            then suc n</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">                            else n<span class="ot">)</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6"></a>
<a class="sourceLine" id="cb29-7" data-line-number="7"><span class="kw">pattern</span> 0+<span class="ot">_</span> tr <span class="ot">=</span> false , tr</a>
<a class="sourceLine" id="cb29-8" data-line-number="8"><span class="kw">pattern</span> 1+<span class="ot">_</span> tr <span class="ot">=</span> true  , tr</a></code></pre></div>
</div>
</div>
<p>We could actually have the Agda definition be the same as Haskell’s, it doesn’t make much difference. I’m mainly using it here to demonstrate dependent pairs in Agda. The first member of the pair is just a boolean (increased in height/not increased in height). The second member is a tree whose height <em>depends</em> on the actual value of the boolean. The <code class="sourceCode agda">∃</code> business is just a fancy syntax; it also waggles its eyebrows at the way a (dependent) pair of type <code>(x , y)</code> means “There exists an x such that y”.</p>
<p>Using this, we can write the type for right-rotation:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">rotr ::</span> k</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">     <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> (<span class="dt">S</span> rh)) k v</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> k v <span class="fu">++?</span> <span class="dt">S</span> (<span class="dt">S</span> rh)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb31"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb31-1" data-line-number="1">rotʳ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>lb ub rh v<span class="ot">}</span> <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">     <span class="ot">→</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">     <span class="ot">→</span> V k</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">     <span class="ot">→</span> Tree V lb [ k ] <span class="ot">(</span>suc <span class="ot">(</span>suc rh<span class="ot">))</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">     <span class="ot">→</span> Tree V [ k ] ub rh</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">     <span class="ot">→</span> Tree V lb ub 1?+⟨ suc <span class="ot">(</span>suc rh<span class="ot">)</span> ⟩</a></code></pre></div>
</div>
</div>
<p>There are two possible cases, single rotation:</p>
<style>
.tree {
  margin: auto;
  width: 30%;
}
</style>
<div class="tree">
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">   ┌a       ┌a</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"> ┌y┤       y┤</a>
<a class="sourceLine" id="cb32-3" data-line-number="3"> │ └b <span class="fu">---&gt;</span>  │ ┌b</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">x┤          └x┤</a>
<a class="sourceLine" id="cb32-5" data-line-number="5"> └c           └c</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">L</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="dt">Stay</span> (<span class="dt">Node</span> y yv <span class="dt">O</span> a (<span class="dt">Node</span> x xv <span class="dt">O</span> b c))</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">O</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">  <span class="dt">Incr</span> (<span class="dt">Node</span> y yv <span class="dt">R</span> a (<span class="dt">Node</span> x xv <span class="dt">L</span> b c))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb34"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb34-1" data-line-number="1">rotʳ x xv <span class="ot">(</span>node y yv ◿ a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  0+ <span class="ot">(</span>node y yv ▽ a <span class="ot">(</span>node x xv ▽  b c<span class="ot">))</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">rotʳ x xv <span class="ot">(</span>node y yv ▽ a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4">  1+ <span class="ot">(</span>node y yv ◺ a <span class="ot">(</span>node x xv ◿  b c<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>And double:</p>
<div class="tree">
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">   ┌a           ┌a</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"> ┌y┤          ┌y┤</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"> │ │ ┌b       │ └b</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"> │ └z┤  <span class="fu">---&gt;</span> z┤</a>
<a class="sourceLine" id="cb35-5" data-line-number="5"> │   └c       │ ┌c</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">x┤            └x┤</a>
<a class="sourceLine" id="cb35-7" data-line-number="7"> └d             └d</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">R</span> a </a>
<a class="sourceLine" id="cb36-2" data-line-number="2">            (<span class="dt">Node</span> z zv bl b c)) d <span class="fu">=</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">  <span class="dt">Stay</span> (<span class="dt">Node</span> z zv <span class="dt">O</span> </a>
<a class="sourceLine" id="cb36-4" data-line-number="4">         (<span class="dt">Node</span> y yv (balr bl) a b)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">         (<span class="dt">Node</span> x xv (ball bl) c d))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb37"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb37-1" data-line-number="1">rotʳ x xv <span class="ot">(</span>node y yv ◺  a</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">            <span class="ot">(</span>node z zv bl b c<span class="ot">))</span> d <span class="ot">=</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">  0+ <span class="ot">(</span>node z zv ▽</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">       <span class="ot">(</span>node y yv <span class="ot">(</span>⃕ bl<span class="ot">)</span> a b<span class="ot">)</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5">       <span class="ot">(</span>node x xv <span class="ot">(</span>⃔ bl<span class="ot">)</span> c d<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>I won’t bore you with left-rotation: suffice to say, it’s the opposite of right-rotation.</p>
<h1 id="insertion">Insertion</h1>
<p>Finally, the main event: insertion. Once the above functions have all been defined, it’s not very difficult, as it happens: by and large, the types guide you to the right answer. Of course, this is only after we decided to use the pivotal pragmatism and balance approach.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">insertWith</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    <span class="ot">-&gt;</span> k</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Tree</span> h k v</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Tree</span> k v <span class="fu">++?</span> h</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">insertWith _ v vc <span class="dt">Leaf</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9">  <span class="dt">Incr</span> (<span class="dt">Node</span> v vc <span class="dt">O</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb38-10" data-line-number="10">insertWith f v vc (<span class="dt">Node</span> k kc bl tl tr) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">  <span class="kw">case</span> compare v k <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12">    <span class="dt">LT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13">      <span class="kw">case</span> insertWith f v vc tl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-14" data-line-number="14">        <span class="dt">Stay</span> tl&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl&#39; tr)</a>
<a class="sourceLine" id="cb38-16" data-line-number="16">        <span class="dt">Incr</span> tl&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-17" data-line-number="17">          <span class="dt">L</span> <span class="ot">-&gt;</span> rotr k kc tl&#39; tr</a>
<a class="sourceLine" id="cb38-18" data-line-number="18">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">L</span> tl&#39; tr)</a>
<a class="sourceLine" id="cb38-19" data-line-number="19">          <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl&#39; tr)</a>
<a class="sourceLine" id="cb38-20" data-line-number="20">    <span class="dt">EQ</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-21" data-line-number="21">      <span class="dt">Stay</span> (<span class="dt">Node</span> v (f vc kc) bl tl tr)</a>
<a class="sourceLine" id="cb38-22" data-line-number="22">    <span class="dt">GT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-23" data-line-number="23">      <span class="kw">case</span> insertWith f v vc tr <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-24" data-line-number="24">        <span class="dt">Stay</span> tr&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-25" data-line-number="25">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl tr&#39;)</a>
<a class="sourceLine" id="cb38-26" data-line-number="26">        <span class="dt">Incr</span> tr&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-27" data-line-number="27">          <span class="dt">L</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl tr&#39;)</a>
<a class="sourceLine" id="cb38-28" data-line-number="28">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">R</span> tl tr&#39;)</a>
<a class="sourceLine" id="cb38-29" data-line-number="29">          <span class="dt">R</span> <span class="ot">-&gt;</span> rotl k kc tl tr&#39;</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb39"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb39-1" data-line-number="1">insert <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>l u h v<span class="ot">}</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">           <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">           <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-4" data-line-number="4">       <span class="ot">→</span> V k</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">       <span class="ot">→</span> <span class="ot">(</span>V k <span class="ot">→</span> V k <span class="ot">→</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-6" data-line-number="6">       <span class="ot">→</span> Tree V l u h</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">       <span class="ot">→</span> l &lt; k &lt; u</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">       <span class="ot">→</span> Tree V l u 1?+⟨ h ⟩</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">insert v vc f <span class="ot">(</span>leaf l&lt;u<span class="ot">)</span> <span class="ot">(</span>l , u<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">  1+ <span class="ot">(</span>node v vc ▽ <span class="ot">(</span>leaf l<span class="ot">)</span> <span class="ot">(</span>leaf u<span class="ot">))</span></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> prf</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">  <span class="kw">with</span> compare v k</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(</span>l , <span class="ot">_)</span></a>
<a class="sourceLine" id="cb39-14" data-line-number="14">    <span class="ot">|</span> tri&lt; a <span class="ot">_</span> <span class="ot">_</span> <span class="kw">with</span> insert v vc f tl <span class="ot">(</span>l , a<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-15" data-line-number="15"><span class="ot">...</span> <span class="ot">|</span> 0+ tl′ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tl′ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-16" data-line-number="16"><span class="ot">...</span> <span class="ot">|</span> 1+ tl′ <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb39-17" data-line-number="17"><span class="ot">...</span> <span class="ot">|</span> ◿ <span class="ot">=</span> rotʳ k kc tl′ tr</a>
<a class="sourceLine" id="cb39-18" data-line-number="18"><span class="ot">...</span> <span class="ot">|</span> ▽ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc  ◿  tl′ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-19" data-line-number="19"><span class="ot">...</span> <span class="ot">|</span> ◺ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc  ▽  tl′ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-20" data-line-number="20">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb39-21" data-line-number="21">    <span class="ot">|</span> tri≈ <span class="ot">_</span> refl <span class="ot">_</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-22" data-line-number="22">        0+ <span class="ot">(</span>node k <span class="ot">(</span>f vc kc<span class="ot">)</span> bl tl tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-23" data-line-number="23">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(_</span> , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-24" data-line-number="24">    <span class="ot">|</span> tri&gt; <span class="ot">_</span> <span class="ot">_</span> c <span class="kw">with</span> insert v vc f tr <span class="ot">(</span>c , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-25" data-line-number="25"><span class="ot">...</span> <span class="ot">|</span> 0+ tr′ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tl tr′<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-26" data-line-number="26"><span class="ot">...</span> <span class="ot">|</span> 1+ tr′ <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb39-27" data-line-number="27"><span class="ot">...</span> <span class="ot">|</span> ◿ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc ▽ tl tr′<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-28" data-line-number="28"><span class="ot">...</span> <span class="ot">|</span> ▽ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc ◺ tl tr′<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-29" data-line-number="29"><span class="ot">...</span> <span class="ot">|</span> ◺ <span class="ot">=</span> rotˡ k kc tl tr′</a></code></pre></div>
</div>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, I’ve been enjoying programming in Agda. The things I liked and didn’t like surprised me:</p>
<dl>
<dt>Editor Support</dt>
<dd><p>Is excellent. I use <a href="http://spacemacs.org">spacemacs</a>, and the whole thing worked pretty seamlessly. Proof search and auto was maybe not as powerful as Idris’, although that might be down to lack of experience (note—as I write this, I see you can enable case-splitting in proof search, so it looks like I was right about my lack of experience). In many ways, it was much better than Haskell’s editor support: personally, I have never managed to get case-splitting to work in my Haskell setup, never mind some of the fancier features that you get in Agda.</p>
<p>It’s worth noting that my experience with Idris is similar: maybe it’s something about dependent types?</p>
<p>Of course, I missed lots of extra tools, like linters, code formatters, etc., but the tight integration with the compiler was so useful it more than made up for it.</p>
<p>Also, I’d implore anyone who’s had trouble with emacs before to give <a href="http://spacemacs.org">spacemacs</a> a go. It works well out-of-the-box, and has a system for keybinding discovery that <em>actually works</em>.</p>
</dd>
<dt>Documentation</dt>
<dd><p>Pretty good, considering. There are some missing parts (<a href="https://agda.readthedocs.io/en/v2.5.4.1/language/rewriting.html">rewriting</a> and <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/telescopes.html">telescopes</a> are both stubs on the documentation site), but there seemed to be more fully worked-out examples available online for different concepts when I needed to figure them out.</p>
</dd>
</dl>
<p>Now, the thing about a lot of these complaints/commendations (<em>especially</em> with regards to tooling and personal setups) is that people tend to be pretty bad about evaluating how difficult finicky tasks like editor setups are. Once you’ve gotten the hang of some of this stuff, you forget that you ever didn’t. Agda is the second dependently-typed language I’ve really gone for a deepish dive on, and I’ve been using spacemacs for a while, so YMMV.</p>
<p>One area of the language itself that I would have liked to see more on was irrelevance. Looking back at the definition of the tree type, in the Haskell version there’s no singleton storing the height (the balance type stores all the information we need), which means that it definitely doesn’t exist at runtime. As I understand it, that implies that the type should be irrelevant in the equivalent Agda. However, when I actually mark it as irrelevant, everything works fine, except that missing cases warnings start showing up. I couldn’t figure out why: Haskell was able to infer full case coverage without the index, after all. Equality proof erasure, also: is it safe? Consistent?</p>
<p>All in all, I’d encourage more Haskellers to give Agda a try. It’s fun, interesting, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="script"><mi>𝒰</mi><mi>𝓃</mi><mi>𝒾</mi><mi>𝒸</mi><mi>ℴ</mi><mi>𝒹</mi><mi>ℯ</mi></mstyle><annotation encoding="application/x-tex">\mathcal{Unicode}</annotation></semantics></math>!</p>
<h1 id="further-reading">Further Reading</h1>
<p>No “deletion is left as an exercise to the reader” here, no sir! Fuller implementations of both the Haskell and Agda versions of the code here are available: first, a pdf of the Agda code with lovely colours is <a href="/pdfs/AVL.pdf">here</a>. The accompanying repository is <a href="https://github.com/oisdk/agda-avl">here</a>, and the equivalent for the Haskell code is <a href="https://github.com/oisdk/verified-avl">here</a>. Of course, if you would rather read something by someone who knows what they’re talking about, please see the</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-danielsson_agda_2018">
<p>Danielsson, Nils Anders. 2018. “The Agda standard library.”</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. “How to Keep Your Neighbours in Order.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297–309. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>.</p>
</div>
<div id="ref-pfaff_performance_2004">
<p>Pfaff, Ben. 2004. “Performance Analysis of BSTs in System Software.” In <em>Proceedings of the Joint International Conference on Measurement and Modeling of Computer Systems</em>, 410–411. SIGMETRICS ’04/performance ’04. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1005686.1005742">10.1145/1005686.1005742</a>.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. “Depending on Types.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241–241. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>My phrasing is maybe a little confusing here. When <code class="sourceCode haskell"><span class="dt">Set</span></code> “has the type” <code class="sourceCode agda"><span class="dt">Set₁</span></code> it means that <code class="sourceCode haskell"><span class="dt">Set</span></code> is <em>in</em> <code class="sourceCode agda"><span class="dt">Set₁</span></code>, not the other way around.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Mon, 30 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-07-30-verified-avl.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Probabilistic Functional Programming</title>
    <link>https://doisinkidney.com/posts/2018-07-17-probability-presentation.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p><a href="/pdfs/prob-presentation.pdf">Here</a> are the slides for a short talk I gave to a reading group I’m in at Harvard today. The speaker notes are included in the pdf, code and the tex is available in the <a href="https://github.com/oisdk/prob-presentation">repository</a>.</p>
]]></description>
    <pubDate>Tue, 17 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-07-17-probability-presentation.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Probability 5 Ways</title>
    <link>https://doisinkidney.com/posts/2018-06-30-probability-5-ways.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 30, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Probability.html">Probability</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Ever since the famous pearl by <span class="citation" data-cites="erwig_functional_2006">Erwig and Kollmansberger (<a href="#ref-erwig_functional_2006">2006</a>)</span>, probabilistic programming with monads has been an interesting and diverse area in functional programming, with many different approaches.</p>
<p>I’m going to present five here, some of which I have not seen before.</p>
<h1 id="the-classic">The Classic</h1>
<p>As presented in the paper, a simple and elegant formulation of probability distributions looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    }</a></code></pre></div>
<p>It’s a list of possible events, each tagged with their probability of happening. Here’s the probability distribution representing a die roll, for instance:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">die ::</span> <span class="dt">Prob</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">die <span class="fu">=</span> [ (x, <span class="dv">1</span><span class="fu">/</span><span class="dv">6</span>) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>] ]</a></code></pre></div>
<p>The semantics can afford to be a little fuzzy: it doesn’t hugely matter if the probabilities don’t add up to 1 (you can still extract meaningful answers when they don’t). However, I can’t see a way in which either negative probabilities or an empty list would make sense. It would be nice if those states were unrepresentable.</p>
<p>Its monadic structure multiplies conditional events:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    fmap f xs <span class="fu">=</span> <span class="dt">Prob</span> [ (f x, p) <span class="fu">|</span> (x,p) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    </a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    pure x <span class="fu">=</span> <span class="dt">Prob</span> [(x,<span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    fs <span class="fu">&lt;*&gt;</span> xs</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        [ (f x,fp<span class="fu">*</span>xp)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        <span class="fu">|</span> (f,fp) <span class="ot">&lt;-</span> runProb fs</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        , (x,xp) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                     </a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    xs <span class="fu">&gt;&gt;=</span> f</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">        <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">        [ (y,xp<span class="fu">*</span>yp)</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">        <span class="fu">|</span> (x,xp) <span class="ot">&lt;-</span> runProb xs</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">        , (y,yp) <span class="ot">&lt;-</span> runProb (f x) ]</a></code></pre></div>
<p>In most of the examples, we’ll need a few extra functions in order for the types to be useful. First is support:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">support ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">support <span class="fu">=</span> fmap fst <span class="fu">.</span> runProb</a></code></pre></div>
<p>And second is expectation:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">expect p xs <span class="fu">=</span> sum [ p x <span class="fu">*</span> xp <span class="fu">|</span> (x,xp) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a></code></pre></div>
<p>It’s useful to be able to construct uniform distributions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">uniform xs <span class="fu">=</span> <span class="dt">Prob</span> [ (x,n) <span class="fu">|</span> x <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">%</span> toEnum (length xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb6-5" data-line-number="5">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  pure (x<span class="fu">+</span>y)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<h1 id="the-bells-and-whistles">The Bells and Whistles</h1>
<p>As elegant as the above approach is, it leaves something to be desired when it comes to efficiency. In particular, you’ll see a combinatorial explosion at every step. To demonstrate, let’s take the example above, using three-sided dice instead so it doesn’t take up too much space.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">example <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  pure (x<span class="fu">+</span>y)</a></code></pre></div>
<p>The probability table looks like this:</p>
<pre class="center"><code>2 1/9
3 2/9
4 1/3
5 2/9
6 1/9</code></pre>
<p>But the internal representation looks like this:</p>
<pre><code>2 1/9
3 1/9
4 1/9
3 1/9
4 1/9
5 1/9
4 1/9
5 1/9
6 1/9</code></pre>
<p>States are duplicated, because the implementation has no way of knowing that two outcomes are the same. We could collapse equivalent outcomes if we used a <code class="sourceCode haskell"><span class="dt">Map</span></code>, but then we can’t implement <code class="sourceCode haskell"><span class="dt">Functor</span></code>, <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, or <code class="sourceCode haskell"><span class="dt">Monad</span></code>. The types:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">    (&gt;&gt;=) ::</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>Don’t allow an <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint, which is what we’d need to remove duplicates. We can instead make our own classes which <em>do</em> allow constraints:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeFamilies     #-}</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Functor</span>(..),<span class="dt">Applicative</span>(..),<span class="dt">Monad</span>(..))</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Kind</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    <span class="kw">type</span> <span class="dt">Domain</span> f<span class="ot"> a ::</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    <span class="kw">type</span> <span class="dt">Domain</span> f a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="ot">    fmap ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-12" data-line-number="12"></a>
<a class="sourceLine" id="cb11-13" data-line-number="13"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    <span class="ot">{-# MINIMAL pure, liftA2 #-}</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="ot">    pure   ::</span> <span class="dt">Domain</span> f a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb11-16" data-line-number="16"><span class="ot">    liftA2 ::</span> <span class="dt">Domain</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">    </a>
<a class="sourceLine" id="cb11-18" data-line-number="18"><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">$</span>) </a>
<a class="sourceLine" id="cb11-20" data-line-number="20"></a>
<a class="sourceLine" id="cb11-21" data-line-number="21"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">fail<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">fail <span class="fu">=</span> error</a>
<a class="sourceLine" id="cb11-26" data-line-number="26"></a>
<a class="sourceLine" id="cb11-27" data-line-number="27">return<span class="ot"> ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Domain</span> f a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb11-28" data-line-number="28">return <span class="fu">=</span> pure</a></code></pre></div>
<p>This setup gets over a couple common annoyances in Haskell, like making <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html"><code class="sourceCode haskell"><span class="dt">Data.Set</span></code></a> a Monad:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Domain</span> <span class="dt">Set</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    fmap <span class="fu">=</span> Set.map</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    pure <span class="fu">=</span> Set.singleton</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    liftA2 f xs ys <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">        x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">        y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        pure (f x y)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    (<span class="fu">&gt;&gt;=</span>) <span class="fu">=</span> flip foldMap</a></code></pre></div>
<p>And, of course, the probability monad:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    {<span class="ot"> runProb ::</span> <span class="dt">Map</span> a <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    }</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    <span class="kw">type</span> <span class="dt">Domain</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    fmap f <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">.</span> Map.mapKeysWith (<span class="fu">+</span>) f <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    pure x <span class="fu">=</span> <span class="dt">Prob</span> (Map.singleton x <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    liftA2 f xs ys <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">      x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">      y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">      pure (f x y)</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      </a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Prob</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">    mempty <span class="fu">=</span> <span class="dt">Prob</span> Map.empty</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">    mappend (<span class="dt">Prob</span> xs) (<span class="dt">Prob</span> ys) <span class="fu">=</span> <span class="dt">Prob</span> (Map.unionWith (<span class="fu">+</span>) xs ys)</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">    <span class="dt">Prob</span> xs <span class="fu">&gt;&gt;=</span> f</a>
<a class="sourceLine" id="cb13-22" data-line-number="22">        <span class="fu">=</span> Map.foldMapWithKey ((<span class="dt">Prob</span> <span class="fu">.</span>) <span class="fu">.</span> flip (Map.map <span class="fu">.</span> (<span class="fu">*</span>)) <span class="fu">.</span> runProb <span class="fu">.</span> f) xs</a>
<a class="sourceLine" id="cb13-23" data-line-number="23"></a>
<a class="sourceLine" id="cb13-24" data-line-number="24">support <span class="fu">=</span> Map.keys <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-25" data-line-number="25"></a>
<a class="sourceLine" id="cb13-26" data-line-number="26">expect p <span class="fu">=</span> getSum <span class="fu">.</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Sum</span> (p k <span class="fu">*</span> v)) <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-27" data-line-number="27"></a>
<a class="sourceLine" id="cb13-28" data-line-number="28">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a>
<a class="sourceLine" id="cb13-29" data-line-number="29"></a>
<a class="sourceLine" id="cb13-30" data-line-number="30">uniform xs <span class="fu">=</span> <span class="dt">Prob</span> (Map.fromList [ (x,n) <span class="fu">|</span> x <span class="ot">&lt;-</span> xs ])</a>
<a class="sourceLine" id="cb13-31" data-line-number="31">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-32" data-line-number="32">    n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">%</span> toEnum (length xs)</a>
<a class="sourceLine" id="cb13-33" data-line-number="33"></a>
<a class="sourceLine" id="cb13-34" data-line-number="34">ifThenElse <span class="dt">True</span> t _ <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb13-35" data-line-number="35">ifThenElse <span class="dt">False</span> _ f <span class="fu">=</span> f</a>
<a class="sourceLine" id="cb13-36" data-line-number="36"></a>
<a class="sourceLine" id="cb13-37" data-line-number="37">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb13-38" data-line-number="38"></a>
<a class="sourceLine" id="cb13-39" data-line-number="39"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-40" data-line-number="40">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb13-41" data-line-number="41">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb13-42" data-line-number="42">  pure (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb13-43" data-line-number="43"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<h1 id="free">Free</h1>
<p>Coming up with the right implementation all at once is quite difficult: luckily, there are more general techniques for designing DSLs that break the problem into smaller parts, which also give us some insight into the underlying composition of the probability monad.</p>
<p>The technique relies on an algebraic concept called “free objects”. A free object for some class is a minimal implementation of that class. The classic example is lists: they’re the free monoid. Monoid requires that you have an additive operation, an empty element, and that the additive operation be associative. Lists have all of these things: what makes them <em>free</em>, though, is that they have nothing else. For instance, the additive operation on lists (concatenation) isn’t commutative: if it was, they wouldn’t be the free monoid any more, because they satisfy an extra law that’s not in monoid.</p>
<p>For our case, we can use the free monad: this takes a functor and gives it a monad instance, in a way we know will satisfy all the laws. This encoding is used in several papers <span class="citation" data-cites="scibior_practical_2015 larsen_memory_2011">(Ścibior, Ghahramani, and Gordon <a href="#ref-scibior_practical_2015">2015</a>; Larsen <a href="#ref-larsen_memory_2011">2011</a>)</span>.</p>
<p>The idea is to first figure out what primitive operation you need. We’ll use weighted choice:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">choose ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">choose <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>Then you encode it as a functor:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Choose</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Choose</span> <span class="dt">Rational</span> a a</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a></code></pre></div>
<p>We’ll say the left-hand-choice has chance <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>, and the right-hand <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">1-p</annotation></semantics></math>. Then, you just wrap it in the free monad:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Choose</span></a></code></pre></div>
<p>And you already have a monad instance. Support comes from the <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Foldable.html#v:toList"><code class="sourceCode haskell"><span class="dt">Foldable</span></code></a> instance:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">support ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">support <span class="fu">=</span> toList</a></code></pre></div>
<p>Expectation is an “interpreter” for the DSL:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">expect p <span class="fu">=</span> iter f <span class="fu">.</span> fmap p</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    f (<span class="dt">Choose</span> c l r) <span class="fu">=</span> l <span class="fu">*</span> c <span class="fu">+</span> r <span class="fu">*</span> (<span class="dv">1</span><span class="fu">-</span>c)</a></code></pre></div>
<p>For building up the tree, we can use Huffman’s algorithm:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">fromList ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">fromList p <span class="fu">=</span> go <span class="fu">.</span> foldMap (\x <span class="ot">-&gt;</span> singleton (p x) (<span class="dt">Pure</span> x))</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go xs <span class="fu">=</span> <span class="kw">case</span> minView xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;empty list&quot;</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="dt">Just</span> ((xp,x),ys) <span class="ot">-&gt;</span> <span class="kw">case</span> minView ys <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        <span class="dt">Just</span> ((yp,y),zs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">          go (insertHeap (xp<span class="fu">+</span>yp) (<span class="dt">Free</span> (<span class="dt">Choose</span> (xp<span class="fu">/</span>(xp<span class="fu">+</span>yp)) x y)) zs)</a></code></pre></div>
<p>And finally, it gets the same notation as before:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">uniform <span class="fu">=</span> fromList (const <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  pure (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<p>One of the advantages of the free approach is that it’s easy to define multiple interpreters. We could, for instance, write an interpreter that constructs a diagram:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> drawTree ((,) <span class="fu">&lt;$&gt;</span> uniform <span class="st">&quot;abc&quot;</span> <span class="fu">&lt;*&gt;</span> uniform <span class="st">&quot;de&quot;</span>)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">           ┌(<span class="ch">&#39;c&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">     ┌<span class="dv">1</span> <span class="fu">%</span> 2┤</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">     │     └(<span class="ch">&#39;c&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="dv">1</span> <span class="fu">%</span> 3┤</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">     │           ┌(<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">     │     ┌<span class="dv">1</span> <span class="fu">%</span> 2┤</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">     │     │     └(<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">     └<span class="dv">1</span> <span class="fu">%</span> 2┤</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">           │     ┌(<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">           └<span class="dv">1</span> <span class="fu">%</span> 2┤</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">                 └(<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a></code></pre></div>
<h1 id="final">Final</h1>
<p>There’s a lot to be said about free objects in category theory, also. Specifically, they’re related to initial and terminal (also called final) objects. The encoding above is initial, the final encoding is simply <code class="sourceCode haskell"><span class="dt">Cont</span></code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="fu">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">Cont</span> <span class="dt">Rational</span></a></code></pre></div>
<p>Here, also, we get the monad instance for free. In contrast to previously, expect is free:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">expect <span class="fu">=</span> flip runCont</a></code></pre></div>
<p>Support, though, isn’t possible.</p>
<p>This version is also called the Giry monad: there’s a deep and fascinating theory behind it, which I probably won’t be able to do justice to here. Check out Jared Tobin’s post <span class="citation" data-cites="tobin_implementing_2017">(<a href="#ref-tobin_implementing_2017">2017</a>)</span> for a good deep dive on it.</p>
<h1 id="cofree">Cofree</h1>
<p>The branching structure of the tree captures the semantics of the probability monad well, but it doesn’t give us much insight into the original implementation. The question is, how can we deconstruct this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)]</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    }</a></code></pre></div>
<p>Eric Kidd <span class="citation" data-cites="kidd_build_2007">(<a href="#ref-kidd_build_2007">2007</a>)</span> pointed out that the monad is the composition of the writer and list monads:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</a></code></pre></div>
<p>but that seems unsatisfying: in contrast to the tree-based version, we don’t encode any branching structure, we’re able to have empty distributions, and it has the combinatorial explosion problem.</p>
<p>Adding a weighting to nondeterminism is encapsulated more concretely by the <code class="sourceCode haskell"><span class="dt">ListT</span></code> transformer. It looks like this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ListT</span> m a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ListT</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    {<span class="ot"> runListT ::</span> m (<span class="dt">Maybe</span> (a, <span class="dt">ListT</span> m a))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    }</a></code></pre></div>
<p>It’s a cons-list, with an effect before every layer<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>While this can be used to give us the monad we need, I’ve found that something more like this fits the abstraction better:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ListT</span> m a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ListT</span> a (m (<span class="dt">Maybe</span> (<span class="dt">ListT</span> m a)))</a></code></pre></div>
<p>It’s a nonempty list, with the first element exposed. Turns out this is very similar to the cofree comonad:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>Just like the initial free encoding, we can start with a primitive operation:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Perhaps</span> a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Impossible</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">WithChance</span> <span class="dt">Rational</span> a</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a></code></pre></div>
<p>And we get all of our instances as well:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    {<span class="ot"> runProb ::</span> <span class="dt">Cofree</span> <span class="dt">Perhaps</span> a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    } <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7">    extract (<span class="dt">Prob</span> xs) <span class="fu">=</span> extract xs</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    duplicate (<span class="dt">Prob</span> xs) <span class="fu">=</span> <span class="dt">Prob</span> (fmap <span class="dt">Prob</span> (duplicate xs))</a>
<a class="sourceLine" id="cb30-9" data-line-number="9"></a>
<a class="sourceLine" id="cb30-10" data-line-number="10"><span class="ot">foldProb ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">foldProb f b <span class="fu">=</span> r <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-13" data-line-number="13">    r (x <span class="fu">:&lt;</span> <span class="dt">Impossible</span>) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb30-14" data-line-number="14">    r (x <span class="fu">:&lt;</span> <span class="dt">WithChance</span> p xs) <span class="fu">=</span> f x p (r xs)</a>
<a class="sourceLine" id="cb30-15" data-line-number="15"></a>
<a class="sourceLine" id="cb30-16" data-line-number="16"><span class="ot">uniform ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-17" data-line-number="17">uniform (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Prob</span> (coiterW f (<span class="dt">EnvT</span> (length xs) (x <span class="fu">:|</span> xs)))</a>
<a class="sourceLine" id="cb30-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-19" data-line-number="19">    f (<span class="dt">EnvT</span> <span class="dv">0</span> (_ <span class="fu">:|</span> [])) <span class="fu">=</span> <span class="dt">Impossible</span></a>
<a class="sourceLine" id="cb30-20" data-line-number="20">    f (<span class="dt">EnvT</span> n (_ <span class="fu">:|</span> (y<span class="fu">:</span>ys))) </a>
<a class="sourceLine" id="cb30-21" data-line-number="21">        <span class="fu">=</span> <span class="dt">WithChance</span> (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (<span class="dt">EnvT</span> (n <span class="fu">-</span> <span class="dv">1</span>) (y<span class="fu">:|</span>ys))</a>
<a class="sourceLine" id="cb30-22" data-line-number="22"></a>
<a class="sourceLine" id="cb30-23" data-line-number="23"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb30-24" data-line-number="24">expect p <span class="fu">=</span> foldProb f p</a>
<a class="sourceLine" id="cb30-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-26" data-line-number="26">    f x n xs <span class="fu">=</span> (p x <span class="fu">*</span> n <span class="fu">+</span> xs) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-27" data-line-number="27"></a>
<a class="sourceLine" id="cb30-28" data-line-number="28"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb30-29" data-line-number="29">probOf p <span class="fu">=</span> expect (\x <span class="ot">-&gt;</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb30-30" data-line-number="30"></a>
<a class="sourceLine" id="cb30-31" data-line-number="31"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-32" data-line-number="32">    pure x <span class="fu">=</span> <span class="dt">Prob</span> (x <span class="fu">:&lt;</span> <span class="dt">Impossible</span>)</a>
<a class="sourceLine" id="cb30-33" data-line-number="33">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap</a>
<a class="sourceLine" id="cb30-34" data-line-number="34">    </a>
<a class="sourceLine" id="cb30-35" data-line-number="35"><span class="ot">append ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-36" data-line-number="36">append <span class="fu">=</span> foldProb f (\x y <span class="ot">-&gt;</span>  <span class="dt">Prob</span> <span class="fu">.</span> (x <span class="fu">:&lt;</span>) <span class="fu">.</span> <span class="dt">WithChance</span> y <span class="fu">.</span> runProb)</a>
<a class="sourceLine" id="cb30-37" data-line-number="37">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-38" data-line-number="38">    f e r a p <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">.</span> (e <span class="fu">:&lt;</span>) <span class="fu">.</span> <span class="dt">WithChance</span> ip <span class="fu">.</span> runProb <span class="fu">.</span> a op</a>
<a class="sourceLine" id="cb30-39" data-line-number="39">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-40" data-line-number="40">        ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-41" data-line-number="41">        op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-42" data-line-number="42"></a>
<a class="sourceLine" id="cb30-43" data-line-number="43"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-44" data-line-number="44">    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldProb (append <span class="fu">.</span> f) f xs</a></code></pre></div>
<p>We see here that we’re talking about gambling-style odds, rather than probability. I wonder if the two representations are dual somehow?</p>
<p>The application of comonads to streams (<code class="sourceCode haskell"><span class="dt">ListT</span></code>) has been explored before <span class="citation" data-cites="uustalu_essence_2005">(Uustalu and Vene <a href="#ref-uustalu_essence_2005">2005</a>)</span>; I wonder if there are any insights to be gleaned from this particular probability comonad.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in Haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.”</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory Efficient Implementation of Probability Monads.”</p>
</div>
<div id="ref-scibior_practical_2015">
<p>Ścibior, Adam, Zoubin Ghahramani, and Andrew D. Gordon. 2015. “Practical Probabilistic Programming with Monads.” In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 50:165–176. Haskell ’15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804317">10.1145/2804302.2804317</a>.</p>
</div>
<div id="ref-tobin_implementing_2017">
<p>Tobin, Jared. 2017. “Implementing the Giry Monad.” <em>jtobin.io</em>.</p>
</div>
<div id="ref-uustalu_essence_2005">
<p>Uustalu, Tarmo, and Varmo Vene. 2005. “The Essence of Dataflow Programming.” In <em>Proceedings of the Third Asian Conference on Programming Languages and Systems</em>, 2–18. APLAS’05. Berlin, Heidelberg: Springer-Verlag. doi:<a href="https://doi.org/10.1007/11575467_2">10.1007/11575467_2</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Note this is <em>not</em> the same as the <code class="sourceCode haskell"><span class="dt">ListT</span></code> in <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-List.html">transformers</a>; instead it’s a “<a href="https://wiki.haskell.org/ListT_done_right">ListT done right</a>”.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 30 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-30-probability-5-ways.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Scheduling Effects</title>
    <link>https://doisinkidney.com/posts/2018-06-23-scheduling-effects.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 23, 2018
</div>
<div class="info">
    
        Part 4 of a <a href="/series/Breadth-First%20Traversals.html">4-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>After the <a href="2018-06-03-breadth-first-traversals-in-too-much-detail.html">last post</a>, Noah Easterly pointed me to their <a href="https://hackage.haskell.org/package/tree-traversals">tree-traversals library</a>, and in particular the <a href="https://hackage.haskell.org/package/tree-traversals-0.1.0.0/docs/Control-Applicative-Phases.html#t:Phases"><code class="sourceCode haskell"><span class="dt">Phases</span></code></a> applicative transformer. It allows you to batch applicative effects to be run together: for the breadth-first traversal, we can batch the effects from each level together, giving us a lovely short solution to the problem.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">breadthFirst c <span class="fu">=</span> runPhasesForwards <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    go (x<span class="fu">:&lt;</span>xs) <span class="fu">=</span> liftA2 (<span class="fu">:&lt;</span>) (now (c x)) (delay (traverse go xs))</a></code></pre></div>
<p>In my efforts to speed this implementation up, I came across a wide and interesting literature on scheduling effects, which I’ll go through a little here.</p>
<h1 id="coroutines">Coroutines</h1>
<p>The first thing that jumps to mind, for me, when I think of “scheduling” is coroutines. These are constructs that let you finely control the order of execution of effects. They’re well explored in Haskell by now, and most libraries will let you do something like the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">oneThenTwo <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  liftIO <span class="fu">$</span> print <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  delay <span class="fu">$</span> liftIO <span class="fu">$</span> print <span class="dv">2</span></a></code></pre></div>
<p>We first print <code>1</code>, then, after a delay, we print <code>2</code>. The <code class="sourceCode haskell">delay</code> doesn’t make a difference if we just run the whole thing:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> retract oneThenTwo</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="dv">2</span></a></code></pre></div>
<p>But you can see its effect when we use the <code class="sourceCode haskell">interleave</code> combinator:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> retract <span class="fu">$</span> interleave (replicate <span class="dv">3</span> oneThenTwo)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="dv">2</span></a></code></pre></div>
<p>Hopefully you can see how useful this might be, and the similarity to the <code class="sourceCode haskell"><span class="dt">Phases</span></code> construction.</p>
<p>The genealogy of most coroutine libraries in Haskell seems to trace back to <span class="citation" data-cites="blazevic_coroutine_2011">Blažević (<a href="#ref-blazevic_coroutine_2011">2011</a>)</span> or <span class="citation" data-cites="kiselyov_iteratees_2012">Kiselyov (<a href="#ref-kiselyov_iteratees_2012">2012</a>)</span>: the implementation I have been using in these past few examples (<a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Iter.html"><code>IterT</code></a>) comes from a slightly different place. Let’s take a quick detour to explore it a little.</p>
<h1 id="partiality">Partiality</h1>
<p>In functional programming, there are several constructions for modeling error-like states: <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for your nulls, <code class="sourceCode haskell"><span class="dt">Either</span></code> for your exceptions. What separates these approaches from the “unsafe” variants (null pointers, unchecked exceptions) is that we can <em>prove</em>, in the type system, that the error case is handled correctly.</p>
<p>Conspicuously absent from the usual toolbox for modeling partiality is a way to model <em>nontermination</em>. At first glance, it may seem strange to attempt to do so in Haskell. After all, if I have a function of type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>I can prove that I won’t throw any errors (with <code class="sourceCode haskell"><span class="dt">Either</span></code>, that is), because the type <code class="sourceCode haskell"><span class="dt">Int</span></code> doesn’t contain <code class="sourceCode haskell"><span class="dt">Left</span> _</code>. I’ve also proved, miraculously, that I won’t make any null dereferences, because <code class="sourceCode haskell"><span class="dt">Int</span></code> also doesn’t contain <code class="sourceCode haskell"><span class="dt">Nothing</span></code>. I <em>haven’t</em> proved, however, that I won’t loop infinitely, because (in Haskell), <code class="sourceCode haskell"><span class="dt">Int</span></code> absolutely <em>does</em> contain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>.</p>
<p>So we’re somewhat scuppered. On the other hand, While we can’t <em>prove</em> termination in Haskell, we can:</p>
<ol>
<li>Model it.</li>
<li>Prove it in something else.</li>
</ol>
<p>Which is exactly what Venanzio Capretta did in the fascinating (and quite accessible) talk “Partiality is an effect” <span class="citation" data-cites="capretta_partiality_2004">(Capretta, Altenkirch, and Uustalu <a href="#ref-capretta_partiality_2004">2004</a>)</span><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>The monad in question looks like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Iter</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Now</span> a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Later</span> (<span class="dt">Inf</span> (<span class="dt">Iter</span> a))</a></code></pre></div>
<p>We’re writing in Idris for the time being, so that we can prove termination and so on. The “recursive call” to <code class="sourceCode haskell"><span class="dt">Iter</span></code> is guarded by the <code class="sourceCode haskell"><span class="dt">Inf</span></code> type: this turns on a different kind of totality checking in the compiler. Usually, Idris will prevent you from constructing infinite values. But that’s exactly what we want to do here. Take the little-known function <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:until"><code class="sourceCode haskell">until</code></a>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">until<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>It’s clearly not necessarily total, and the totality checker will complain as such when we try and implement it directly:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">until</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">until p f x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> x <span class="kw">else</span> until p f (f x)</a></code></pre></div>
<p>But we can use <code class="sourceCode haskell"><span class="dt">Iter</span></code> to model that possible totality:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">until</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Iter</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">until p f x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dt">Now</span> x <span class="kw">else</span> <span class="dt">Later</span> (until p f (f x))</a></code></pre></div>
<p>Of course, nothing’s for free: when we get the ability to construct infinite values, we lose the ability to consume them.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">run</span> <span class="ot">:</span> <span class="dt">Iter</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">run (<span class="dt">Now</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">run (<span class="dt">Later</span> x) <span class="fu">=</span> run x</a></code></pre></div>
<p>We get an error on the <code class="sourceCode haskell">run</code> function. However, as you would expect, we can run <em>guarded</em> iteration: iteration up until some finite point.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">runUntil</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Iter</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">runUntil <span class="dt">Z</span> <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">runUntil (<span class="dt">S</span> n) (<span class="dt">Now</span> x) <span class="fu">=</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">runUntil (<span class="dt">S</span> n) (<span class="dt">Later</span> x) <span class="fu">=</span> runUntil n x</a></code></pre></div>
<p>Making our way back to Haskell, we must first—as is the law—add a type parameter, and upgrade our humble monad to a monad transformer:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">IterT</span> m a <span class="fu">=</span> <span class="dt">IterT</span> {<span class="ot"> runIterT ::</span> m (<span class="dt">Either</span> a (<span class="dt">IterT</span> m a)) }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Iter</span> <span class="fu">=</span> <span class="dt">IterT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>The semantic meaning of the extra <code class="sourceCode haskell">m</code> here is interesting: each layer adds not just a recursive step, or a single iteration, but a single effect. Interpreting things in this way gets us back to the original goal:</p>
<h1 id="scheduling">Scheduling</h1>
<p>The <code class="sourceCode haskell"><span class="dt">Later</span></code> constructor above can be translated to a <code class="sourceCode haskell">delay</code> function on the transformer:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">delay <span class="fu">=</span> <span class="dt">IterT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Right</span></a></code></pre></div>
<p>And using this again, we can write the following incredibly short definition for <code class="sourceCode haskell">unfoldTreeM_BF</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">unfoldTreeM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">unfoldTreeM_BF f <span class="fu">=</span> retract <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    go b <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      (x,xs) <span class="ot">&lt;-</span> lift (f b)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      fmap (<span class="dt">Node</span> x) (interleave (map (delay <span class="fu">.</span> go) xs))</a></code></pre></div>
<h1 id="applicative">Applicative</h1>
<p>It would be nice to bring this back to traversals, but alas, <code class="sourceCode haskell"><span class="dt">IterT</span></code> is pretty monad-centric. What’s more, if it’s analogous to <code class="sourceCode haskell"><span class="dt">Phases</span></code> it certainly doesn’t look like it:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Phases</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="dt">Lift</span><span class="ot"> ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">  (:&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f b</a></code></pre></div>
<p>However, in the documentation for <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Iter.html#t:IterT"><code class="sourceCode haskell"><span class="dt">IterT</span></code></a>, there’s the following little note:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">IterT</span> <span class="fu">~</span> <span class="dt">FreeT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">FreeT</span></code> is the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Free.html">free monad transformer</a>. This seems to strongly hint that we could get the same thing for applicatives with <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Applicative-Trans-Free.html"><code class="sourceCode haskell"><span class="dt">ApT</span></code></a>. Let’s try it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Phases</span> f a <span class="fu">=</span> <span class="dt">Phases</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">    {<span class="ot"> runPhases ::</span> <span class="dt">ApT</span> <span class="dt">Identity</span> f a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">Applicative</span></code> instance is a little hairy, but it <em>seems</em> correct:</p>
<details>
<p><summary> Applicative Instance </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    pure <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> pure</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    liftA2 f&#39; (<span class="dt">Phases</span> (<span class="dt">ApT</span> xs&#39;)) (<span class="dt">Phases</span> (<span class="dt">ApT</span> ys&#39;)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">        <span class="dt">Phases</span> (<span class="dt">ApT</span> (liftA2 (go f&#39;) xs&#39; ys&#39;))</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">        go</a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">            ::</span> <span class="ot">∀</span> a b c<span class="fu">.</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">               (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f a</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f b</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f c</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">        go f (<span class="dt">Pure</span> x) ys <span class="fu">=</span> fmap (f x) ys</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">        go f xs (<span class="dt">Pure</span> y) <span class="fu">=</span> fmap (<span class="ot">`f`</span> y) xs</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">        go f (<span class="dt">Ap</span> x (<span class="dt">ApT</span> xs)) (<span class="dt">Ap</span> y (<span class="dt">ApT</span> ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">            <span class="dt">Ap</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">                (liftA2 (,) x y)</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">                (<span class="dt">ApT</span> (liftA2 (go (\xx yy <span class="ot">-&gt;</span> uncurry f <span class="fu">.</span> (xx <span class="fu">***</span> yy))) xs ys))</a></code></pre></div>
</details>
<p>(on a side note: thank <em>goodness</em> for <code class="sourceCode haskell">liftA2</code> finally getting into <code class="sourceCode haskell"><span class="dt">Applicative</span></code>)</p>
<p>And we get all the normal combinators:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">delay ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">delay <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">ApT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Ap</span> (pure ()) <span class="fu">.</span> fmap const <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">lift ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">lift <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> liftApO</a></code></pre></div>
<p>The issue comes with running the thing at the end: <code class="sourceCode haskell"><span class="dt">Monad</span></code> creeps back in.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">retract ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">retract <span class="fu">=</span> fmap (runIdentity <span class="fu">.</span> retractAp) <span class="fu">.</span> joinApT <span class="fu">.</span> runPhases</a></code></pre></div>
<p>Because the effects are all layered on top of each other, you need to flatten them out at the end, which requires <code class="sourceCode haskell">join</code>. Mind you, it does work: it’s just not as general as it could be.</p>
<p>All’s not lost, though. Turns out, we never needed the transformer in the first place: we could just define the different applicative instance straight off.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Phases</span> f a <span class="fu">=</span> <span class="dt">Phases</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    {<span class="ot"> runPhases ::</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">         <span class="dt">Applicative</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    pure <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">    liftA2 f&#39; (<span class="dt">Phases</span> xs&#39;) (<span class="dt">Phases</span> ys&#39;) <span class="fu">=</span> <span class="dt">Phases</span> (go f&#39; xs&#39; ys&#39;)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"><span class="ot">        go ::</span> <span class="ot">∀</span> a b c<span class="fu">.</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">              (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f b</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f c</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">        go f (<span class="dt">Pure</span> x) ys <span class="fu">=</span> fmap (f x) ys</a>
<a class="sourceLine" id="cb21-16" data-line-number="16">        go f xs (<span class="dt">Pure</span> y) <span class="fu">=</span> fmap (<span class="ot">`f`</span> y) xs</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">        go f (<span class="dt">Ap</span> x xs) (<span class="dt">Ap</span> y ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-18" data-line-number="18">            <span class="dt">Ap</span></a>
<a class="sourceLine" id="cb21-19" data-line-number="19">                (liftA2 (,) x y)</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">                (go (\xx yy <span class="ot">-&gt;</span> uncurry f <span class="fu">.</span> (xx <span class="fu">***</span> yy)) xs ys)</a>
<a class="sourceLine" id="cb21-21" data-line-number="21"></a>
<a class="sourceLine" id="cb21-22" data-line-number="22"><span class="ot">delay ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb21-23" data-line-number="23">delay <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">Ap</span> (pure ()) <span class="fu">.</span> fmap const <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb21-24" data-line-number="24"></a>
<a class="sourceLine" id="cb21-25" data-line-number="25"><span class="ot">retract ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb21-26" data-line-number="26">retract <span class="fu">=</span> retractAp <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb21-27" data-line-number="27"></a>
<a class="sourceLine" id="cb21-28" data-line-number="28"><span class="ot">lift ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb21-29" data-line-number="29">lift <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> liftAp</a></code></pre></div>
<h1 id="more-coroutines">More Coroutines</h1>
<p>In the wonderful article Coroutine Pipelines <span class="citation" data-cites="blazevic_coroutine_2011">(Blažević <a href="#ref-blazevic_coroutine_2011">2011</a>)</span>, several different threads on coroutine-like constructions are unified. What I’ve demonstrated above isn’t yet as powerful as what you might see in a full coroutine library: ideally, you’d want generators and sinks. As it turns out, when we look back at the note from <code class="sourceCode haskell"><span class="dt">IterT</span></code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="dt">IterT</span> <span class="fu">~</span> <span class="dt">FreeT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>We can get both of those other constructs by swapping out <code class="sourceCode haskell"><span class="dt">Identity</span></code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="dt">Generator</span> a <span class="fu">=</span> <span class="dt">FreeT</span> ((,) a)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="dt">Sink</span> a <span class="fu">=</span> <span class="dt">FreeT</span> ((<span class="ot">-&gt;</span>) a)</a></code></pre></div>
<p>(<code class="sourceCode haskell"><span class="dt">Sink</span></code> is usually called an <code class="sourceCode haskell"><span class="dt">Iteratee</span></code>)</p>
<p>This is the fundamental abstraction that underlies things like the pipes library <span class="citation" data-cites="gonzalez_pipes_2018">(Gonzalez <a href="#ref-gonzalez_pipes_2018">2018</a>)</span>.</p>
<h1 id="interleaving">Interleaving</h1>
<p>The only missing part from the first coroutine example by now is <code class="sourceCode haskell">interleave</code>. In the free library, it has the following signature:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">interleave ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [<span class="dt">IterT</span> m a] <span class="ot">-&gt;</span> <span class="dt">IterT</span> m [a]</a></code></pre></div>
<p>But we should be able to spot that, really, it’s a traversal. And, as a traversal, it should rely on some underlying <code class="sourceCode haskell"><span class="dt">Applicative</span></code> instance. Let’s try and come up with one:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Parallel</span> m f a <span class="fu">=</span> <span class="dt">Parallel</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    {<span class="ot"> runParallel ::</span> <span class="dt">FreeT</span> m f a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    }</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">         <span class="dt">Functor</span> (<span class="dt">Parallel</span> m f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    fmap f <span class="fu">=</span> <span class="dt">Parallel</span> <span class="fu">.</span> <span class="dt">FreeT</span> <span class="fu">.</span> fmap go <span class="fu">.</span> runFreeT <span class="fu">.</span> runParallel</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9">        go <span class="fu">=</span> bimap f (<span class="dt">FreeT</span> <span class="fu">.</span> fmap go <span class="fu">.</span> runFreeT)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">         <span class="dt">Applicative</span> (<span class="dt">Parallel</span> m f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">    pure <span class="fu">=</span> <span class="dt">Parallel</span> <span class="fu">.</span> <span class="dt">FreeT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">    <span class="dt">Parallel</span> fs&#39; <span class="fu">&lt;*&gt;</span> <span class="dt">Parallel</span> xs&#39; <span class="fu">=</span> <span class="dt">Parallel</span> (unw fs&#39; xs&#39;)</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">        unw (<span class="dt">FreeT</span> fs) (<span class="dt">FreeT</span> xs) <span class="fu">=</span> <span class="dt">FreeT</span> (liftA2 go fs xs)</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">        go (<span class="dt">Pure</span> f) <span class="fu">=</span> bimap f (runParallel <span class="fu">.</span> fmap f <span class="fu">.</span> <span class="dt">Parallel</span>)</a>
<a class="sourceLine" id="cb25-18" data-line-number="18">        go (<span class="dt">Free</span> fs) <span class="fu">=</span> <span class="dt">Free</span> <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb25-19" data-line-number="19">            <span class="dt">Pure</span> x <span class="ot">-&gt;</span> fmap (runParallel <span class="fu">.</span> fmap (<span class="fu">$</span>x) <span class="fu">.</span> <span class="dt">Parallel</span>) fs</a>
<a class="sourceLine" id="cb25-20" data-line-number="20">            <span class="dt">Free</span> xs <span class="ot">-&gt;</span> liftA2 unw fs xs</a></code></pre></div>
<p>Now, interleave is just <code class="sourceCode haskell">sequenceA</code>!</p>
<h1 id="applicatives-again">Applicatives, Again</h1>
<p>So we can see that there’s a “parallel” applicative for both the free monad and the free applicative. To try and understand this type a little better, we can leverage our intuition about a much simpler, more familiar setting: lists. There’s an interesting similarity between lists and the free monad: <code class="sourceCode haskell"><span class="dt">FreeT</span> ((,) a)</code>) looks a lot like “<a href="https://wiki.haskell.org/ListT_done_right"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>” (so much so, in fact, that most coroutine libraries provide their own version of it). More concretely, list also has a famous “parallel” applicative: <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Applicative.html#t:ZipList"><code class="sourceCode haskell"><span class="dt">ZipList</span></code></a>!</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ZipList</span> a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ZipList</span> </a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    {<span class="ot"> getZipList ::</span> [a]</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"></a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">ZipList</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  pure <span class="fu">=</span> <span class="dt">ZipList</span> <span class="fu">.</span> repeat</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  liftA2 f (<span class="dt">ZipList</span> xs) (<span class="dt">ZipList</span> ys) <span class="fu">=</span> <span class="dt">ZipList</span> (zipWith f xs ys)</a></code></pre></div>
<p>We’ll use some of our knowledge about <code class="sourceCode haskell"><span class="dt">ZipList</span></code> to help us in the next section.</p>
<h1 id="timekeeping">Timekeeping</h1>
<p>We’ve seen that efforts to model both coroutines and partiality end up in the same neighborhood: there’s yet another way to get there, which seems (at first) almost the opposite of the second. It starts with a blog post from Conor McBride <span class="citation" data-cites="mcbride_time_2009">(<a href="#ref-mcbride_time_2009">2009</a>)</span> called “Time flies like an applicative functor”. Curiously, here too breadth-first labeling is the focus. Remember first the lovely circular solution from <span class="citation" data-cites="jones_linear-time_1993-1">(<span class="citeproc-not-found" data-reference-id="jones_linear-time_1993-1"><strong>???</strong></span>)</span>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="ot">relabel ::</span> <span class="dt">Tree</span> x <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> (<span class="dt">Tree</span> a, [[a]])</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">relabel <span class="dt">Leaf</span> xss <span class="fu">=</span> (<span class="dt">Leaf</span>,xss)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">relabel (<span class="dt">Node</span> _ l r) ((x<span class="fu">:</span>xs)<span class="fu">:</span>xss0) <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  <span class="kw">let</span> (l&#39;,xss1) <span class="fu">=</span> relabel l xss0</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">      (r&#39;,xss2) <span class="fu">=</span> relabel r xss1</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="kw">in</span> (<span class="dt">Node</span> x l&#39; r&#39;,xs<span class="fu">:</span>xss2)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">bflabel ::</span> <span class="dt">Tree</span> x <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">bflabel tr xs <span class="fu">=</span> u</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-13" data-line-number="13">    (u,xss) <span class="fu">=</span> relabel tr (xs<span class="fu">:</span>xss)</a></code></pre></div>
<p>As lovely as it is, spare a thought for the poor totality checker: it’s hard to imagine how it would even <em>start</em> to show that something so lazy and circular would terminate. <code class="sourceCode haskell"><span class="dt">IterT</span></code> won’t help us here, either: it can help us express programs that <em>might</em> diverge, not weird-looking ones that definitely won’t.</p>
<p>The solution presented is a type (<code class="sourceCode haskell"><span class="dt">De</span></code>) which has a limited set of combinators: a fixpoint (<code class="sourceCode haskell"><span class="ot">fix ::</span> (<span class="dt">De</span> x <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</code>), and an applicative instance. As long as all problematic recursive calls are instead expressed using those combinators, the termination checker should be satisfied.</p>
<p><code class="sourceCode haskell"><span class="dt">De</span></code> can be thought of as a “delay” wrapper. Values of type <code class="sourceCode haskell"><span class="dt">De</span> a</code> are one step in the future, <code class="sourceCode haskell"><span class="dt">De</span> (<span class="dt">De</span> a)</code> are two, and so on. This idea was later expanded upon in <span class="citation" data-cites="atkey_how_2011">Atkey (<a href="#ref-atkey_how_2011">2011</a>)</span> and <span class="citation" data-cites="atkey_productive_2013">Atkey and McBride (<a href="#ref-atkey_productive_2013">2013</a>)</span> to <em>clock variables</em>. Instead of types with a delay, types are tagged with how much more time they have (something like “fuel” in the Idris sense, maybe). So a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle></msup><annotation encoding="application/x-tex">a^\mathsf{K}</annotation></semantics></math> is tagged with time <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math>, effectively meaning “I have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> productive steps left before I diverge”. “Productive steps” will mean something different for every data type: for lists, it could mean that it can produce up until the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math>th cons-cell. In the paper <span class="citation" data-cites="atkey_productive_2013">(Atkey and McBride <a href="#ref-atkey_productive_2013">2013</a>)</span> this is fleshed out a little more, with fixpoint combinators and so on. As a concrete example, take the type of the cons operator on streams:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Cons</mtext><mo>:</mo><mtext mathvariant="normal">a</mtext><mo>→</mo><msup><mtext mathvariant="normal">Stream a</mtext><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle></msup><mo>→</mo><msup><mtext mathvariant="normal">Stream a</mtext><mrow><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
\text{Cons} : \text{a}
\rightarrow \text{Stream a}^\mathsf{K}
\rightarrow \text{Stream a}^{\mathsf{K}+1}
\end{equation}</annotation></semantics></math>
<p>It increments the clock on the type, saying that it has one more productive step than it did before. This is kind of the opposite of a “delay”: previously, the scheduling types have meant “this is available <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> number of steps in the future” rather than “this is available for another <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> steps”. We can still describe delays in this system, though, using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mo>⊳</mo><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle></msup><annotation encoding="application/x-tex">\rhd^\mathsf{K}</annotation></semantics></math> notation:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Cons</mtext><mo>:</mo><mtext mathvariant="normal">a</mtext><mo>→</mo><mover><mo>⊳</mo><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle></mover><mtext mathvariant="normal">Stream a</mtext><mo>→</mo><mtext mathvariant="normal">Stream a</mtext></mrow><annotation encoding="application/x-tex">\begin{equation}
\text{Cons} : \text{a}
\rightarrow \rhd^\mathsf{K}\text{Stream a}
\rightarrow \text{Stream a}
\end{equation}</annotation></semantics></math>
<p>Let’s first try express some of this in the free monad:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">K</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">K</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Delay</span><span class="ot"> ::</span> <span class="dt">K</span> <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="dt">Now</span><span class="ot">   ::</span> a <span class="ot">-&gt;</span> <span class="dt">Delay</span> n f m a</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">  <span class="dt">Later</span><span class="ot"> ::</span> f (<span class="dt">DelayT</span> n f m a) <span class="ot">-&gt;</span> <span class="dt">Delay</span> (<span class="dt">S</span> n) f m a</a>
<a class="sourceLine" id="cb28-6" data-line-number="6"></a>
<a class="sourceLine" id="cb28-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Delay</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">  fmap f (<span class="dt">Now</span> x) <span class="fu">=</span> <span class="dt">Now</span> (f x)</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">  fmap f (<span class="dt">Later</span> xs) <span class="fu">=</span> <span class="dt">Later</span> (fmap (fmap f) xs)</a>
<a class="sourceLine" id="cb28-10" data-line-number="10"></a>
<a class="sourceLine" id="cb28-11" data-line-number="11"><span class="kw">newtype</span> <span class="dt">DelayT</span> n f m a <span class="fu">=</span> <span class="dt">DelayT</span> {<span class="ot"> runDelayT ::</span> m (<span class="dt">Delay</span> n f m a) }</a>
<a class="sourceLine" id="cb28-12" data-line-number="12"></a>
<a class="sourceLine" id="cb28-13" data-line-number="13"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb28-14" data-line-number="14">         <span class="dt">Functor</span> (<span class="dt">DelayT</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">    fmap f <span class="fu">=</span> <span class="dt">DelayT</span> <span class="fu">.</span> fmap (fmap f) <span class="fu">.</span> runDelayT</a></code></pre></div>
<p>We can straight away express one of the combinators from the paper, <code class="sourceCode haskell">force</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">force ::</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> (<span class="ot">∀</span> k<span class="fu">.</span> <span class="dt">DelayT</span> k f m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">force (<span class="dt">DelayT</span> xs) <span class="fu">=</span> fmap f xs</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="ot">    f ::</span> <span class="dt">Delay</span> <span class="dt">Z</span> f m a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    f (<span class="dt">Now</span> x) <span class="fu">=</span> x</a></code></pre></div>
<p>Similar trick to <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad-ST.html#v:runST"><code class="sourceCode haskell">runST</code></a> here: if the type is delayed however long we want it to be, then it mustn’t really be delayed at all.</p>
<p>Next, remember that we have types for streams (generators) from the <code class="sourceCode haskell"><span class="dt">IterT</span></code> monad:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Stream</span> n a <span class="fu">=</span> <span class="dt">DelayT</span> n ((,) a)</a></code></pre></div>
<p>And cons does indeed have the right type:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="ot">cons ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> n a m b <span class="ot">-&gt;</span> <span class="dt">Stream</span> (<span class="dt">S</span> n) a m b</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">cons x xs <span class="fu">=</span> <span class="dt">DelayT</span> (pure (<span class="dt">Later</span> (x,xs)))</a></code></pre></div>
<p>We also get an applicative:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">DelayT</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    pure <span class="fu">=</span> <span class="dt">DelayT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Now</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    <span class="dt">DelayT</span> fs&#39; <span class="fu">&lt;*&gt;</span> <span class="dt">DelayT</span> xs&#39; <span class="fu">=</span> <span class="dt">DelayT</span> (liftA2 go fs&#39; xs&#39;)</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6"><span class="ot">        go ::</span> <span class="ot">∀</span> k a b<span class="fu">.</span> <span class="dt">Delay</span> k f m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Delay</span> k f m a <span class="ot">-&gt;</span> <span class="dt">Delay</span> k f m b</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        go (<span class="dt">Now</span> f) <span class="fu">=</span> fmap f</a>
<a class="sourceLine" id="cb32-8" data-line-number="8">        go (<span class="dt">Later</span> fs) <span class="fu">=</span> <span class="dt">Later</span> <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">            <span class="dt">Now</span> x <span class="ot">-&gt;</span> fmap (fmap (<span class="fu">$</span>x)) fs</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">            <span class="dt">Later</span> xs <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;*&gt;</span>) fs xs</a></code></pre></div>
<p>Now, I’m not sure how much this stuff actually corresponds to the paper, but what caught my eye is the statement that <code class="sourceCode haskell"><span class="dt">De</span></code> is a classic “applicative-not-monad”: just like <code class="sourceCode haskell"><span class="dt">ZipList</span></code>. However, under the analogy that the free monad is listy, and the parallel construction is ziplist-y, what we have in the <code class="sourceCode haskell"><span class="dt">DelayT</span></code> is the equivalent of a length-indexed list. These have an applicative instance similar to ziplists: but they also have a monad. Can we apply the same trick here?</p>
<h1 id="future-posts">Future Posts</h1>
<p>There’s a lot of fascinating stuff out there—about clock variables, especially—that I hope to get a chance to learn about once I get a chance. What I’m particularly interested to follow up on includes:</p>
<ol>
<li>Comonads and their relationship to these constructions. Streams are naturally expressed as comonads, could they be used as a basis on which to build a similar “delay” mechanism?</li>
<li>I’d love to explore more efficient implementations like the ones in <span class="citation" data-cites="spivey_faster_2017">Spivey (<a href="#ref-spivey_faster_2017">2017</a>)</span>.</li>
<li>I’m interested to see the relationship between these types, power series, and algebras for combinatorial search <span class="citation" data-cites="spivey_algebras_2009">(Spivey <a href="#ref-spivey_algebras_2009">2009</a>)</span>.</li>
</ol>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-atkey_how_2011">
<p>Atkey, Robert. 2011. “How to be a Productive Programmer - by putting things off until tomorrow.” Heriot-Watt University.</p>
</div>
<div id="ref-atkey_productive_2013">
<p>Atkey, Robert, and Conor McBride. 2013. “Productive coprogramming with guarded recursion.” In, 197. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500597">10.1145/2500365.2500597</a>.</p>
</div>
<div id="ref-blazevic_coroutine_2011">
<p>Blažević, Mario. 2011. “Coroutine Pipelines.” <em>The Monad.Reader</em> 19 (19) (August): 29–50.</p>
</div>
<div id="ref-capretta_partiality_2004">
<p>Capretta, Venanzio, Thorsten Altenkirch, and Tarmo Uustalu. 2004. “Partiality is an effect.” In <em>Dependently Typed Programming</em>, 04381:20. Dagstuhl seminar proceedings. Dagstuhl, Germany: Internationales Begegnungs- und Forschungszentrum für Informatik (IBFI), Schloss Dagstuhl, Germany.</p>
</div>
<div id="ref-gonzalez_pipes_2018">
<p>Gonzalez, Gabriel. 2018. “Pipes: Compositional pipelines.”</p>
</div>
<div id="ref-kiselyov_iteratees_2012">
<p>Kiselyov, Oleg. 2012. “Iteratees.” In <em>Proceedings of the 11th International Conference on Functional and Logic Programming</em>, 166–181. Lecture notes in computer science. Berlin, Heidelberg: Springer, Berlin, Heidelberg. doi:<a href="https://doi.org/10.1007/978-3-642-29822-6_15">10.1007/978-3-642-29822-6_15</a>.</p>
</div>
<div id="ref-mcbride_time_2009">
<p>McBride, Conor. 2009. “Time flies like an applicative functor.” <em>Epilogue for Epigram</em>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. “Algebras for combinatorial search.” <em>Journal of Functional Programming</em> 19 (3-4) (July): 469–487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>.</p>
</div>
<div id="ref-spivey_faster_2017">
<p>Spivey, Michael. 2017. “Faster coroutine pipelines.” <em>Proceedings of the ACM on Programming Languages</em> 1 (ICFP) (August): 1–23. doi:<a href="https://doi.org/10.1145/3110249">10.1145/3110249</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There is a later, seemingly more formal version of the talk available <span class="citation" data-cites="capretta_partiality_2005">(<span class="citeproc-not-found" data-reference-id="capretta_partiality_2005"><strong>???</strong></span>)</span>, but the one from 2004 was a little easier for me to understand, and had a lot more Haskell code.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Small note: <code>(,) a</code> and <code>(-&gt;) a</code> are adjunct. I wonder if there is any implication from this? Certainly, producers and consumers seem adjunct, but there’s no instance I can find for it in adjunctions.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 23 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-23-scheduling-effects.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Breadth-First Traversals in Far Too Much Detail</title>
    <link>https://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  3, 2018
</div>
<div class="info">
    
        Part 3 of a <a href="/series/Breadth-First%20Traversals.html">4-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>After looking at the algorithms I <a href="2018-06-01-rose-trees-breadth-first-traversing.html">posted last time</a>, I noticed some patterns emerging which I thought deserved a slightly longer post. I’ll go through the problem <span class="citation" data-cites="gibbons_breadth-first_2015">(Gibbons <a href="#ref-gibbons_breadth-first_2015">2015</a>)</span> in a little more detail, and present some more algorithms to go along with it.</p>
<h1 id="the-problem">The Problem</h1>
<p>The original question was posed by <a href="https://www.facebook.com/groups/programming.haskell/permalink/985981691412832/">Etian Chatav</a>:</p>
<blockquote>
<p>What is the correct way to write breadth first traversal of a <code class="sourceCode haskell">[<span class="dt">Tree</span>]</code>?</p>
</blockquote>
<p>The breadth-first traversal here is a traversal in the lensy sense, i.e:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a] <span class="ot">-&gt;</span> f [<span class="dt">Tree</span> b]</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">Tree</span></code> type we’re referring to here is a rose tree; we can take the one defined in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#t:Tree"><code class="sourceCode haskell"><span class="dt">Data.Tree</span></code></a>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    {<span class="ot"> rootLabel ::</span> a</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    ,<span class="ot"> subForest ::</span> [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    }</a></code></pre></div>
<p>Finally, instead of solving the (somewhat intermediate) problem of traversing a forest, we’ll look directly at traversing the tree itself. In other words, our solution should have the type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a></code></pre></div>
<h1 id="breadth-first-enumeration">Breadth-First Enumeration</h1>
<p>As in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>, let’s first look at just converting the tree to a list in breadth-first order. In other words, given the tree:</p>
<pre><code>   ┌3
 ┌2┤
 │ └4
1┤
 │ ┌6
 └5┤
   └7</code></pre>
<p>We want the list:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]</a></code></pre></div>
<p>Last time I looked at this problem, the function I arrived at was as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">breadthFirstEnumerate ts <span class="fu">=</span> f ts b []</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>It’s admittedly a little difficult to understand, but it’s really not too complex: we’re popping items off the front of a queue, and pushing the subforest onto the end. <code class="sourceCode haskell">fw</code> is the recursive call here: that’s where we send the queue with the element pushed on. Even though it may <em>look</em> like we’re pushing onto the front (as we’re using a cons), this is really the <em>end</em> of the queue, since it’s being consumed in reverse, with <code class="sourceCode haskell">foldl</code>.</p>
<p>We can compare it to the technique used in <span class="citation" data-cites="allison_circular_2006">Allison (<a href="#ref-allison_circular_2006">2006</a>)</span> and <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>, where it’s called <em>corecursive queues</em>. Breadth-first enumeration is accomplished as follows in <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">levelOrder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">levelOrder tr <span class="fu">=</span> map rootLabel qs</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    qs <span class="fu">=</span> enqs [tr] <span class="dv">0</span> qs</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    enqs []     n xs <span class="fu">=</span> deq n xs</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    enqs (t<span class="fu">:</span>ts) n xs <span class="fu">=</span> t <span class="fu">:</span> enqs  ts (n<span class="fu">+</span><span class="dv">1</span>) xs</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    deq <span class="dv">0</span> _      <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    deq n (x<span class="fu">:</span>xs) <span class="fu">=</span> enqs (subForest x) (n<span class="fu">-</span><span class="dv">1</span>) xs</a></code></pre></div>
<p>We get to avoid tracking the length of the queue, however.</p>
<h1 id="level-order-enumeration">Level-Order Enumeration</h1>
<p>Before we go the full way to traversal, we can try add a little structure to our breadth-first enumeration, by delimiting between levels in the tree. We want our function to have the following type:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>Looking back at our example tree:</p>
<pre><code>   ┌3
 ┌2┤
 │ └4
1┤
 │ ┌6
 └5┤
   └7</code></pre>
<p>We now want the list:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]]</a></code></pre></div>
<p>This function is strictly more powerful than <code class="sourceCode haskell">breadthFirstEnumerate</code>, as we can define one in terms of the other:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">breadthFirstEnumerate <span class="fu">=</span> concat <span class="fu">.</span> levels</a></code></pre></div>
<p>It’s also just a generally useful function, so there are several example implementations available online.</p>
<h3 id="iterative-style">Iterative-Style</h3>
<p>The one provided in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/src/Data.Tree.html#levels">Data.Tree</a> is as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">levels t <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    map (map rootLabel) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">        takeWhile (not <span class="fu">.</span> null) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        iterate (concatMap subForest) [t]</a></code></pre></div>
<p>Pretty nice, but it looks to me like it’s doing a lot of redundant work. We could write it as an unfold:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">levels t <span class="fu">=</span>  unfoldr (f <span class="fu">.</span> concat) [[t]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    f [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    f xs <span class="fu">=</span> <span class="dt">Just</span> (unzip [(y,ys) <span class="fu">|</span> <span class="dt">Node</span> y ys <span class="ot">&lt;-</span> xs])</a></code></pre></div>
<p>The performance danger here lies in <code class="sourceCode haskell">unzip</code>: one could potentially optimize that for a speedup.</p>
<h3 id="with-an-implicit-queue">With an (implicit) Queue</h3>
<p>Another definition, in the style of <code class="sourceCode haskell">breadthFirstEnumerate</code> above, is as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">levels ts <span class="fu">=</span> f b ts [] []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<p>Here, we maintain a stack building up the current level, as well as a queue that we send to the next level. Because we’re consing onto the front of the stack, the subforest needs to be traversed in reverse, to build up the output list in the right order. This is why we’re using a second <code class="sourceCode haskell">foldl</code> here, whereas the original had <code class="sourceCode haskell">foldr</code> on the inner loop.</p>
<h3 id="zippy-style">Zippy-Style</h3>
<p>Looking at the implicit queue version, I noticed that it’s just using a church-encoded pair to reverse the direction of the fold. Instead of doing both reversals, we can use a normal pair, and run it in one direction:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">levels ts <span class="fu">=</span> b (f ts ([],[]))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (ls,qs) <span class="fu">=</span> (x<span class="fu">:</span>ls,xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    b (_,[]) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    b (k,qs) <span class="fu">=</span> k <span class="fu">:</span> b (foldr (flip (foldr f)) ([],[]) qs)</a></code></pre></div>
<p>Secondly, we’re running a fold on the second component of the pair: why not run the fold immediately, rather than building the intermediate list. In fact, we’re running a fold over the <em>whole</em> thing, which we can do straight away:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">levels ts <span class="fu">=</span> f ts []</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>After looking at it for a while, I realized it’s similar to an inlined version of the algorithm presented in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">levels t <span class="fu">=</span> [rootLabel t] <span class="fu">:</span> foldr (lzw (<span class="fu">++</span>)) [] (map levels (subForest t))</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    lzw f (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> f x y <span class="fu">:</span> lzw f xs ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    lzw _ xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    lzw _ [] ys <span class="fu">=</span> ys</a></code></pre></div>
<h1 id="cofree">Cofree</h1>
<p>Before going any further, all of the functions so far can be redefined to work on the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Comonad-Cofree.html">cofree comonad</a>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>When <code class="sourceCode haskell">f</code> is specialized to <code class="sourceCode haskell">[]</code>, we get the original rose tree. So far, though, all we actually require is <code class="sourceCode haskell"><span class="dt">Foldable</span></code>.</p>
<p>From now on, then, we’ll use <code class="sourceCode haskell"><span class="dt">Cofree</span></code> instead of <code class="sourceCode haskell"><span class="dt">Tree</span></code>.</p>
<h1 id="traversing">Traversing</h1>
<p>Finally, we can begin on the traversal itself. We know how to execute the effects in the right order, what’s missing is to build the tree back up in the right order.</p>
<h3 id="filling">Filling</h3>
<p>First thing we’ll use is a trick with <code class="sourceCode haskell"><span class="dt">Traversable</span></code>, where we fill a container from a list. In other words:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fill [(),(),(),()] [<span class="dv">1</span><span class="fu">..</span>] <span class="fu">=</span> ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">5</span><span class="fu">..</span>])</a></code></pre></div>
<p>With the state monad (or applicative, in this case, I suppose), we can define a “pop” action, which takes an element from the supply:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">pop <span class="fu">=</span> state (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x,xs))</a></code></pre></div>
<p>And then we <code class="sourceCode haskell">traverse</code> that action over our container:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>When we use fill, it’ll have the following type:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">breadthFirst <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">    fill ::</span> t (<span class="dt">Cofree</span> t a) <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">Cofree</span> t b] (t (<span class="dt">Cofree</span> t b))</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>Hopefully that makes sense: we’re going to get the subforest from here:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> t a <span class="fu">=</span> a <span class="fu">:&lt;</span> t (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">                       <span class="fu">^^^^^^^^^^^^^^</span></a></code></pre></div>
<p>And we’re going to fill it with the result of the traversal, which changes the contents from <code>a</code>s to <code>b</code>s.</p>
<h3 id="composing-applicatives">Composing Applicatives</h3>
<p>One of the nice things about working with applicatives is that they compose, in a variety of different ways. In other words, if I have one effect, <code class="sourceCode haskell">f</code>, and another <code class="sourceCode haskell">g</code>, and I want to run them both on the contents of some list, I can do it in one pass, either by layering the effects, or putting them side-by-side.</p>
<p>In our case, we need to deal with two effects: the one generated by the traversal, (the one the caller wants to use), and the internal state we’re using to fill up the forests in our tree. We could use <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Functor-Compose.html#t:Compose"><code class="sourceCode haskell"><span class="dt">Compose</span></code></a> explicitly, but we can avoid some calls to <code class="sourceCode haskell">pure</code> if we write the combinators we’re going to use directly:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">map2</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">map2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    fmap (\y <span class="ot">-&gt;</span> fmap (f y) xs) x</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">app2</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> g)</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c) <span class="ot">-&gt;</span> f (g d)</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">app2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    liftA2 (\y <span class="ot">-&gt;</span> liftA2 (f y) xs) x</a></code></pre></div>
<p>The outer applicative (<code>f</code>) will be the user’s effect, the inner will be <code>State</code>.</p>
<h1 id="take-1-zippy-style-traversing">Take 1: Zippy-Style Traversing</h1>
<p>First we’ll try convert the zippy-style <code class="sourceCode haskell">levels</code> to a traversal. First, convert the function over to the cofree comonad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">levels tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, instead of building up a list of just the root labels, we’ll pair them with the subforests:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, we’ll fill the subforests:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Then, we can run the applicative effect on the root label:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((c x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(c x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Now, to combine the effects, we can use the combinators we defined before:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>This builds a list containing all of the level-wise traversals of the tree. To collapse them into one, we can use a fold:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">             <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">             <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    head <span class="fu">&lt;$&gt;</span> foldr (liftA2 evalState) (pure []) (f tr [])</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-11" data-line-number="11">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<h1 id="take-2-queue-based-traversing">Take 2: Queue-Based Traversing</h1>
<p>Converting the queue-based implementation is easy once we’ve done it with the zippy one. The result is (to my eye) a little easier to read, also:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    fmap head (f b tr e [])</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">      k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) ls) (xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb31-9" data-line-number="9"></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    b _ [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">    b l qs <span class="fu">=</span> liftA2 evalState l (foldl (foldl f) b qs e [])</a>
<a class="sourceLine" id="cb31-12" data-line-number="12"></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>There are a couple things to notice here: first, we’re not using <code class="sourceCode haskell">map2</code> anywhere. That’s because in the zippy version we were able to notice when the queue was exhausted, so we could just output the singleton effect. Here, instead, we’re using <code class="sourceCode haskell">pure (pure [])</code>: this is potentially a source of inefficiency, as <code class="sourceCode haskell">liftA2 f (pure x) y</code> is less efficient than <code class="sourceCode haskell">fmap (f x) y</code> for some applicatives.</p>
<p>On the other hand, we don’t build up a list of levels to be combined with <code class="sourceCode haskell">foldr (liftA2 evalState)</code> at any point: we combine them at every level immediately. You may be able to do the same in the zippy version, but I haven’t figured it out yet.</p>
<h3 id="yoneda">Yoneda</h3>
<p>The final point to make here is to do with the very last thing we do in the traversal: <code class="sourceCode haskell">fmap head</code>. Strictly speaking, any <code class="sourceCode haskell">fmap</code>s in the code should be unnecessary: we <em>should</em> be able to fuse them all with any call to <code class="sourceCode haskell">liftA2</code>. This transformation is often called the “Yoneda embedding”. We can use it here like so:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot">    ::</span> <span class="ot">∀</span> t a f b<span class="fu">.</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span> f (b head) tr e []</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="ot">    b ::</span> <span class="ot">∀</span> x<span class="fu">.</span> ([<span class="dt">Cofree</span> t b] <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">      <span class="ot">-&gt;</span> f (<span class="dt">State</span> [<span class="dt">Cofree</span> t b] [<span class="dt">Cofree</span> t b])</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">      <span class="ot">-&gt;</span> [t (<span class="dt">Cofree</span> t a)]</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">      <span class="ot">-&gt;</span> f x</a>
<a class="sourceLine" id="cb32-13" data-line-number="13">    b k _ [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    b k l qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-15" data-line-number="15">        liftA2 (\x <span class="ot">-&gt;</span> k <span class="fu">.</span> evalState x) l (foldl (foldl f) (b id) qs e [])</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>Notice that we need scoped type variables here, since the type of <code class="sourceCode haskell">b</code> changes depending on when it’s called.</p>
<h1 id="take-3-iterative-traversing">Take 3: Iterative Traversing</h1>
<p>Transforming the iterative version is slightly different from the other two:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-5" data-line-number="5">        liftA2</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">            evalState</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">            (go (foldr (\(_<span class="fu">:&lt;</span>ys) b <span class="ot">-&gt;</span> foldr (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">    f (x<span class="fu">:&lt;</span>xs) <span class="fu">=</span> <span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs))</a></code></pre></div>
<p>We’re using <code class="sourceCode haskell"><span class="dt">Compose</span></code> directly here, in contrast to the other two algorithms.</p>
<h1 id="comparison">Comparison</h1>
<p>Performance-wise, no one algorithm wins out in every case. For enumeration, the zippy algorithm is the fastest in most cases—except when the tree had a large branching factor; then, the iterative algorithm wins out. For the traversals, the iterative algorithm is usually better—except for monads with more expensive applicative instances.</p>
<p>I’m still not convinced that the zippy traversal is as optimized as it could be, however. If anyone has a better implementation, I’d love to see it!</p>
<h1 id="fusion">Fusion</h1>
<p>Using the composability of applicatives, we can fuse several operations over traversables into one pass. Unfortunately, however, this can often introduce a memory overhead that makes the whole operation slower overall. One such example is the iterative algorithm above:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    go xs <span class="fu">=</span> liftA2 evalState zs (go (ys []))</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">        <span class="dt">Compose</span> (<span class="dt">Endo</span> ys,<span class="dt">Compose</span> zs) <span class="fu">=</span> traverse f xs</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">    f (x <span class="fu">:&lt;</span> xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">        <span class="dt">Compose</span></a>
<a class="sourceLine" id="cb34-9" data-line-number="9">            (<span class="dt">Endo</span> (flip (foldr (<span class="fu">:</span>)) xs)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">            ,<span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs)))</a></code></pre></div>
<p>We only traverse the subforest of each node once now, fusing the fill operation with building the list to send to the recursive call. This is expensive (especially memory-wise), though, and traversing the descendant is cheap; the result is that the one-pass version is slower (in my tests).</p>
<h1 id="generalizing">Generalizing</h1>
<p>The cofree comonad allows us to generalize over the type of “descendants”—from lists (in <code class="sourceCode haskell"><span class="dt">Tree</span></code>) to anything traversable. We could also generalize over the type of the traversal itself: given a way to access the descendants of a node, we should be able to traverse all nodes in a breadth-first order. This kind of thing is usually accomplished by <a href="http://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Plated.html">Plated</a>: it’s a class that gives you a traversal over the immediate descendants of some recursive type. Adapting the iterative version is relatively simple:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">breadthFirstOf ::</span> <span class="dt">Traversal&#39;</span> a a <span class="ot">-&gt;</span> <span class="dt">Traversal&#39;</span> a a</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">breadthFirstOf trav c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">        liftA2</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">            evalState</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb35-9" data-line-number="9">            (go (foldr (\ys b <span class="ot">-&gt;</span> foldrOf trav (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb35-10" data-line-number="10">    f xs <span class="fu">=</span> <span class="dt">Compose</span> (fmap fill (c xs))</a>
<a class="sourceLine" id="cb35-11" data-line-number="11">    fill <span class="fu">=</span> trav (const (<span class="dt">State</span> (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x, xs))))</a></code></pre></div>
<p>We can use this version to get back some of the old functions above:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span>  <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> <span class="dt">Cofree</span> f a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">breadthFirstEnumerate <span class="fu">=</span> toListOf (breadthFirstOf plate <span class="fu">.</span> _extract)</a></code></pre></div>
<h1 id="unfolding">Unfolding</h1>
<p>Building a tree breadth-first, monadically, is still an unsolved problem <span class="citation" data-cites="feuer_is_2015">(it looks like: Feuer <a href="#ref-feuer_is_2015">2015</a>)</span>.</p>
<p>Using some of these we can implement a monadic breadth-first unfold for the cofree comonad:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">unfoldM ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">        <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, t b))</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">        <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">        <span class="ot">-&gt;</span> m (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">unfoldM c tr <span class="fu">=</span> go head [tr]</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">    go k [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">    go k xs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb37-9" data-line-number="9">        ys <span class="ot">&lt;-</span> traverse c xs</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">        go (k <span class="fu">.</span> evalState (traverse f ys)) (toList (<span class="dt">Compose</span> (<span class="dt">Compose</span> ys)))</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">    f (x,xs) <span class="fu">=</span> fmap (x<span class="fu">:&lt;</span>) (fill xs)</a></code></pre></div>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. “Circular Programs and Self-Referential Structures.” <em>Software: Practice and Experience</em> 19 (2) (October 30): 99–109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>. <a href="http://users.monash.edu/~lloyd/tildeFP/1989SPE/" class="uri">http://users.monash.edu/~lloyd/tildeFP/1989SPE/</a>.</p>
</div>
<div id="ref-feuer_is_2015">
<p>Feuer, David. 2015. “Is a lazy, breadth-first monadic rose tree unfold possible?” Question. <em>Stack Overflow</em>. <a href="https://stackoverflow.com/q/27748526" class="uri">https://stackoverflow.com/q/27748526</a>.</p>
</div>
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. “Breadth-First Traversal.” <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. “Lloyd Allison’s Corecursive Queues: Why Continuations Matter.” <em>The Monad.Reader</em>, July 29. <a href="https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf" class="uri">https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 03 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>

    </channel>
</rss>
