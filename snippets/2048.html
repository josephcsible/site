<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>2048 - Donnacha Oisín Kidney</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>2048</h2>

            <div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#-----------------------------functional-helpers-------------------------#</span>

<span class="im">from</span> functools <span class="im">import</span> <span class="bu">reduce</span>, partial

<span class="kw">def</span> compose(<span class="op">*</span>funcs):

  <span class="co">&quot;&quot;&quot;</span>
<span class="co">  Mathematical function composition.</span>
<span class="co">  compose(h, g, f)(x) =&gt; h(g(f(x)))</span>
<span class="co">  &quot;&quot;&quot;</span>

  <span class="cf">return</span> <span class="bu">reduce</span>(<span class="kw">lambda</span> a,e: <span class="kw">lambda</span> x: a(e(x)), funcs, <span class="kw">lambda</span> x: x)

<span class="co">#-----------------------------------base---------------------------------#</span>

<span class="co"># The base determines three things:</span>
<span class="co">#  - The number of squares which need to be in a row to coalesce (= base)</span>
<span class="co">#  - The length of the side of the board (= base^2)</span>
<span class="co">#  - The number added to a random blank box on the board at the beginning</span>
<span class="co">#    of every turn. (The seed) (90% of the time, the number added will be</span>
<span class="co">#    the base, but 10% of the time, it will be the square of the base)</span>
<span class="co">#  - The number of seeds added at evey turn (= 2^(base - 2))</span>
<span class="co">#</span>
<span class="co"># Normal 2048 has a base of 2.</span>

base <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">&quot;Choose a base. (2 for normal 2048)</span><span class="ch">\n</span><span class="st">&gt; &quot;</span>))

<span class="co">#-----------------------------------rand---------------------------------#</span>

<span class="kw">def</span> addn(board):

  <span class="co">&quot;&quot;&quot;</span>
<span class="co">  Inserts n seeds into random, empty positions in board. Returns board.</span>
<span class="co">  n = 2^(base - 2)</span>
<span class="co">  The  seed is equal to base 90% of the time. 10% of the time, it is</span>
<span class="co">  equal to the square of the base.</span>
<span class="co">  &quot;&quot;&quot;</span>

  <span class="im">from</span> random <span class="im">import</span> randrange, sample

  inds    <span class="op">=</span> <span class="bu">range</span>(base<span class="op">**</span><span class="dv">2</span>)
  empties <span class="op">=</span> [(y,x) <span class="cf">for</span> y <span class="kw">in</span> inds <span class="cf">for</span> x <span class="kw">in</span> inds <span class="cf">if</span> <span class="kw">not</span> board[y][x]]
  <span class="cf">for</span> y,x <span class="kw">in</span> sample(empties,<span class="dv">2</span><span class="op">**</span>(base<span class="op">-</span><span class="dv">2</span>)):
    board[y][x] <span class="op">=</span> base <span class="cf">if</span> randrange(<span class="dv">10</span>) <span class="cf">else</span> base<span class="op">**</span><span class="dv">2</span>
  <span class="cf">return</span> board

<span class="co">#----------------------------------squish--------------------------------#</span>

<span class="im">from</span> itertools <span class="im">import</span> count, groupby, starmap

<span class="kw">def</span> squish(row):

  <span class="co">&quot;&quot;&quot;</span>
<span class="co">  Returns a list, the same length as row, with the contents</span>
<span class="co">  &quot;squished&quot; by the rules of 2048.</span>
<span class="co">  Boxes are coalesced by adding their values together.</span>
<span class="co">  Boxes will be coalesced iff:</span>
<span class="co">   - They are adjacent, or there are only empty boxes between them.</span>
<span class="co">   - The total number of boxes is equal to the base.</span>
<span class="co">   - All the values of the boxes are equal.</span>
<span class="co">  For base 2:</span>
<span class="co">  [2][2][ ][ ] -&gt; [4][ ][ ][ ]</span>
<span class="co">  [2][2][2][2] -&gt; [4][4][ ][ ]</span>
<span class="co">  [4][ ][4][2] -&gt; [8][2][ ][ ]</span>
<span class="co">  [4][2][4][2] -&gt; [4][2][4][2]</span>
<span class="co">  For base 3:</span>
<span class="co">  [3][ ][ ][3][ ][ ][3][ ][ ] -&gt; [9][ ][ ][ ][ ][ ][ ][ ][ ]</span>
<span class="co">  [3][3][3][3][3][3][3][3][3] -&gt; [9][9][9][ ][ ][ ][ ][ ][ ]</span>
<span class="co">  [3][3][3][9][9][ ][ ][ ][ ] -&gt; [9][9][9][ ][ ][ ][ ][ ][ ]</span>
<span class="co">  Keyword arguments:</span>
<span class="co">  row -- A list, containing a combination of numbers and None</span>
<span class="co">  (representing empty boxes)</span>
<span class="co">  &quot;&quot;&quot;</span>

  r <span class="op">=</span> []
  <span class="cf">for</span> n,x <span class="kw">in</span> starmap(<span class="kw">lambda</span> n, a: (n, <span class="bu">sum</span>(<span class="bu">map</span>(<span class="bu">bool</span>,a))),
                     groupby(<span class="bu">filter</span>(<span class="bu">bool</span>, row))):
    r <span class="op">+=</span> ([n<span class="op">*</span>base] <span class="op">*</span> (x<span class="op">//</span>base)) <span class="op">+</span> ([n] <span class="op">*</span> (x<span class="op">%</span>base))
  <span class="cf">return</span> r <span class="op">+</span> ([<span class="va">None</span>] <span class="op">*</span> (base<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="bu">len</span>(r)))

<span class="co">#----------------------------matrix-manipulation-------------------------#</span>

<span class="co"># Transposes an iterable of iterables</span>
<span class="co"># [[1, 2], -&gt; [[1, 3],</span>
<span class="co">#  [3, 4]]     [2, 4]]</span>

<span class="kw">def</span> transpose(l): <span class="cf">return</span> [<span class="bu">list</span>(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">zip</span>(<span class="op">*</span>l)]

<span class="co"># Flips horizontally an iterable of lists</span>
<span class="co"># [[1, 2], -&gt; [[2, 1],</span>
<span class="co">#  [3, 4]]     [4, 3]]</span>

flip <span class="op">=</span> partial(<span class="bu">map</span>, <span class="bu">reversed</span>)

<span class="co"># transforms an iterable of iterables into a list of lists</span>

thunk <span class="op">=</span> compose(<span class="bu">list</span>, partial(<span class="bu">map</span>, <span class="bu">list</span>))

<span class="co">#----------------------------------moves---------------------------------#</span>

<span class="co"># The move functions take a board as their argument, and return the board</span>
<span class="co"># &quot;squished&quot; in a given direction.</span>

moveLeft  <span class="op">=</span> compose(thunk, partial(<span class="bu">map</span>, squish), thunk)
moveRight <span class="op">=</span> compose(thunk, flip, moveLeft, flip)
moveUp    <span class="op">=</span> compose(transpose, moveLeft, transpose)
moveDown  <span class="op">=</span> compose(transpose, moveRight, transpose)

<span class="co">#-------------------------------curses-init------------------------------#</span>

<span class="im">import</span> curses

screen <span class="op">=</span> curses.initscr()
curses.noecho()           <span class="co"># Don't print pressed keys</span>
curses.cbreak()           <span class="co"># Don't wait for enter</span>
screen.keypad(<span class="va">True</span>)
curses.curs_set(<span class="va">False</span>)    <span class="co"># Hide cursor</span>

<span class="co">#----------------------------------keymap--------------------------------#</span>

<span class="co"># A map from the arrow keys to the movement functions</span>

moves <span class="op">=</span> {curses.KEY_RIGHT: moveRight,
         curses.KEY_LEFT : moveLeft ,
         curses.KEY_UP   : moveUp   ,
         curses.KEY_DOWN : moveDown }

<span class="co">#----------------------------------color---------------------------------#</span>

curses.start_color()
curses.use_default_colors()
curses.init_pair(<span class="dv">1</span>, curses.COLOR_WHITE, <span class="op">-</span><span class="dv">1</span>) <span class="co"># Border color</span>

<span class="kw">def</span> colorfac():

  <span class="co">&quot;&quot;&quot;Initializes a color pair and returns it (skips black)&quot;&quot;&quot;</span>

  <span class="cf">for</span> i,c <span class="kw">in</span> <span class="bu">zip</span>(count(<span class="dv">2</span>),(c <span class="cf">for</span> c <span class="kw">in</span> count(<span class="dv">1</span>) <span class="cf">if</span> c<span class="op">!=</span>curses.COLOR_BLACK)):
    curses.init_pair(i, c, <span class="op">-</span><span class="dv">1</span>)
    <span class="cf">yield</span> curses.color_pair(i)

colorgen <span class="op">=</span> colorfac()

<span class="im">from</span> collections <span class="im">import</span> defaultdict

<span class="co"># A cache of colors, with the keys corresponding to numbers on the board.</span>

colors <span class="op">=</span> defaultdict(<span class="kw">lambda</span>: <span class="bu">next</span>(colorgen))

<span class="co">#---------------------------printing-the-board---------------------------#</span>

size <span class="op">=</span> <span class="bu">max</span>(<span class="dv">11</span> <span class="op">-</span> base<span class="op">*</span><span class="dv">2</span>, <span class="dv">3</span>) <span class="co"># box width</span>

<span class="kw">def</span> printBoard(board):

  <span class="kw">def</span> line(b,c): <span class="cf">return</span> b <span class="op">+</span> b.join([c<span class="op">*</span>(size)]<span class="op">*</span><span class="bu">len</span>(board)) <span class="op">+</span> b
  border, gap <span class="op">=</span> line(<span class="st">&quot;+&quot;</span>,<span class="st">&quot;-&quot;</span>), line(<span class="st">&quot;|&quot;</span>,<span class="st">&quot; &quot;</span>)
  pad <span class="op">=</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>.join([gap]<span class="op">*</span>((size<span class="op">-</span><span class="dv">2</span>)<span class="op">//</span><span class="dv">4</span>)) <span class="cf">if</span> size <span class="op">&gt;</span> <span class="dv">5</span> <span class="cf">else</span> <span class="st">&quot;&quot;</span>
  screen.addstr(<span class="dv">0</span>, <span class="dv">0</span>, border, curses.color_pair(<span class="dv">1</span>))
  <span class="cf">for</span> row <span class="kw">in</span> board:
    screen.addstr(pad <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">|&quot;</span>, curses.color_pair(<span class="dv">1</span>))
    <span class="cf">for</span> e <span class="kw">in</span> row:
      <span class="cf">if</span> e: screen.addstr(<span class="bu">str</span>(e).center(size), colors[e])
      <span class="cf">else</span>: screen.addstr(<span class="st">&quot; &quot;</span> <span class="op">*</span> size)
      screen.addstr(<span class="st">&quot;|&quot;</span>, curses.color_pair(<span class="dv">1</span>))
    screen.addstr(pad <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="op">+</span> border, curses.color_pair(<span class="dv">1</span>))

<span class="co">#----------------------------------board---------------------------------#</span>

<span class="co"># The board is a list of n lists, each of length n, where n is the base</span>
<span class="co"># squared. Empty boxes are represented by None. The starting board has</span>
<span class="co"># one seed.</span>

board <span class="op">=</span> addn([[<span class="va">None</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(base<span class="op">**</span><span class="dv">2</span>)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(base<span class="op">**</span><span class="dv">2</span>)])
printBoard(board)

<span class="co">#--------------------------------game-loop-------------------------------#</span>

<span class="co"># The main game loop. Continues until there are not enough empty spaces</span>
<span class="co"># on the board, or &quot;q&quot; is pressed.</span>

<span class="cf">for</span> char <span class="kw">in</span> <span class="bu">filter</span>(moves.<span class="fu">__contains__</span>, <span class="bu">iter</span>(screen.getch, <span class="bu">ord</span>(<span class="st">&quot;q&quot;</span>))):
  moved <span class="op">=</span> moves[char](board)
  <span class="cf">if</span> <span class="bu">sum</span>(<span class="kw">not</span> n <span class="cf">for</span> r <span class="kw">in</span> moved <span class="cf">for</span> n <span class="kw">in</span> r) <span class="op">&lt;</span> <span class="dv">2</span><span class="op">**</span>(base<span class="op">-</span><span class="dv">2</span>): <span class="cf">break</span>
  <span class="cf">if</span> moved <span class="op">!=</span> board: board <span class="op">=</span> addn(moved)
  printBoard(board)

<span class="co">#--------------------------------clean-up--------------------------------#</span>

curses.nocbreak()     <span class="co"># Wait for enter</span>
screen.keypad(<span class="dv">0</span>)      <span class="co"># Stop arrow-key handling</span>
curses.echo()         <span class="co"># Print all keyboard input</span>
curses.curs_set(<span class="va">True</span>) <span class="co"># Show cursor</span>
curses.endwin()       <span class="co"># Return to normal prompt</span></code></pre></div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
